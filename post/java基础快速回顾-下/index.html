<!DOCTYPE html>
































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-US"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>java基础快速回顾-下 - My Hugo Site</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 //一些参数，一个箭头，一段重写代码 () -&gt; System.out.println(&#34;lambda&#34;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;目录的创建、查找和删除等操作 //File类的4个成员变量 //路径分隔符(windows分号,linux冒号) static String pathSeparator; static char pathSeparatorChar; //默认名称分隔符(windows反斜杠，linux正斜杠) static String separator; static char separator; //注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 /** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 **/ public static void main(){ File f1 = new File(&#34;/home/jack1024/桌面/a.txt&#34;); File f2 = new File(&#34;/home/jack1024/桌面/a&#34;); } File类常用方法： public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径） public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串） public String getName();//文件/目录名字 public long length();//文件字节大小(目录没有大小概念) 判断功能： public boolean exists();//该文件/目录是否存在 public boolean isDirectory();//是否为目录 public boolean isFile();//是否为文件 创建 &amp; 删除 public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件 public boolean delete();//删除由此File表示的文件或目录，不走回收站 public boolean mkdir();//创建由此File表示的目录 public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录 public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示：" />
  <meta
    name="author"
    content=""
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="http://example.org/main.min.css" />

  

  
     
  <link rel="preload" as="image" href="http://example.org/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/44813701?v=4" />
  
  

  
  <link rel="preload" as="image" href="http://example.org/github.svg" />
  

  
  <link rel="icon" href="http://example.org/favicon.ico" />
  <link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.109.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="java基础快速回顾-下" />
<meta property="og:description" content="Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 //一些参数，一个箭头，一段重写代码 () -&gt; System.out.println(&#34;lambda&#34;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;目录的创建、查找和删除等操作 //File类的4个成员变量 //路径分隔符(windows分号,linux冒号) static String pathSeparator; static char pathSeparatorChar; //默认名称分隔符(windows反斜杠，linux正斜杠) static String separator; static char separator; //注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 /** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 **/ public static void main(){ File f1 = new File(&#34;/home/jack1024/桌面/a.txt&#34;); File f2 = new File(&#34;/home/jack1024/桌面/a&#34;); } File类常用方法： public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径） public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串） public String getName();//文件/目录名字 public long length();//文件字节大小(目录没有大小概念) 判断功能： public boolean exists();//该文件/目录是否存在 public boolean isDirectory();//是否为目录 public boolean isFile();//是否为文件 创建 &amp; 删除 public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件 public boolean delete();//删除由此File表示的文件或目录，不走回收站 public boolean mkdir();//创建由此File表示的目录 public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录 public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8B/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-09T11:42:39+00:00" />
<meta property="article:modified_time" content="2021-03-09T11:42:39+00:00" />

  
  <meta itemprop="name" content="java基础快速回顾-下">
<meta itemprop="description" content="Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 //一些参数，一个箭头，一段重写代码 () -&gt; System.out.println(&#34;lambda&#34;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;目录的创建、查找和删除等操作 //File类的4个成员变量 //路径分隔符(windows分号,linux冒号) static String pathSeparator; static char pathSeparatorChar; //默认名称分隔符(windows反斜杠，linux正斜杠) static String separator; static char separator; //注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 /** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 **/ public static void main(){ File f1 = new File(&#34;/home/jack1024/桌面/a.txt&#34;); File f2 = new File(&#34;/home/jack1024/桌面/a&#34;); } File类常用方法： public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径） public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串） public String getName();//文件/目录名字 public long length();//文件字节大小(目录没有大小概念) 判断功能： public boolean exists();//该文件/目录是否存在 public boolean isDirectory();//是否为目录 public boolean isFile();//是否为文件 创建 &amp; 删除 public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件 public boolean delete();//删除由此File表示的文件或目录，不走回收站 public boolean mkdir();//创建由此File表示的目录 public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录 public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示："><meta itemprop="datePublished" content="2021-03-09T11:42:39+00:00" />
<meta itemprop="dateModified" content="2021-03-09T11:42:39+00:00" />
<meta itemprop="wordCount" content="936">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="java基础快速回顾-下"/>
<meta name="twitter:description" content="Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 //一些参数，一个箭头，一段重写代码 () -&gt; System.out.println(&#34;lambda&#34;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;目录的创建、查找和删除等操作 //File类的4个成员变量 //路径分隔符(windows分号,linux冒号) static String pathSeparator; static char pathSeparatorChar; //默认名称分隔符(windows反斜杠，linux正斜杠) static String separator; static char separator; //注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 /** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 **/ public static void main(){ File f1 = new File(&#34;/home/jack1024/桌面/a.txt&#34;); File f2 = new File(&#34;/home/jack1024/桌面/a&#34;); } File类常用方法： public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径） public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串） public String getName();//文件/目录名字 public long length();//文件字节大小(目录没有大小概念) 判断功能： public boolean exists();//该文件/目录是否存在 public boolean isDirectory();//是否为目录 public boolean isFile();//是否为文件 创建 &amp; 删除 public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件 public boolean delete();//删除由此File表示的文件或目录，不走回收站 public boolean mkdir();//创建由此File表示的目录 public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录 public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示："/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="http://example.org/"
      >My Hugo Site</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/YangFanJack "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">java基础快速回顾-下</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Mar 9, 2021</time>
      
      
    </div>
    
  </header>

  <section><h2 id="lambda表达式">Lambda表达式</h2>
<ul>
<li>匿名内部类可以省去定义实现类，但是语法太复杂</li>
<li>lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//一些参数，一个箭头，一段重写代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">()</span> <span style="color:#f92672">-&gt;</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;lambda&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><ul>
<li>将Runnable接口作为参数进行传递，可以使用两种方法：</li>
</ul>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223437.png" alt="image-20210309120501501"></p>
<ul>
<li>使用lambda必须满足接口中有且仅有一个抽象方法</li>
<li>有且仅有一个抽象方法的接口称为 “函数式接口”</li>
<li>Lambda的省略写法有如下要求：
<ol>
<li>括号中参数列表的数据类型可以省略</li>
<li>括号中的参数只有一个，那么类型和（）都可以省略</li>
<li>如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分</li>
</ol>
</li>
</ul>
<h2 id="file类">FIle类</h2>
<ul>
<li><strong>文件和目录</strong>的抽象表示，用于文件&amp;目录的创建、查找和删除等操作</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//File类的4个成员变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//路径分隔符(windows分号,linux冒号)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> String pathSeparator<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> pathSeparatorChar<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//默认名称分隔符(windows反斜杠，linux正斜杠)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> String separator<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">char</span> separator<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//注意：操作路径的时候，路径不能写死了，根据不同系统更换
</span></span></span></code></pre></div><ul>
<li>File构造函数</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	File(String pathname);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	File(String parent,String child);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	File(File parent,String child)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	路径可以是文件名，也可以是文件夹名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	可以相对路径，也可以绝对路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	路径可以是存在的，也可以是不存在的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>    File f1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/桌面/a.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    File f2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> File<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/桌面/a&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>File类常用方法：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getAbsolutePath</span><span style="color:#f92672">();</span><span style="color:#75715e">//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getPath</span><span style="color:#f92672">();</span><span style="color:#75715e">//文件/目录路径名字符串（构造方法中传递的字符串）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span><span style="color:#75715e">//文件/目录名字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">length</span><span style="color:#f92672">();</span><span style="color:#75715e">//文件字节大小(目录没有大小概念)
</span></span></span></code></pre></div><ul>
<li>判断功能：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">exists</span><span style="color:#f92672">();</span><span style="color:#75715e">//该文件/目录是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isDirectory</span><span style="color:#f92672">();</span><span style="color:#75715e">//是否为目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFile</span><span style="color:#f92672">();</span><span style="color:#75715e">//是否为文件
</span></span></span></code></pre></div><ul>
<li>创建 &amp; 删除</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">createNewFile</span><span style="color:#f92672">();</span><span style="color:#75715e">//当该名字的文件不存在时，创建一个新的空文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">delete</span><span style="color:#f92672">();</span><span style="color:#75715e">//删除由此File表示的文件或目录，不走回收站
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">mkdir</span><span style="color:#f92672">();</span><span style="color:#75715e">//创建由此File表示的目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">mkdirs</span><span style="color:#f92672">();</span><span style="color:#75715e">//创建由此File表示的目录，包括任何必须但不存在的父目录
</span></span></span></code></pre></div><ul>
<li>目录遍历
<ul>
<li>包含隐藏文件/文件夹</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String<span style="color:#f92672">[]</span> <span style="color:#a6e22e">list</span><span style="color:#f92672">();</span><span style="color:#75715e">//返回一个String数组，表示该File目录中所有子文件或目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> File<span style="color:#f92672">[]</span> <span style="color:#a6e22e">listFiles</span><span style="color:#f92672">();</span><span style="color:#75715e">//返回一个File数组，表示该File目录中所有子文件或目录
</span></span></span></code></pre></div><h3 id="递归">递归</h3>
<ul>
<li>直接递归 &amp; 间接递归</li>
<li>递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError</li>
<li>递归的次数也不能太多，否则也可能发生栈内存溢出</li>
<li>构造方法中禁止递归</li>
</ul>
<p>递归图示：</p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223505.png" alt="image-20210310002114259"></p>
<h3 id="文件过滤器">文件过滤器</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> File<span style="color:#f92672">[]</span> <span style="color:#a6e22e">listFiles</span><span style="color:#f92672">(</span>FileFilter filter<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> File<span style="color:#f92672">[]</span> <span style="color:#a6e22e">listFiles</span><span style="color:#f92672">(</span>FilenameFilter filter<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>通过重写accept()方法来实现</p>
<h2 id="io流">IO流</h2>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223522.png" alt="image-20210310010209212"></p>
<h3 id="字节流">字节流</h3>
<h4 id="字节输出流">字节输出流</h4>
<ul>
<li>OutputStream：所有输出字节流的超类，接下来主要探讨其子类FileOutputStream：
<ol>
<li>close()：释放资源</li>
<li>flush()：刷新此输出流并强制写出所有缓冲的输出字节</li>
<li>void write(byte[] b)：往文件写入多个字节</li>
<li>void write(int b)：往文件写入一个字节</li>
<li>void write(byte[] b,int off,int len)：往文件写入指定位置指定长度的放入的数组中的字节</li>
</ol>
</li>
<li>FileOutputStream构造方法：
<ol>
<li>FileOutputStream(File file)</li>
<li>FileOutputStream(String name)</li>
<li>FileOutputStream(File file, boolean append)</li>
<li>FileOutputStream(String name, boolean append)</li>
</ol>
</li>
</ul>
<h4 id="字节输入流">字节输入流</h4>
<ul>
<li>InputStream：表示字节输入流的所有子类超类。接下来主要探讨其子类FileInputStream：
<ol>
<li>close()：释放资源</li>
<li>int read(byte[] b)：从文件读取一定数量的字节，并将其存在缓冲区数组b中</li>
<li>int read()：从文件读取一个字节</li>
</ol>
</li>
<li>FileInputStream构造方法：
<ol>
<li>FileInputStream(File file)</li>
<li>FileInputStream(String name)</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>len<span style="color:#f92672">=</span>fis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())!=-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span><span style="color:#ae81ff">0</span><span style="color:#f92672">,</span>len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="字符流">字符流</h3>
<h4 id="字符输入流">字符输入流</h4>
<ul>
<li>
<p>Reader：是一个抽象类</p>
<ol>
<li>int read()</li>
<li>int read(char[] cbuf)</li>
<li>void close()</li>
</ol>
</li>
<li>
<p>FileReader：文件字符输入流</p>
<p>构造方法：</p>
<ol>
<li>FileReader(File file)</li>
<li>FileReader(String name)</li>
</ol>
</li>
</ul>
<h4 id="字符输出流">字符输出流</h4>
<ul>
<li>
<p>Writer：是一个抽象类</p>
<ol>
<li>void write(int c)：写入单个字符</li>
<li>void write(char[] cbuf)：写入字符数组</li>
<li>abstract void write(char[] cbuf,int off,int len)：写入字符数组的某一部分，off表示开始索引，len表示写的字符个数</li>
<li>void write(String str)：写入字符串</li>
<li>void write(String str, int off, int len)：写入字符串的某一部分</li>
<li>void flush()：刷新流的缓冲</li>
<li>void close()：刷新缓冲后关闭此流</li>
</ol>
</li>
<li>
<p>字符输出流和字节输出流的最大的区别就是字符输出流要将内容先写到内存缓冲区中（进行 字符——&gt;字节 过程），所以之后必须进行flush或者close。</p>
</li>
<li>
<p>FileWriter构造方法：</p>
<ol>
<li>FileWriter(File file)</li>
<li>FileWriter(String name)</li>
<li>FileWriter(File file, boolean append)</li>
<li>FileWriter(String name, boolean append)</li>
</ol>
</li>
<li>
<p>jdk1.7之前进行异常处理的过程</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//可能产生异常的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">异常类参数对象</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//异常的处理逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">finally</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//资源释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>jdk1.7后中进行流异常处理的过程</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">try</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">定义流对象</span><span style="color:#f92672">){</span><span style="color:#75715e">//流对象使用完毕自动释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//可能产生异常的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//异常的处理逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="属性集properties">属性集Properties</h3>
<ul>
<li>唯一一个和io流结合的集合</li>
<li>store：集合中数据持久化到硬盘存储</li>
<li>load：硬盘中的键值对读取到集合使用</li>
<li>Properties是一个双列集合，key和value都默认是字符串</li>
<li>setProperty方法相当于map中的put方法</li>
<li>getProperty方法相当于map中的set方法</li>
<li>stringPropertyNames方法相当于map中的keySet方法</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileWriter fw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileWriter<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/a.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Proterties prop <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Properties<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>prop<span style="color:#f92672">.</span><span style="color:#a6e22e">setProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aa&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;11&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>prop<span style="color:#f92672">.</span><span style="color:#a6e22e">setProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;bb&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;22&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>prop<span style="color:#f92672">.</span><span style="color:#a6e22e">store</span><span style="color:#f92672">(</span>fw<span style="color:#f92672">,</span><span style="color:#e6db74">&#34;save data&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>fw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>prop<span style="color:#f92672">.</span><span style="color:#a6e22e">load</span><span style="color:#f92672">(</span>fw<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Set<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> set <span style="color:#f92672">=</span> prop<span style="color:#f92672">.</span><span style="color:#a6e22e">stringPropertyNames</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>String key <span style="color:#f92672">:</span> set<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    String value <span style="color:#f92672">=</span> prop<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span>key<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">+</span>value<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>properties文件中可以使用等号或者空格来分隔键值对</li>
<li>对中文进行处理的时候必须使用字符输入/出流</li>
</ul>
<h3 id="缓冲流">缓冲流</h3>
<ul>
<li>
<p>增强基本流（普通流都是一个一个地传，效率低下）</p>
</li>
<li>
<p>给基本字节输入输出流增加一个缓冲区，提高传输速率</p>
</li>
<li>
<p>BufferedInputStream(InputStream fis)</p>
<p>BufferedInputStream(InputStream fis, int size)</p>
</li>
<li>
<p>BufferedOutputStream(OutputStream fos)</p>
<p>BufferedOutputStream(OutputStream fos, int size)</p>
</li>
<li>
<p>BufferedWriter(Writer fw)</p>
<p>BufferedWriter(Writer fw, int size)</p>
</li>
<li>
<p>BufferedReader(Reader fr)</p>
<p>BufferedReader(Reader fr, int size)</p>
</li>
<li>
<p><strong>写和读的方法和基本流一致</strong></p>
<ol>
<li>BufferedWriter有一个特有的成员方法void newLine：写入一个行分隔符(不同操作系统统一一个方法)</li>
<li>BufferReader有一个特有的成员方法String readLine：读取一行数据(不同操作系统统一一个方法)</li>
</ol>
</li>
</ul>
<p>测试复制文件的效率：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        Scanner scanner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;请输入需要复制的文件路径:&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        String sourcePath <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;请输入粘贴的路径:&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        String targetPath <span style="color:#f92672">=</span> scanner<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> t1 <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>sourcePath<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>targetPath<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        byte[] bytes = new byte[1024];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        while((len = bis.read(bytes)) != -1){
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//            bos.write(bytes,0,len);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//        }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        bis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        bos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> t2 <span style="color:#f92672">=</span> System<span style="color:#f92672">.</span><span style="color:#a6e22e">currentTimeMillis</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> sumT <span style="color:#f92672">=</span> t2<span style="color:#f92672">-</span>t1<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;复制过程总共耗时:&#34;</span><span style="color:#f92672">+</span>sumT<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;毫秒&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="转换流">转换流</h3>
<ul>
<li>编码：字符——&gt;字节</li>
<li>解码：字节——&gt;字符</li>
<li>制定了编码，字节文件对应的字符集也就确定了，每个软件也就能根据软件功能转化字节为对应的字符供我们查看了</li>
<li>常见的字符集有ASCII字符集，GBK字符集，Unicode字符集</li>
<li>FileReader只能读取系统默认编码utf-8格式的文件，如果读取GBK格式的文件，就会产生乱码</li>
<li>引入转换流来解决：InputStreamReader和OutputStreamWriter是字节流和字符流的桥梁，可以指定编码表</li>
</ul>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223541.png" alt="image-20210311100154292"></p>
<ul>
<li>
<p>InputStreamReader(InputStream fis) //默认编码</p>
<p>InputStreamReader(InputStream fis, String charsetName) //指定编码</p>
</li>
<li>
<p>OutputStreamWriter(OutputStream fos)</p>
<p>OutputStreamWriter(OutputStream fos, String charsetName)</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>OutputStreamWriter osw <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OutputStreamWriter<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/a.txt&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>osw<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;你好&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>osw<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/a.txt&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;GBK&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span><span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> isr<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">())!=-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">((</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span>len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>isr<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><h3 id="序列化--反序列化流">序列化 &amp; 反序列化流</h3>
<p>把对象以字节的形式写入到文件中存储 并 从文件中读取对象到内存中继续使用，即是<strong>对象持久化</strong></p>
<ul>
<li>
<p>ObjectOutputStream(OutputStream os)：对象的序列化流</p>
<ul>
<li>void writeObject(Object obj)</li>
</ul>
</li>
<li>
<p>ObjectInputStream(IutputStream is)：对象的反序列化流</p>
<ul>
<li>Object readObject()</li>
</ul>
</li>
<li>
<p>要对对象进行序列化 or 反序列化，必须在类中实现<strong>Serializable</strong>接口</p>
</li>
<li>
<p>序列化的内容都是对象的内容，所以static的变量不能被序列化。如果想让一个成员变量不被序列化但是又没有static的含义，可以使用transient关键字声明变量</p>
</li>
<li>
<p>如果一个类实现了Serializable接口，编译后的.class文件中会带有一个序列号。序列化时，会将这个序号一同写入文件；<strong>当反序列化时，会将文件的序列号和.class文件中的序列号作对比</strong>，如果不同会抛<strong>InvalidClassException</strong>异常。（每次对类修改后都会重新生成一个序列号，为了避免异常，我们可以手动给Serializable实现类加上一个序列号）</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> serivalVersionUID <span style="color:#f92672">=</span> <span style="color:#ae81ff">42L</span><span style="color:#f92672">;</span>
</span></span></code></pre></div><h3 id="打印流">打印流</h3>
<ul>
<li>PrintStream：为其他输出流添加功能，使他们能方便打印各种数据值的表示形式
<ol>
<li>print()</li>
<li>pringln()</li>
<li>继承自OutputStream的方法（如果使用write方法会查询编码表97-&gt;a；如果使用println or print方法会原样输出）</li>
</ol>
</li>
<li>构造方法：
<ol>
<li>PrintStream(File file)</li>
<li>PrintStream(OutputStream out)</li>
<li>PrintStream(String fileName)</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>PrintStream ps <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PrintStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/home/jack1024/a.txt&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>ps<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#ae81ff">97</span><span style="color:#f92672">);</span><span style="color:#75715e">//转化为字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ps<span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#ae81ff">97</span><span style="color:#f92672">);</span><span style="color:#75715e">//原样打印到文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ps<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">setOut</span><span style="color:#f92672">(</span>ps<span style="color:#f92672">);</span><span style="color:#75715e">//改变输出语句的目的地为ps的目的地
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;haha&#34;</span><span style="color:#f92672">);</span><span style="color:#75715e">//会将haha字符串写到/home/jack1024/a.txt中
</span></span></span></code></pre></div><h2 id="java网络编程">Java网络编程</h2>
<p>TCP/IP协议是Internet中最基本，最广泛的协议，他定义了计算机计算机如何进因特网，数据如何在计算机间传输数据。它的内部包含一系列用于处理数据通信的协议</p>
<ul>
<li>UDP协议：无连接，效率更高，不安全</li>
<li>TCP协议：三次握手建立连接，四次挥手解除连接，效率较低，安全</li>
</ul>
<p>网络编程三要素：</p>
<ol>
<li>协议</li>
<li>IP地址：ipv4(32位：8<em>4)，ipv6(128位：16</em>8)，连接两台主机</li>
<li>端口：两个字节(0—1024—65535)，连接两台主机的两个进程</li>
</ol>
<h3 id="tcp通信程序">TCP通信程序</h3>
<ul>
<li>客户端主动请求服务端建立连接，连接中包含一个IO对象，这个对象只能是字节流对象</li>
</ul>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223550.png" alt="image-20210311113110227"></p>
<p><strong>代码实现：</strong></p>
<p><strong>客户端</strong></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223558.png" alt="image-20210311113550491"></p>
<p><strong>服务器</strong></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223606.png" alt="image-20210311115105384"></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//客户端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TcpClient</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		Socket socket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Socket<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">8888</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//往服务器写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		OutputStream os <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		os<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;你好&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//从服务端拿
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		InputStream is <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> is<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span><span style="color:#ae81ff">0</span><span style="color:#f92672">,</span>len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		socket<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//服务端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TcpServer</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        ServerSocket serverSocket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ServerSocket<span style="color:#f92672">(</span><span style="color:#ae81ff">8888</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        Socket accept <span style="color:#f92672">=</span> serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        InputStream is <span style="color:#f92672">=</span> accept<span style="color:#f92672">.</span><span style="color:#a6e22e">getInputStream</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        OutputStream os <span style="color:#f92672">=</span> accept<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> is<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>bytes<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span><span style="color:#ae81ff">0</span><span style="color:#f92672">,</span>len<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        os<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;收到了&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>        accept<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="tcp文件上传案例">TCP文件上传案例</h3>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521223615.png" alt="image-20210311142418192"></p>
<h3 id="模拟bs通信案例">模拟B/S通信案例</h3>
<h2 id="函数式编程">函数式编程</h2>
<ul>
<li>函数式接口：有且仅有一个抽象方法的接口，但是可以包含其他方法（默认，静态，私有）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">修饰符</span> <span style="color:#66d9ef">interface</span> <span style="color:#960050;background-color:#1e0010">接口名称{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#960050;background-color:#1e0010">返回值类型</span> <span style="color:#960050;background-color:#1e0010">方法名称</span><span style="color:#f92672">(</span><span style="color:#960050;background-color:#1e0010">可选参数信息</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li>lambda是延迟加载的，可以提升部分代码的性能。也就是说只有满足执行lambda中方法的条件，才会执行方法中的内容，否则不会执行。</li>
<li>函数式接口作为方法的参数，我们可以用lambda表达式 或者 匿名内部类 作为实参</li>
<li>函数式接口作为方法的返回值，我们可以返回这个接口的匿名内部类 或者 lambda表达式</li>
</ul>
<h3 id="常用的函数式接口">常用的函数式接口</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//java.util.funciton.Supplier&lt;T&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">getString</span><span style="color:#f92672">(</span>Supplier<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> sup<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> sup<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span><span style="color:#75715e">//用来返回一个指定类型的数据对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    String s <span style="color:#f92672">=</span> getString<span style="color:#f92672">(()-&gt;{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Sam Smith&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//java.util.function.Consumer&lt;T&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">,</span>Consumer<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> con<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    con<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">(</span>name<span style="color:#f92672">);</span><span style="color:#75715e">//用来消费name字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    method<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Mariah Carey&#34;</span><span style="color:#f92672">,(</span>String name<span style="color:#f92672">)-&gt;{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//对传递的字符串进行处理消费
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">})</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//andThen()默认方法，连续组合多个Consumer的accept方法
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//java.util.function.Predicate&lt;T&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">checkString</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span>Predicate<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> pre<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> pre<span style="color:#f92672">.</span><span style="color:#a6e22e">test</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span><span style="color:#75715e">//对传入的参数进行判断，返回真假
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcde&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> b <span style="color:#f92672">=</span> checkString<span style="color:#f92672">(</span>s<span style="color:#f92672">,()-&gt;{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()&gt;</span><span style="color:#ae81ff">5</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//Predicate的and()，or()默认方法可以用来连接两个判断条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//negate()默认方法可以对一个判断条件取反
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//java.util.function.Function&lt;T,R&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">change</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span>Function<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Integer<span style="color:#f92672">&gt;</span> fun<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    Integer in <span style="color:#f92672">=</span> fun<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> staic <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>    String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    change<span style="color:#f92672">(</span>s<span style="color:#f92672">,(</span>String s<span style="color:#f92672">)-&gt;{</span><span style="color:#75715e">//将一个值从原类型转化为另一个类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    	<span style="color:#66d9ef">return</span> Ingeter<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>    
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//andThen()默认方法，连续组合多个Function的apply方法
</span></span></span></code></pre></div><h2 id="stream流式编程">Stream流式编程</h2>
<ul>
<li><strong>Stream和io流</strong>不能说差不多，只能说是<strong>毫无关系</strong></li>
<li>极大地简化了对集合进行过滤 &amp; 遍历的操作</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>name<span style="color:#f92672">.</span><span style="color:#a6e22e">startWith</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;杨&#34;</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>name<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">==</span><span style="color:#ae81ff">3</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">.</span><span style="color:#a6e22e">foreach</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">));</span>
</span></span></code></pre></div><ul>
<li><strong>流式操作过程：</strong>
<ol>
<li>获取数据源(集合,数组)</li>
<li>数据转换(把数据源转化为Stream流)</li>
<li>执行操作获取想要的结果</li>
</ol>
</li>
</ul>
<h3 id="获得stream流对象">获得Stream流对象</h3>
<ol>
<li>所有collection集合可通过stream()方法获得</li>
<li>Stream接口有一个static方法of()，可以把数组转化为stream流</li>
</ol>
<h3 id="stream对象的方法">Stream对象的方法</h3>
<ul>
<li>stream属于管道流，只能使用一次，第一个Stream流调用完毕，数据会流到下一个Stream流身上，此时第一个Stream流就不能再调用方法了</li>
</ul>
<h4 id="延迟方法">延迟方法</h4>
<ul>
<li>返回值类型仍然是Stream接口自身类型的方法，支持链式调用</li>
<li>每个流 流到下一步，上一步的流就关闭了，这个要注意，这也是为什么叫流，它是一个动态的过程</li>
</ul>
<p><strong>filter方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Jack&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;Sam&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream2 <span style="color:#f92672">=</span> stream<span style="color:#f92672">.</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;{</span>
</span></span><span style="display:flex;"><span>    reuturn name<span style="color:#f92672">.</span><span style="color:#a6e22e">startWith</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;J&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span></code></pre></div><p><strong>map方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;3&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Stream<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stream2 <span style="color:#f92672">=</span> stream<span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">-&gt;{</span>
</span></span><span style="display:flex;"><span>    reuturn Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parse</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span></code></pre></div><p><strong>limit方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Stream&lt;T&gt; limit(long maxSize)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;哈哈&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;嘿嘿&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;咚咚&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//只取前两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stream<span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">(</span><span style="color:#ae81ff">2</span><span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">));</span>
</span></span></code></pre></div><p><strong>skip方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//Stream&lt;T&gt; skip(long n)：跳过前n个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;哈哈&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;嘿嘿&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;咚咚&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//只取前两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stream<span style="color:#f92672">.</span><span style="color:#a6e22e">skip</span><span style="color:#f92672">(</span><span style="color:#ae81ff">2</span><span style="color:#f92672">).</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">));</span>
</span></span></code></pre></div><p><strong>concat方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//两个流合并为一个新的流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream1 <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;3&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream2 <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> concat <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">concat</span><span style="color:#f92672">(</span>stream1<span style="color:#f92672">,</span>stream2<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>concat<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">));</span>
</span></span></code></pre></div><h4 id="终结方法">终结方法</h4>
<ul>
<li>返回值类型不再是Stream接口自身类型的方法，不再支持链式调用</li>
</ul>
<p><strong>count方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//long count():统计个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#ae81ff">2</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#ae81ff">3</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#ae81ff">4</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Stream<span style="color:#f92672">&lt;</span>Ingeter<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> count <span style="color:#f92672">=</span> stream<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
</span></span></code></pre></div><p><strong>forEach方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//void forEach(Consumer&lt;? super T&gt; con)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Stream<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Jack&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;Sam&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;Tom&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>stream<span style="color:#f92672">.</span><span style="color:#a6e22e">forEach</span><span style="color:#f92672">(</span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">));</span>
</span></span></code></pre></div><h2 id="方法引用">方法引用</h2>
<ul>
<li>虽然lambda已经很简单了，但是方法引用还可以堆lambda表达式继续简化</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>name<span style="color:#f92672">-&gt;</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name<span style="color:#f92672">);</span><span style="color:#75715e">//lambda表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">::</span>println<span style="color:#f92672">;</span><span style="color:#75715e">//方法引用
</span></span></span></code></pre></div><p>几种情况：</p>
<ol>
<li>通过对象名引用成员方法</li>
<li>通过类名引用静态方法</li>
<li>通过super引用父类成员方法</li>
<li>通过this引用本类成员方法</li>
<li>构造方法的方法引用</li>
<li>数组的构造器引用</li>
</ol>
<h2 id="junit单元测试">Junit单元测试</h2>
<ul>
<li>黑盒测试：不需要关注代码，只需要看输入是否能得到输出</li>
<li>白盒测试：通过代码来测试程序的流程正确性（Junit属于白盒测试）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//定义测试类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/**几个建议
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	1.类名：被测试类名Test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	2.包名：XXX.XXX.test
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	3.方法名：test被测试的方法名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	4.返回值：void
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	5.参数列表：空参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//之前需要导入junit依赖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> CaculateTest<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testAdd</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        Assert<span style="color:#f92672">.</span><span style="color:#a6e22e">assertEquals</span><span style="color:#f92672">(</span><span style="color:#ae81ff">3</span><span style="color:#f92672">,</span>result<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>@Before和@After注解</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//所有测试方法前和后都会执行的两个注解@Before和@After
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">@Before</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@After</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="反射">反射</h2>
<blockquote>
<p>查看之前写的一片博客《java-反射》</p>
</blockquote>
<h2 id="注解">注解</h2>
<blockquote>
<p>查看之前写的一片博客《java-注解》</p>
</blockquote>
</section>

  
  

  
  
  
  <nav
    class="mt-24 flex rounded-lg bg-black/[3%] p-1.5 text-lg dark:bg-white/[8%]"
  >
    
    <a
      class="flex w-1/2 items-center rounded-md p-6 pr-3 no-underline hover:bg-black/[2%]"
      href="http://example.org/post/javaweb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/"
      ><span class="mr-1.5">←</span><span>javaWeb三大组件</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-md p-6 pl-3 no-underline hover:bg-black/[2%]"
      href="http://example.org/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%AD/"
      ><span>java基础快速回顾-中</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div class="mt-24" id="disqus_thread"></div>
  <script>
    const disqusShortname = 'Jack';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  

  
  
  <div class="mt-24" id="graphcomment"></div>
  <script type="text/javascript">
    var __semio__params = {
      graphcommentId: 'YOUR_GRAPH_COMMENT_ID',
      behaviour: {
        
      },
      
    };

    function __semio__onload() {
      __semio__gc_graphlogin(__semio__params);
    }

    (function () {
      var gc = document.createElement('script');
      gc.type = 'text/javascript';
      gc.async = true;
      gc.onload = __semio__onload;
      gc.defer = true;
      gc.src =
        'https://integration.graphcomment.com/gc_graphlogin.js?' + Date.now();
      (
        document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]
      ).appendChild(gc);
    })();
  </script>
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="http://example.org/">My Hugo Site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
