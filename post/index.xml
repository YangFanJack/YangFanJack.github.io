<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Hugo Site</title>
    <link>114.116.115.171/post/</link>
    <description>Recent content in Posts on My Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 30 Mar 2022 08:27:58 +0000</lastBuildDate><atom:link href="114.116.115.171/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>win10壁纸bingtoday</title>
      <link>114.116.115.171/post/win10%E5%A3%81%E7%BA%B8bingtoday/</link>
      <pubDate>Wed, 30 Mar 2022 08:27:58 +0000</pubDate>
      
      <guid>114.116.115.171/post/win10%E5%A3%81%E7%BA%B8bingtoday/</guid>
      <description>注册表指定壁纸路径 WIN+R打开运行对话框：输入regedit打开注册表 到达路径：计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System下，一个叫Wallpaper的名称就是壁纸的指定路径，更换成你希望的壁纸路径：例如：C:\wallpaper\wallpaper.jpg 每日bing壁纸下载 通过java代码实现下载每日bing壁纸到刚才注册表指定的壁纸路径
public class DownloadMain { public static void main(String[] args) throws IOException { final String imgResource = getImgResource(); final URL url = new URL(imgResource); final URLConnection urlConnection = url.openConnection(); final BufferedInputStream bis = new BufferedInputStream(urlConnection.getInputStream()); final BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&amp;#34;C:\\wallpaper\\wallpaper.jpg&amp;#34;)); final byte[] bytes = new byte[1024]; int len = 0; while ((len=bis.read(bytes)) != -1){ bos.write(bytes,0,len); } bis.close(); bos.close(); } public static String getImgResource() throws IOException{ String url = &amp;#34;http://cn.</description>
    </item>
    
    <item>
      <title>RPM打包初试</title>
      <link>114.116.115.171/post/rpm%E6%89%93%E5%8C%85%E5%88%9D%E8%AF%95/</link>
      <pubDate>Wed, 01 Dec 2021 10:44:01 +0000</pubDate>
      
      <guid>114.116.115.171/post/rpm%E6%89%93%E5%8C%85%E5%88%9D%E8%AF%95/</guid>
      <description>1434
rpm打包需要一个独立的打包目录
BUILD：编译rpm包的临时目录 BUILDROOT：编译后生成的软件临时安装目录 RPMS：最终生成的可安装rpm包存放目录 SOURCES：所有源文件和补丁文件存放目录 SPECS：存放SPEC文件的目录 SRPMS：软件最终的rpm源码格式存放路径 打包需要从源码sources开始，将存放源码的目录打包压缩成tar.gz格式，放进SOURCES目录中
然后在SPECS目录中创建并编辑spec文件
最后根据spec文件进行打包rpm -ba rpmbuild/SPECS/xxx.spec</description>
    </item>
    
    <item>
      <title>国庆北京独游</title>
      <link>114.116.115.171/post/%E5%9B%BD%E5%BA%86%E5%8C%97%E4%BA%AC%E7%8B%AC%E6%B8%B8/</link>
      <pubDate>Wed, 13 Oct 2021 08:13:19 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%9B%BD%E5%BA%86%E5%8C%97%E4%BA%AC%E7%8B%AC%E6%B8%B8/</guid>
      <description>在保定工作的这3个月里，从学校到工作过渡很平稳，学校里做的事和工作中差异不大，总体来说还是很快适应了工作环境。另外，和学校相比，假期确实太少啦，但是没办法，毕竟要挣钱的嘛。自己要想办法在一天8小时的工作中做更多有意义的事，否则就真的是浪费时间了。
好不容易等到国庆长假，早就计划趁着这次假期去北京走走看看，上一次去北京还是大二寒假返校利用转机空挡期在北京玩了一天，那次北京行印象深刻。但一天的行程，我即使用一天50000步的极限速度来搞，也不可能走完北京几个著名景点，况且还是走马观花式地在地铁线上往来于景点之间。
这次的北京行，我希望能尽量放慢时间，从底向上体会北京这座城的样貌。
总体计划 先说一下旅行前的大致安排：
第一天：天安门、故宫、北海公园、三里屯太古里、北京CBD核心区域、王府井
第二天：奥林匹克公园、圆明园、颐和园
第三天：八达岭长城
Day1 9月30号下班后，备置些干粮，带上洗漱用品、充电宝、雨伞、充电器、钱包&amp;hellip;。
由于是国庆节假日，可以预料到北京的拥挤程度。我提前预定了故宫和长城的门票。根据自己的行程安排预定好住宿旅馆：第一天的写在了王府井附近的一个胡同里；第二天的定在了鸟巢附近。
10月1号的高铁是6点40的班次——当天最早的一趟。保险起见，前一天晚上在滴滴就预约了凌晨4点的出租车，结果到了高铁站才知道高铁站6点开门，于是，我在高铁站外的一个尚未装修完的地下商场里等了1个小时&amp;hellip;好在这地方还挺暖和。
坐上高铁，40分钟就到了北京。北京西站没有直达天安门广场附近的地铁。坐地铁最近能到天安门广场南几公里远，然后我骑着共享单车跟着导航穿越了传说中的北京胡同。
所谓胡同，其实就是北京老式住房间的过道，算是北京最具本地特色的文化之一。骑一段路就要看看导航，最后总算是断断续续地走出来了，走出胡同最先入目的就是箭楼和正阳门，两个建筑非常端庄地前后有序地坐落在北京城的中轴线上。
意料之中，人真的很多，毕竟时值国庆日，人再多都是能理解的。
排队安检后来到天安门广场，时隔3年再次来到天安门广场，和上次相比，10月1日的天安门广场自然有所不同。沿着中轴线摆放着巨型花篮和孙中山先生的画像。毛主席纪念堂、国家博物馆、人民大会堂、天安门从东南西北四四方方地围着广场，广场上竖立着国旗和人民英雄纪念碑。建筑整体看来非常大气壮观，倍显大国气象。
从地下通道穿过长安大街来到天安门下，顺着故宫西墙往北走，就能看见后海。北京似乎有很多海，这些“海”有很重的人文色彩，大概就是明清时期的皇家湖泊吧。
后海里的面积挺大，风景也很不错，值得一来。
逛完公园后后乘公交原路返回，从天安门进入，穿过端门，就能看见雄伟的故宫大门——午门了。故宫每天的游览人数是有限制的，所以需要提前在微信公众号预定门票，现场是不出售门票的。
故宫虽然没有完全开放，但如果你想走完左右地方是不现实的，我选了一条公众号上推荐的路线：从午门进入，沿着中轴线经过太和门，太和殿、中和殿、保和殿，然后进入后宫，沿着乾清宫、交泰殿、坤宁宫、东六宫（钟粹宫、景阳宫、承乾宫、永和宫、延禧宫、景仁宫），最后，经过斋宫武备馆、宁寿宫，从神武门出去就算是出了宫😄。
从故宫出来，已经是下午4点过了，在神武门外搭乘双层大巴去南锣鼓巷换乘地铁前往三里屯。
北京三里屯太古里和成都那个太古里差球不多，满眼的外国牌子，一个都不认识，留下一张外景就拍屁股走人。
之后来到北京CBD核心区域，也是北京城最大的商业圈，“大裤衩”、国贸大楼&amp;hellip;高楼林立，极具钢铁美感，作为共和国首都，经济自然不能太拉。
到王府井已经是晚上了，逛了会儿街。最后的晚饭在王府井街道末尾的APM吃的。
回到旅馆就睡了，太累了！哈哈，上一次50000步也是上一次的北京，不过有一说一，也是靠着北京世界级的城市交通网络我才能在十几个小时内在这么多地方往返。
Day2 第二天早上8点过才醒，收拾好后就去了奥林匹克公园。遗憾的是，北京这3天的天气真是一天比一天差。
来看鸟巢水立方的人明显较之其他地方的少，阴雨绵绵下的鸟巢少了运动的活力，添了几分忧郁的气质。玲珑塔上北京2022冬奥会的倒计时预示着3个月后这里又将迎来世界体育的目光。
圆明园上次就来过一次，这次去就随着人群走马观花了。
这次来北京的初衷就打算把颐和园和长城看了，结果到了颐和园才发现要提前预定门票，哎，没办法，以后有机会再来吧。圆明园旁边就是清华北大——中国两所巨无霸高校，一路上遇到的可能全是学霸&amp;hellip;
计划里没了颐和园，之后去逛了逛牛街，这是条清真小吃街，几家名小吃门前排队的人也很多。
最后回到鸟巢，在附近电影院里看了《长津湖》，这部主旋律电影优点很多，但是3个小时的电影剧情不连贯，也少有起伏。但总体来说还是推荐的。希望之后能多拍这种共和国历史重要节点的历史战争片。
电影看完就11点了，第二天行程结束。
Day3 由于前两天的高负荷奔走，第三天9点才从旅馆动身出发，一路上公交车、地铁、火车，到八达岭总共花了3个小时，本来时间都不太够了。到了八达岭脚下看见只见蛇头不见蛇尾的队伍心就凉了一半了，等坐缆车上了长城彻底绝望了。
好家伙，百闻不如一见，果真是人海，一点不夸张。
我的感受是：长城应该像故宫、颐和园那样采取提前预约制，再加上长城本身只有极为狭窄的通道，这种摩肩擦踵的游览确实十分糟心。
然而我还是低估了，刚走一会儿又开始下雨，然后大部分游客又顺着原路返回，emmmmm，回去也堵上了，我真的服了。
此时应该安慰自己，至少还是“到此一游”了😭
回看旅行前的计划，没有完全实现，也没有很多从底向上细看北京城的机会。主要原因还是行程安排的太满，有得必有失，下次旅行总结经验。国庆北京行总体来说还是很不错的，很多地方都是第一次去，惊叹于故宫的红墙金瓦，震撼于长城的庄严磅礴，向往于CBD的高楼大厦；不知道下次到北京又是什么时候，希望能把这次的遗憾补足。</description>
    </item>
    
    <item>
      <title>摄影入门</title>
      <link>114.116.115.171/post/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 10 Oct 2021 18:19:17 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</guid>
      <description>曝光 摄影就是用光线绘图，摄影是光与影的艺术！ 曝光：胶片、底片、数码时代的CMOS通过光线产生影像的过程 曝光不足 &amp;amp; 曝光过度(过曝) 曝光正常：亮有细节不过曝，暗有层次不漆黑 摄影的第一步是控制曝光 光圈（f） 光圈用来控制进光量 f3.5、f5.6、f8、f11、f16、f22：数值和光圈大小成反比 大光圈：景深浅，主体清晰背景模糊 小光圈：景深长、主体和背景都很清晰 快门（以秒为单位） 用来控制光线进来的时间，时间越长曝光越多 高速快门凝固瞬间 低速快门记录轨迹（必须用三脚架） 感光度ISO 底片/胶片/CMOS感光元件 等硬件的感官能力 ISO越高，感光能力越强，画质越粗糙，噪点越多；反之亦然 但是：一张有噪点的照片比一张拍虚了的照片有价值 当光圈和快门没有办法时，适当提高ISO增加亮度 重点：光圈、快门、ISO调节优先级：光圈 &amp;gt; 快门 &amp;gt; ISO **暗处：**首先增大光圈，如果不够再适当延长快门时间，如果此时光线还是不足，那么再调节ISO，增大感光能力 **亮处：**首先缩小ISO，降低感光能力，如果还是太亮，就缩短快门时间，如果还是不行，再缩小光圈。 拍摄模式 拍摄模式种类： M：手动曝光模式 A（AV）：光圈优先模式 S（TV）：快门优先模式 P：程序自动模式（傻瓜模式） 光圈、快门、ISO的组合关系 光圈、快门、ISO共同决定了一张影像的曝光 相机镜头 定焦 &amp;amp; 变焦
定焦镜头：成像质量好，方便性差 变焦镜头：成像质量比定焦镜头略差，方便性好 **焦距：**决定了镜头能看到的范围大小
镜头越短看的范围广，镜头长看的范围窄
广角：&amp;lt;24mm，景深大 标准：≈55mm 中长焦：70-135mm 长焦：&amp;gt;135mm，景深浅 焦距越长，景深越浅；焦距越短，景深越深。
对焦模式
手动对焦模式（MF）： 变焦环：伸缩镜头，达到变焦目的 对焦环：手动对焦时用 自动对焦模式（AF）： 尼康：AF-S、AF-C、AF-A 佳能：ONE SHOT、AI SERVO、AI FOCUS 对焦点的作用
单点对焦：一般用于拍摄静止物体（拍一个花瓶） 区域对焦：一般用于拍摄不规则运动的物体（拍一群鸟，一群人） 白平衡 白平衡能对光线颜色进行补偿 **AWB：**自动白平衡，类似人的眼睛，在不同光线下相机自动识别定义一个比较合适的白平衡保证拍摄物体尽可能地呈现自身的颜色 AWB只在一定的色温范围内是准确的 预设的几种白平衡可以选择集中预设的白平衡选项 用户自定义可以更加的自由（重点！重点！重点！） 色温K值越大越冷，反之亦然；白平衡和色温恰好相反。但是很多人是把色温和白平衡弄反了 其实我们利用白平衡欺骗相机，你可以设置一个高的色温值，然后相机就会认为此时的画面色温很高，就会往画面中加入暖色调来中和 光 光质：</description>
    </item>
    
    <item>
      <title>工作流Activiti</title>
      <link>114.116.115.171/post/%E5%B7%A5%E4%BD%9C%E6%B5%81activiti/</link>
      <pubDate>Thu, 23 Sep 2021 19:38:06 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%B7%A5%E4%BD%9C%E6%B5%81activiti/</guid>
      <description>工作流的作用是：对系统的业务流程进行自动化管理。一个软件的系统核心是系统的业务流程，工作流只是协助进行业务流程管理。工作流能更好的管理业务流程，提高系统的可扩展性。
工作流的具体应用：
关键业务流程 行政管理类 财务相关类 客户服务类 特殊服务类 在没有专门的工作流引擎前，要实现流程控制，通常的做法是采用状态字段的值类跟踪流程的变化情况。这样不用角色的用户，通过状态字段的取值来决定记录是否显示。但是这样做和业务代码的耦合性特别高。
Activiti7概述 Activiti是一个工作流引擎，activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行。实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时减少了系统开发维护成本。
BPM：Business Process Management业务流程管理
BPM软件：对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升。
BPMN：Business Process Model And Notation业务流程模型和符号，是由BPMI开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。
BPMN图形其实是通过xml表示的业务逻辑，上面的.bpmn文件使用文本编辑器打开后是一个xml文件
Activiti的使用 Activiti的使用步骤 部署activiti
Activiti是一个工作流引擎，业务系统访问activit的api接口，就能方便的操作流程相关数据，这样就可以把工作流环境与业务系统的环境集成在一起。
流程定义
使用activiti流程建模工具（activiti-designer）或者通过手写xml文件来定义业务流程（.bpmn文件）
流程定义部署
使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容
Activiti执行把流程定义存储在数据库中
启动一个流程实例
启动一个流程实例表示开始一次业务流程的运行
For Example：在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互不干扰
用户查询待办任务Task
因为系统的业务流程已经交给了activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些东西activiti都帮我管理了
用户办理任务
用户查询待办任务后，就可以办理某个任务了，如果这个任务办理完成后还需要其他用户办理，比如：采购单创建后由部门经理审核，这些过程也是由activiti帮我们完成了。
流程结束
当任务办理完成后没有下一个任务节点了，这个流程实例就完成了
Activiti环境 &amp;lt;!-- https://mvnrepository.com/artifact/org.activiti/activiti-engine --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.activiti&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;activiti-engine&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;7.1.0.M6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Activiti运行需要有数据库的支持，支持的数据库有：h2，mysql，oracle，postgres等。
在IDEA中创建一个Activiti的Maven项目框架 导入Maven依赖包： Activiti相关的包：activiti-engine包，activiti依赖的jar包，activiti依赖的spring包 mysql的驱动包：mysql的数据库驱动包 mybatis的包： log4j的包 数据库连接池的包：第三方数据库连接池包dbcp 单元测试包junit </description>
    </item>
    
    <item>
      <title>shiro权限管理</title>
      <link>114.116.115.171/post/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 12 Aug 2021 21:30:04 +0000</pubDate>
      
      <guid>114.116.115.171/post/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>shiro权限管理 Shiro的核心就是用来完成权限管理的。权限管理包括用户身份认证和授权两部分，简称认证授权。
只要有人参与的系统都需要进行权限管理。
什么是Shiro？ Shiro是apache旗下的一个开源框架，它将软件系统的安全认认证相关的功能抽取出来，实现用户身份认证、权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。
**Security Manager：**包含Authenticator认证器，Authorizer授权器，Session Manager会话管理器，Cache Manager缓存管理器，Session DAO会话数据访问对象，Pluggable Realms可插拔域 **cryptography：**密码器（sha256，md5） **subject：**主体（Shiro集成的东西，宿主） Shiro中用户的身份认证 subject：主体
访问系统的用户，主体可以是用户、程序等，进行认证都称为主体。主体在进行身份认证时需要身份信息Principal和凭证信息credential
Principal：身份信息
身份认证的标识，如用户名、手机号、邮箱地址等。一个主体可以有多个身份信息，但是只能有一个主身份信息。
credential：凭证信息
只有主体自己知道的安全信息，如密码、证书等
认证流程：
代码
[users]zhangsan=123lisi=1234wangwu=12345zhaoliu=123456public class TestAuhenticator{public static void main( String[] args ){//创建安全管理器对象DefaultSecurityManager securityManager = new DefaultSecurityManager();//给安全管理器设置realmsecurityManager.setRealm(new IniRealm(&amp;#34;classpath:shiro.ini&amp;#34;));//SecurityUtils安全工具类SecurityUtils.setSecurityManager(securityManager);//拿到主体subjectSubject subject = SecurityUtils.getSubject();//模拟登录，创建令牌UsernamePasswordToken token = new UsernamePasswordToken(&amp;#34;zhangsan&amp;#34;, &amp;#34;123&amp;#34;);//用户登录try {System.out.println(&amp;#34;Authentication Status:&amp;#34;+subject.isAuthenticated());subject.login(token);System.out.println(&amp;#34;Authentication Status:&amp;#34;+subject.isAuthenticated());}catch (UnknownAccountException e){e.</description>
    </item>
    
    <item>
      <title>毕业九寨三人游</title>
      <link>114.116.115.171/post/%E6%AF%95%E4%B8%9A%E4%B9%9D%E5%AF%A8%E4%B8%89%E4%BA%BA%E6%B8%B8/</link>
      <pubDate>Thu, 08 Jul 2021 17:38:00 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%AF%95%E4%B8%9A%E4%B9%9D%E5%AF%A8%E4%B8%89%E4%BA%BA%E6%B8%B8/</guid>
      <description>6月9号本科毕设答辩后就赶回家了，休息一个月就要开始工作啦。和高中同学联系打算出去玩玩儿。综合考虑后打算到九寨-黄龙-若尔盖一线玩玩儿，我的博客不仅仅是技术博客，旅行游记是一个不错的题材。
总体计划 本次前往九寨沟的行程有几个计划：报个旅游团、坐班车去然后租车自驾、全程包车、坐班车去然后包车等等计划都有想过，虽然三个同学都有拿到驾照，但是平时都在学校学习，开车的机会并不多，再加上当前绵九高速正在施工，从江油前往九寨沟的路并不好走甚至有点儿危险；在论如果跟团游的话不是很舒服，旅行安排的灵活性就不足。最后选择自行做班车到九寨沟，然后在九寨沟当地联系一个司机包车游览九寨沟、黄龙、若尔盖草原一线。九寨沟是没有铁路的，当然，你可以选择做飞机前往，但是因为旅游专线，机票价格十分高昂。
这个司机也是在网上浏览一个2017年的游客写的游记，其中推荐了这个九寨沟当地刘师傅。先说一下旅行的总体安排。整个旅行大概有6天时间：
第一天：从江油做班车到九寨沟，晚上就住进沟内 第二天：游览九寨沟，看九寨千古情演出，住在九寨沟附近 第三天：从九寨沟经雪宝顶、川主寺一线前往黄龙，游览黄龙，住在松潘 第四天：从松潘出发前往若尔盖大草原，体验骑马，黄河九曲第一湾看日落，住在唐克 第五天：从唐克出发，经瓦切、红原一线返回松潘，住在松潘 第六天：从松潘搭班车返回江油 Day 1 旅行前几天，最好准备些零食干粮、防晒工具（喷雾、冰袖等）、防寒衣物、晕车药。
当天一大早，从家出发前往汽车站和一个同学会合同乘班车从江油出发，另一个同学从广元出发。六块钱一颗的晕车药属实厉害，抖了7个小时的山路都没晕车。下午5点，三人会合于九寨沟。有意思的是，在从江油出发的班车上，遇到了一个九寨沟内的大叔，交谈一番后，他表示内把我们带进去，连同一晚的住宿只需要220块钱，比门票259便宜很多。三个刚毕业的大学生为了节省预算还是忍不住&amp;hellip;&amp;hellip;当然，这种做法不合规也不推荐， 出了事儿也只能自己负责，所以还是推荐正常购买门票。
当天晚上就住在九寨沟内的荷叶寨，民宿老板很友好，房屋非常具有藏式特色。晚餐后小试了会儿无人机拍摄。一天颠簸的车程很是疲劳，一切收拾妥当后就睡了。
Day 2 第二天早上吃完晚饭后就直接轻装出发，行李留在民宿，下午游览完后来取。
九寨沟属于古冰川地貌，冰川融化，积水沿着山谷留下聚集就形成了被当地人成为“海子”的湖泊。
九寨后的游览有两种方式：步行和坐车，一般来说都是坐车到某个地点，然后下车游览。总体的游览流程是：从盆景海做车到老虎海，游览老虎海、树正瀑布、犀牛海后，从犀牛海坐车到则扎洼沟的长海，游览长海、五彩池后坐车回到诺日朗游客中心。（上季节海、下季节海都在车上观览）。
到诺日朗就差不多中午了，可以选择在诺日朗中心食堂用餐，推荐自带干粮解决。然后从游客中心坐车去五花海。（因为2017年的地震，日则沟再往上的旅游景点还没有重新开放，最远只能走到五花海）从五花海往回步行，五花海、孔雀河道、金铃海、珍珠滩瀑布、诺日朗瀑布，是九寨沟景点最丰富的地方。步行到诺日朗后坐车到老虎海，然后下车步行至出口，结束。
当然，实际的情况还是没能复制计划。当下午游览到珍珠滩时，天降暴雨，只得坐车直接到出口。虽有遗憾，但幸运的是把九寨沟的主要景点都游览到了。九寨的风景是世界闻名的，青山绿水间隔坐落在山谷间，仿佛置若仙境，甚是惊艳。
出了九寨沟景区就联系了包车司机，晚上计划是观看九寨沟千古情演出，旅馆就定在了千古情旁边。晚上的千古情果真精彩以至于忘记了拍照&amp;hellip;&amp;hellip;
Day3 从九寨沟景区往南走，路过雪宝顶、川主寺到达黄龙景区，和九寨沟一样，黄龙也是世界自然遗产。其独特的喀斯特地貌让黄龙景色堪称一绝。
购买门票（学生证可半价）后，做缆车直接到达黄龙最高点，然后步行往下走，黄龙这个地方海拔确实有点儿高，运动量稍微增大就气喘吁吁，不过一路上逗提供了氧气补充站。黄龙的景色和九寨沟不同，九寨沟是看山谷间的山水，黄龙是体验置身大山中的渺小。
从山顶往下走，路很长，不过路上的风景也是应接不暇。刚开始，山路两旁甚至路中间都是高大的树木，山路虽平缓，但四千多米的海拔导致氧气稀薄，还是建议慢慢走，不要走太快。每走一段路都有补氧站，仨人进去体验了一把，也就是找个地方坐会儿歇口气，工作人员两根管子插鼻孔，氧气袋放你背后，不一定有啥大用，新奇的体验还是不错的，哈哈。
往下走一段路，就会有被称为很多被称为“五彩池”的大型喀斯特地貌景观，实际上就是长期钙化沉积形成的小湖，配合川北的高山地貌，有一说一，还是非常漂亮的。在黄龙景区中有一个相对宽广的位置，应该是个山谷，几座寺庙座落下雪山之下，旁边就是一片片的五彩池错落堆叠。我想若是孤身来此，定会被群山和碧水的酷冷所吞噬。
继续下山，之后的景观基本就大同小异了，都是碳酸盐沉积后形成了一片片水池，有种广西贵州那边梯田的感觉。遗憾的是不久就下雨了，虽说雨不大，但是没有了阳光的照射，水池显得死气沉沉的，遂快步下山，司机载着我们前往松潘，找了间旅馆住下了。
有趣的是，途中遇到了好几只松鼠，这些松鼠似乎并不怎么怕人，看来生活地还是比较安逸。
晚上住在松潘的一条街上，都是卖特产的小店，锟哥似乎对这些东西尤为喜欢，在与店主套完近乎后，又多次博弈，最后心满意足地买了5多雪莲花，之后在另一家店也偶然看见了雪莲花，一问结果便宜一半，😄。
Day4 第四天的计划是从松潘出发前往若尔盖草原，说实话，这趟草原之旅是我最期待的，草原的辽阔空旷只在影视作品里体会过，在此之前还没有正紧地去过真正的草原。幻想这样一个场景：蓝天白云，绿草无边，牛羊成群，一条弯曲的公路铺在平缓的绿色地毯上，汽车沿着这条公路平稳地行驶着，向着无垠地远方。。。我去，太巴适了。
初入草原，就迫不及待地下车，说实话，第一次现场感受草原，很有冲击力。
之后到了一家藏家乐，来草原不能不骑马，其实刚开始还是有点儿犹豫，一是价钱有点儿贵，而是有点儿恐惧（我胆儿小😱），但是想到在正儿八经的草原骑马的经历还是很难得的，就开始了人生的第一次骑马。一个藏族小哥和我一前一后，这个小哥爱开玩笑，老是让马跑步前进，本身就很抖，在一跑，我去，勾deng子qing疼。视频里看别人骑马很飒，真轮到我了就呵呵了。不过慢慢就熟悉了骑马的奥义：肌肉不要太紧绷，要迎合马身体的抖动带动自己身体的抖动，这样就会轻松很多。中途骑着马到达草原上一个山包顶，风很大并且夹杂着雨水，冻得我呀，早知道还是应该穿件藏袍。总之，骑马还是挺好玩的，不知道下一次骑马又是几年后。
之后继续赶路，一路上都是原生态草原景观，中途一些牧民赶着牦牛群穿过公路，刚好碰上，近距离观赏了牦牛这个高原特殊畜种，中途还是顶不过困意睡了一觉。
最后到了唐克的旅馆，放好行李准备去九曲黄河第一湾看日落。
阴差阳错，锟哥想爬上去结果做了电梯；我和杰哥想做电梯结果被锟哥忽悠买了普通票。所以我就和思杰一路顺着木制阶梯一段一段地爬到顶部。不得不说，站在一定高度俯瞰草原是最能体会草原辽阔的手段，感谢锟哥的歪打正着😄。一路上的风景确实非常不错，望着辽阔无边的草原，仿佛此时此刻所有的烦恼都不存在了。这里的海拔没有黄龙那么高，但是3500m左右的海拔然是让我俩每爬一段路就气喘吁吁。
最后在最高点和锟哥会合。不久，太阳从草原最远方的地平线上缓缓落下。没了太阳的草原温度迅速降低，赶快回去享受被窝的我温暖。
Day5 第五天开始返回，顺着红原、瓦切一线返回松潘。其实玩了这几天大家都有点儿累了，草原看了一天也看厌了。今天的最大期待是草原上的烤羊腿。
开整
不出意外，没吃完。
晚上回到松潘，准备搭乘第二天早上的班车回江油
Day6 第六天一大早，简单吃了点儿饭就坐车回江油了，一路上的颠簸还是和来时一样，车程6个小时，到了江油。思杰说来江油读高中3年都没吃过肥肠，哈哈，那还不尝尝，江油肥肠名店除了老火车站的罗肥肠，城里就数这家小小吃了。杰哥很满意，说如果广元肥肠有这个味道，绝对天天吃肥肠。。。
九寨沟的这次旅行，和高中挚友同行，一路都很开心，足矣！</description>
    </item>
    
    <item>
      <title>实体机安装Arch</title>
      <link>114.116.115.171/post/%E5%AE%9E%E4%BD%93%E6%9C%BA%E5%AE%89%E8%A3%85arch/</link>
      <pubDate>Mon, 14 Jun 2021 09:18:48 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%AE%9E%E4%BD%93%E6%9C%BA%E5%AE%89%E8%A3%85arch/</guid>
      <description>准备： 机器：华硕飞行堡垒fx-60vm
第一系统：win10
Arch镜像
https://archlinux.org/download/
镜像考录工具：Rufus
U盘
安装系统 联网 #安装过程中调整字体 setfont ter-132n setfont ter-122b #查看网卡 ip link #有线连接 dhcpcd #无线连接 #查看wifi是否关闭，开启wifi rfkill list rfkill unblock wifi #wifi联网 iwctl [iwd] device list [iwd] station wlan0 scan [iwd] station wlan0 get-networks [iwd] station wlan0 connect SSID #分配ip dhcpcd #测试网络连接 ping archlinux.org 更新系统时间 #更新系统时间 timedatectl set-ntp true #检查服务状态 timedatectl status 系统分区 #查看当前分区 lsblk fdisk -l #新建分区 cfdisk /dev/sdX (X替换成相应的硬盘字母，一般是a或b，默认gpt即可) #分区建议 # /boot/efi:和win10共用 512M # swap:固态硬盘1G # /:固态硬盘剩下所有 #格式化分区 mkfs.</description>
    </item>
    
    <item>
      <title>英语语法框架构建</title>
      <link>114.116.115.171/post/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Mon, 17 May 2021 15:49:41 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/</guid>
      <description>Simple Sentence：主语+谓语 可以独立完成的动作：不及物动词Intransitive Verbs 主语+不及物动词 有一个动作的承受者：单及物动词Monotransitive Verbs 主语+单及物动词+宾语 有两个动作承受者：双及物动词Ditransitive Verbs 主语+间接宾语+直接宾语 只有一个动作承受者（不同于2）：复杂及物动词Complex-Transitive Verbs 主语+复杂及物动词+宾语+宾语补语 不是狭义的”动作“：系动词Linking Verbs 主语+系动词+主语补语(表语) Parts Of Speech：句子成分 Subject：主语 Predicate Verb：谓语动词 Object：宾语 Object Complement：宾语补语 Subject Complement（Predicative）：主语补语（表语） Attributive：定语&amp;mdash;修饰主语/宾语 Adverbial：状语&amp;mdash;修饰谓语动词 Appositive：同位语&amp;mdash;再把主语/宾语说一遍 Non Simple Sentence Compuond Sentence：Simple Sentence+Simple Sentence&amp;hellip;
Complex Sentence：Main Clause（主句）+Subordinate Clause（从句）
Subordinate Clause 主语从句 宾语从句 表语从句 同位语从句 定语从句 状语从句 词类 Nouns：名词 Articles：冠词 Pronouns：代词 Adjectives：形容词 Numerals：数词 Adverbs：副词 Prepositions：介词 Interjections：叹词 Conjunctions：连词 Verbs：动词 注意：对于句子成分和词类的关系而言，除了谓语动词只能用动词，其余句子成份都可能包含不同的词类
Predicate Verbs&amp;rsquo; Big Three（谓语动词的三大本领） 表示动作的时间：Tense 现在 过去 将来 过去将来 表示动作的状态：Aspect 一般 完成 进行 完成进行 表斯动作的假设，情感等：Mood 虚拟语气：If i were a boy &amp;hellip; 陈述语气：I ate a carrot and &amp;hellip; 祈使语气：Eat this carrot and &amp;hellip; 谓语动词充分发挥功能，需要助动词的帮助 注意：不要把助动词和它的其他身份（实义动词）混淆</description>
    </item>
    
    <item>
      <title>经济学原理学习</title>
      <link>114.116.115.171/post/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 15 May 2021 21:49:01 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</guid>
      <description>经济学入门 宗旨：没有对的经济学理论，只有好的经济学理论
Let‘s Go
经济学演变 自给自足，没有交换 开始分工，根据劳动量交换产品 随着生产力发展，更多的产品生产出来，产生货币：从商品中分离出来充当一般等价物的商品，专门用于交换（吾以吾之所有予市场，换吾之所需，货币就是这一过程的约定，它反映的是个体与社会的经济协作关系） 交换促进了分工，分工带来了生产率提升，反过来又促进了交换 交换的前提是交换双方彼此信任。 货币要么是具有稀缺性，要么背后有强权背书。所以一旦遇到乱世，大家都会把货币兑换成普通商品或者硬通货。 早期交易体系：以铜币为基础的弱信用链（谷物，绢帛，铜钱） 早期铜钱货币交易体系中，铜钱较稀缺，铜钱铸造速度&amp;lt;生产率提高速度，市场流通货币减少，货币增值，商品价格下降，会导致通货紧缩 经济由所有市场内的全部交易构成
信任是分工的基石 人类社会的每次变革，都伴随着社会信任关系的重构：
部落内的分工：私人信用体系 国家内的分工：政府信用体系 国家间的分工：银行信用体系 任何交易都依赖于信用体系：所以理论上，只要构建一个足够完善的信用链将所有人纳入其中，就能让更多的人参与交换活动，从而让更多的交易达成，经济得到发展
但是由各种问题阻碍这种理想信任链的形成：分配问题，国家对抗，金融危机&amp;hellip;&amp;hellip;
现代经济学 以银行发放贷款创造出存款货币的银行信用货币体系
政府：负责收税，花钱 中央银行：负责控制货币，信贷数量（通过利率和发行货币） 经济学三类问题： 人们如何作出决策（微观） 人们如何相互作用（微观） 整体经济如何运行（宏观） 经济学的十个原理： 人们如何作出决策？
People face tradeoffs：人们面临得失交换 The cost of somothing is what you give up to get it：某物的成本是为此所放弃的东西 Rational people think at the margin：理性人考虑边际量 People respond to incentives：人们会对激励作出反应 人们如何相互作用？
Trade can make everyone better off：贸易使人人收益 Markets are usually a good way to organize economic activity：市场是组织经济活动的好方式 Governments can sometimes improve market outcomes：政府有时可以改进市场结果 整体经济如何运行？</description>
    </item>
    
    <item>
      <title>股票入门</title>
      <link>114.116.115.171/post/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 15 May 2021 14:58:12 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/</guid>
      <description>理财的几种投资渠道： 银行利息 年利率1.5% 银行的利率跑不赢通货膨胀 证券投资：股票 收益高 波动很大，技术要求大 房地产投资 基金 收益低点：货币基金，纯债基金 收益高点：股票型基金，混合型基金 一些概念： 债券：别人买你，还你利息 股票：共同分享开公司的成果 A股：中国大陆公司发行的股票 指数：一家公司一只股票，多支股票组合形成指数 大盘（上证指数）：在上海债券交易所上发行的所有股票组合 小盘（中证500指数）：选取了500家中小公司的股票组合 基金：由基金公司拿我们的钱，帮我们买股票，债券，帮助我们打理我们的钱 我们不会理财，可以找大的基金公司（天弘，富国&amp;hellip;&amp;hellip;），千万不要找P2P 关于基金Fund的一些概念 开放式基金（随买随卖）按照投资类型一般分为：
股票型：风险较高收益较多 债券型：风险较低收益较少 混合型：股票+债券 货币型：风险最小，收益最少。投资于货币市场的基金。例：一年以内的银行定期存款，剩余期限397天以内的债券 经济 &amp;amp; 金融 ？ 经济 一次性的买卖，为了自己消费 供需定价 金融 买家炒来炒去，为了自己赚钱 预期决定价格，大家看涨它就涨 股票分类： A股，B股，H股，N股，S股
一般做的都是沪深A股（上海证券交易所 &amp;amp; 深圳证券交易所）
60开头——上证A股 0开头——深证A股 3开头——创业版（证券公司去开通） 688开头——科创版（最低50W资金） 股票交易时间 周一到周五（09:30-11:30，13:00-15:00） 周六周日休市，法定节日休市 09:15-09:20：随便挂单随便撤单 09:20-09:25：随便挂单不可撤单 股票的涨跌幅 0和60股票每天涨跌幅是10% 3股票每天涨跌幅是20% 68股票前5个交易日无限制，后面涨跌幅是20% 新股第一天涨跌幅44% ST股（亏损股）：涨跌幅是5% 股票分时图和K线图 股票交易规则 股票最低买1手=100股，不同上市股票每股价格不同 股票交易费由三部分组成：佣金，印花税，过户费（仅上股收取） 印花税：0.1% 过户费：0.002% 交易佣金：最高0.003%，最低5元 交易佣金是双向收取：买 &amp;amp; 卖 看盘软件界面介绍 股票趋势 顺势而为，不能和大盘逆向操作 尽量做上涨趋势的股票 支撑位和压力位 突破和跌破 股票盘口 股票买卖机制 自己通过各种软件买卖软件中的模拟买卖来练习</description>
    </item>
    
    <item>
      <title>Java中加载配置文件的几种方法</title>
      <link>114.116.115.171/post/java%E4%B8%AD%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 21 Mar 2021 19:22:16 +0000</pubDate>
      
      <guid>114.116.115.171/post/java%E4%B8%AD%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>Java的常用web框架中会有很多配置文件，这些配置文件都是为了降低代码耦合性而从代码中剥离出来的。为了在程序运行时动态地加载这些文件进内存，需要加载这些配置文件，学习过程中发现有很多种方法都能将这些配置文件加载进内存，需要总结下方便记忆。
基于ClassLoader加载配置文件 Properties properties = new Properties(); InputStream in = 当前类名.class.getClassLoader().getResourceAsStream(&amp;#34;配置文件相对路径&amp;#34;); properties.load(in); System.out.println(properties.getProperty(&amp;#34;username&amp;#34;)); System.out.println(properties.getProperty(&amp;#34;password&amp;#34;)); 基于Resources读取配置文件 InputStream resourceAsStream = Resources.getResourceAsStream(&amp;#34;SqlMapConfig.xml&amp;#34;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close(); 基于ResourceBundle读取配置文件 ResourceBundle resourceBundle = ResourceBundle.getBundle(&amp;#34;配置文件相对路径&amp;#34;); System.out.println(resourceBundle.getString(&amp;#34;username&amp;#34;)); InputStream in3 = new FileInputStream(new File(filePath)); ResourceBundle resourceBundle2 = new PropertyResourceBundle(in3); System.out.println(resourceBundle2.getString(&amp;#34;username&amp;#34;)); </description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>114.116.115.171/post/nginx/</link>
      <pubDate>Thu, 18 Mar 2021 22:10:05 +0000</pubDate>
      
      <guid>114.116.115.171/post/nginx/</guid>
      <description> Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 应用场景 http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 HTTP服务器 将静态网站文件 上传到服务器的/usr/local/nginx/html下即可访问 虚拟主机 虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器。虚拟主机技术极大的促进了网络技术的应用和普及。同时虚拟主机的租用服务也成了网络时代的一种新型经济形式。 端口绑定 域名绑定 反向代理 负载均衡 </description>
    </item>
    
    <item>
      <title>Arch入教路</title>
      <link>114.116.115.171/post/arch%E5%85%A5%E6%95%99%E8%B7%AF/</link>
      <pubDate>Wed, 17 Mar 2021 10:29:41 +0000</pubDate>
      
      <guid>114.116.115.171/post/arch%E5%85%A5%E6%95%99%E8%B7%AF/</guid>
      <description>我的linux入门是redhat系，跟着兄弟连用的centos。之后一直用的debian系，包括桌面日用，ubuntu，deepin，kubuntu，mint。早就听说了Arch邪教，纯命令安装系统，需要对linux系统有更深的了解，也借这个契机来试试。
第一步：虚拟机试探 官网下载安装包
启动vBox，开始进入安装界面
确保开启虚拟机的EFI支持
确保网络
ip link #有线网络 dhcpcd #无线网络 iwctl [iwd] device list [iwd] station device scan [iwd] station device get-networks [iwd] station device connect SSID ping www.baidu.com 更新系统时间
timedatectl set-ntp true #检查服务状态 timedatectl status 系统分区
fdisk -l cfdisk /dev/sdx (x替换成相应的硬盘字母，一般是a或b，默认gpt即可) 分区结果
mkfs.fat -F32 /dev/sda1 mkfs.ext4 /dev/sda3 mkswap /dev/sda2 swapon /dev/sda2 挂载
mount /dev/sda3 /mnt mkdir /mnt/boot mount /dev/sda1 /mnt/boot 安装
vim /etc/pacman.d/mirrorlist # 找到中国镜像移到最上面或者添加 Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # pacstrap脚本安装arch基础 pacstrap /mnt base base-devel linux linux-firmware dhcpcd vim 生成fstab挂载文件</description>
    </item>
    
    <item>
      <title>redis缓存技术</title>
      <link>114.116.115.171/post/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 16 Mar 2021 10:54:17 +0000</pubDate>
      
      <guid>114.116.115.171/post/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</guid>
      <description>Redis简介： **概念：**redis是一款高性能的NOSQL（Not Only SQL）系列的菲关系型数据库
Redis特点：
Redis 是一个开源的使用 ANSI、C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。
Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。
关系型数据库和非关系数据库是互补的关系，通常情况下使用关系型数据库，在适合的情况下使用NOSQL数据库能够堆关系型数据库的不足进行弥补从而提高网站的性能。
一般会将数据存储在关系型数据库中，在nosql数据库中备份关系型数据库的数据
目前Redis支持的键值数据类型如下：
字符串类型：string 哈希类型：hash 列表类型：list 集合类型：set 有序集合类型：sortedset Redis的应用场景：
缓存（数据查询，短连接，新闻内容，商品内容） 聊天室的在线好友列表 任务队列（秒杀，抢购，12306抢票） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒级别） 分布式集群架构中的session分离 安装 debian：sudo apt install redis
启动服务：执行sudo systemctl start redis
关闭服务：执行sudo systemctl stop redis
进入客户端：redis-cli
命令操作 字符串类型：string
set key value get key del key 哈希类型：hash
hset key field value hget key field hgetall key hdel key field 列表类型：list
lpush key value rpush key value lrange key start end lpop key rpop key 集合类型：set</description>
    </item>
    
    <item>
      <title>javaWeb三大组件</title>
      <link>114.116.115.171/post/javaweb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Tue, 16 Mar 2021 10:51:26 +0000</pubDate>
      
      <guid>114.116.115.171/post/javaweb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/</guid>
      <description>Servlet 见之前的两篇博客：《javaWeb核心-理解servlet》，《javaWeb核心-servlet细节》，讲的很详细 Filter：过滤器 拦截请求：完成通用操作（登录验证，统一编码，敏感字符过滤） @WebFilter(&amp;#34;/*&amp;#34;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&amp;#34;filterDemo1被执行了....&amp;#34;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } web.xml配置 &amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;demo1&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;cn.itcast.web.filter.FilterDemo1&amp;lt;/filter-class&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;demo1&amp;lt;/filter-name&amp;gt; &amp;lt;!-- 拦截路径 --&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; 过滤器执行流程
执行放行前的代码 执行放行后的资源 回来执行过滤器放行代码下边的代码（一般是对response对象做增强） 过滤器生命周期方法
**init:**在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 **doFilter:**每一次请求被拦截资源时，会执行。执行多次 **destroy:**在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解
拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2.</description>
    </item>
    
    <item>
      <title>java基础快速回顾-下</title>
      <link>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8B/</link>
      <pubDate>Tue, 09 Mar 2021 11:42:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8B/</guid>
      <description>Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 //一些参数，一个箭头，一段重写代码 () -&amp;gt; System.out.println(&amp;#34;lambda&amp;#34;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;amp;目录的创建、查找和删除等操作 //File类的4个成员变量 //路径分隔符(windows分号,linux冒号) static String pathSeparator; static char pathSeparatorChar; //默认名称分隔符(windows反斜杠，linux正斜杠) static String separator; static char separator; //注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 /** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况 **/ public static void main(){ File f1 = new File(&amp;#34;/home/jack1024/桌面/a.txt&amp;#34;); File f2 = new File(&amp;#34;/home/jack1024/桌面/a&amp;#34;); } File类常用方法： public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径） public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串） public String getName();//文件/目录名字 public long length();//文件字节大小(目录没有大小概念) 判断功能： public boolean exists();//该文件/目录是否存在 public boolean isDirectory();//是否为目录 public boolean isFile();//是否为文件 创建 &amp;amp; 删除 public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件 public boolean delete();//删除由此File表示的文件或目录，不走回收站 public boolean mkdir();//创建由此File表示的目录 public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录 public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp;amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示：</description>
    </item>
    
    <item>
      <title>java基础快速回顾-中</title>
      <link>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%AD/</link>
      <pubDate>Sat, 06 Mar 2021 09:36:20 +0000</pubDate>
      
      <guid>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%AD/</guid>
      <description>Java某些类 Object类 java的根类 toString() Object类的toString()方法默认返回该对象实现类的“类名+@+hashcode”值 看一个类是否重写了toString方法，可以通过直接打印对象名字，没有重写的显示对象地址值，重写的按照toString重写内容自定义打印 equals() Object类的equals()方法默认就是用==来进行比较 public class Person{ public String name; public int age; @Override public boolean equals(Object obj){ Person p = (Person)obj; return this.name.equals(p.name) &amp;amp;&amp;amp; this.age==p.age; } } public class Test{ public static void main(String[] args){ Person p1 = new Person(); p1.name = &amp;#34;jack&amp;#34;; p1.age = 10; Person p2 = new Person(); p2.name = &amp;#34;sam&amp;#34;; p2.age = 14; p1.equals(p2); } } Objects类 Objectsq工具类提供了一些静态方法来操作对象，这些方法是空指针安全，容忍空指针的 String s1 = null; String s2 = &amp;#34;jack&amp;#34;; System.</description>
    </item>
    
    <item>
      <title>我的Linux工作平台搭建</title>
      <link>114.116.115.171/post/%E6%88%91%E7%9A%84linux%E5%B7%A5%E4%BD%9C%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 06 Mar 2021 09:35:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%88%91%E7%9A%84linux%E5%B7%A5%E4%BD%9C%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</guid>
      <description>Mint LInux安装概述 rufus录入iso镜像到U盘 进入bios界面调节启动位置为U盘 开机进入安装界面，下一步&amp;hellip; efi分区自动放入win10的efi分区，/分区45G，/home分区300G，swap分区1G 安装后配置 双系统时间不同步 sudo apt update # 禁用Ubuntu的UTC timedatectl set-local-rtc 1 --adjust-system-clock # 更新本地时间 sudo apt install ntpdate sudo ntpdate time.windows.com # 将本地时间更新到硬件上 sudo hwclock --localtime --systohc 输入法里安装ficix &amp;amp; 安装搜狗输入法 IDEA等jetbrain公司的IDE的搜狗输入法不跟随问题可以采用更改这些IDE的运行环境解决 完善mint的中文支持 sudo apt-get install language-pack-zh-hans language-pack-gnome-zh-hans #添加微软雅黑字体 #雅黑字体文件放在 Windows/fonts/ 文件夹，或者在控制面板-字体中查找，两个文件名分别为：msyh.ttf和msyhbd.ttf。字体 # 在Linux mint 系统字体文件夹中创建对应的字体文件夹： sudo mkdir /usr/share/fonts/msyh # 移动字体文件到对应的文件夹下： udo mv msyh.ttf msyhbd.ttf /usr/share/fonts/msyh # 更新字体： sudo fc-cache -fv 安装typora wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # 添加公钥 sudo add-apt-repository &amp;#39;deb https://typora.</description>
    </item>
    
    <item>
      <title>旧手机搭建linux服务器</title>
      <link>114.116.115.171/post/%E6%97%A7%E6%89%8B%E6%9C%BA%E6%90%AD%E5%BB%BAlinux%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Fri, 19 Feb 2021 20:43:01 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%97%A7%E6%89%8B%E6%9C%BA%E6%90%AD%E5%BB%BAlinux%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>硬件&amp;amp;软件准备： 硬件：
一台已root的安卓手机 软件：
Linux Deploy：https://github.com/meefik/linuxdeploy/releases busyBox：https://github.com/meefik/busybox/releases 开干 点开busyBox直接安装，记住安装地址 点开linux deploy，点击左上角三条杠，修改系统名字，然后进入设置，自己根据需要开关选项 在PATH环境变量里写上busyBox的安装路径 点击右下角的属性按钮，根据需要安装linux发行版 我选的是ubuntu，考虑到国内网络环境，将源地址改为http://mirrors.ustc.edu.cn/ubuntu-ports/ 在镜像大小里最好分多点空间，默认只有2G，如果有外置sd卡最好把镜像地址改为sd卡的地址，这样能自行分区更合理。 修改初始用户的username和password，本地化选择语言，推荐英文 初始化，挂载，SSH，声音服务 推荐都弄上 返回主界面，点击右上角三个点开始安装，等待一会儿，直到出现deploy字样，说明安装成功 此时先点击停止，在点击启动，就可以根据局域网ip通过ssh来远程连接安卓上linux容器了。 配置 做一些配置
apt update apt upgrade apt install gcc g++ vim git openjdk-8-jdk net-tools bash-completion htop # LinuxDeploy下ping命令无法运行，提示socket：权限不足，原来android里将一些硬件使用（包括网络）的权限归到不同的用户组. 而3003就是关于网络权限的组，称为inet. 上述命令是在debian的用户权限系统中给root 添加inte权限． usermod -G 3003 root # 修改root的密码 su - root passwd 安装samba服务 #安装samba apt install samba samba-common #选定需要共享的文件夹 mkdir XXX #设置文件夹权限 chmod 777 XXX #设置samba用户密码 useradd smbUser smbpasswd -a smbUser smbpasswd -xx smbUser #配置samba的配置文件 vim /etc/samba/smb.</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>114.116.115.171/post/jdbc/</link>
      <pubDate>Thu, 18 Feb 2021 07:31:41 +0000</pubDate>
      
      <guid>114.116.115.171/post/jdbc/</guid>
      <description>JDBC JDBC本质： 其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。
操作步骤 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键&amp;ndash;&amp;gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 //1. 导入驱动jar包 //2.注册驱动 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); //3.获取数据库连接对象 //如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 Connection conn = DriverManager.getConnection(&amp;#34;jdbc:mysql://localhost:3306/db3&amp;#34;, &amp;#34;root&amp;#34;, &amp;#34;root&amp;#34;); //4.定义sql语句 String sql = &amp;#34;update account set balance = 500 where id = 1&amp;#34;; //5.获取执行sql的对象 Statement //prepareStatement(String sql)解决sql注入问题 Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 几个重要对象 DriverManager
//通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 //mysql5之后的驱动jar包可以省略注册驱动的步骤。 static { try { java.</description>
    </item>
    
    <item>
      <title>玩儿转MySQL</title>
      <link>114.116.115.171/post/%E7%8E%A9%E5%84%BF%E8%BD%ACmysql/</link>
      <pubDate>Thu, 11 Feb 2021 20:21:12 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E7%8E%A9%E5%84%BF%E8%BD%ACmysql/</guid>
      <description>数据库的特点：
持久化存储数据，数据库就是一个文件系统 方便存储并管理数据 提供了方式统一操作数据 常见的数据库软件：
数据库软件是对数据库的不同实现 常见的有： Oracle MySQL Microsoft SQL Server DB2 MongoDB SQLite Redis MySQL准备 安装：推荐5.7版本 Windows直接官网下载安装包，然后根据提示选择并下一步，如果要删除除了在控制面板卸载，还需要在C盘的ProgramData的目录下的mysql目录卸载
Linux下的安装/卸载参考博客另一篇博文《我的linux工作平台搭建》
启动 #本地启动 mysql -uroot -proot #远程连接 mysql -h127.0.0.1 -uroot -proot #详细写 mysql --host=127.0.0.1 --user=root --password=root #退出 exit or quit SQL语句 **SQL：**Structured Qurey Language，结构化查询语言实际上就是定义了操作所有关系型数据库的规则 -- SQL语句注意事项： # SQL语句特有的注释 /** SQL语句可以单行或者多行书写，以分号结尾 SQL语句不区分大小写，关键字建议使用大写 **/ -- 查看该操作系统下的mysql各文件的存储位置 show variables like &amp;#39;%dir%&amp;#39;; -- 查看该操作系统下的编码情况 show variables like &amp;#39;%character%&amp;#39;; SQL语句分类 DDL（操作数据库、表） 数据定义语言 drop，create，alter Create
数据库:
create database if not exists db1; create database db2 character set gbk; 数据库类型：</description>
    </item>
    
    <item>
      <title>SSM框架-Mybatis</title>
      <link>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-mybatis/</link>
      <pubDate>Fri, 22 Jan 2021 22:40:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-mybatis/</guid>
      <description>开始 原始jdbc操作的分析 原始jdbc开发存在的问题如下：
数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案：
使用数据库连接池初始化连接资源 将sql语句抽取到xml配置文件中 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 什么是Mybatis mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 开发步骤 MyBatis开发步骤：
添加MyBatis的坐标 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapConfig.xml 编写测试类 &amp;lt;!--mybatis坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.4.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--mysql驱动坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.6&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--单元测试坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--日志坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; public class User { private int id; private String username; private String password; //省略get个set方法 } &amp;lt;?</description>
    </item>
    
    <item>
      <title>SSM框架-SpringMVC</title>
      <link>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-springmvc/</link>
      <pubDate>Thu, 21 Jan 2021 22:40:31 +0000</pubDate>
      
      <guid>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-springmvc/</guid>
      <description>SpringMVC的简介 SpringMVC概述 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。
SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。
SpringMVC快速入门 需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。
开发步骤
导入SpringMVC相关坐标 配置SpringMVC核心控制器DispathcerServlet 创建Controller类和视图页面 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件 spring-mvc.xml 客户端发起请求测试 代码实现
①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标
&amp;lt;!--Spring坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--SpringMVC坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.0.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Servlet坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Jsp坐标--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; ②在web.xml配置SpringMVC的核心控制器
&amp;lt;servlet&amp;gt; &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt; &amp;lt;/servlet&amp;gt; &amp;lt;servlet-mapping&amp;gt; &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt; &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt; &amp;lt;/servlet-mapping&amp;gt; ③创建Controller和业务方法</description>
    </item>
    
    <item>
      <title>SSM框架-Spring</title>
      <link>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-spring/</link>
      <pubDate>Wed, 20 Jan 2021 22:40:22 +0000</pubDate>
      
      <guid>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6-spring/</guid>
      <description>Spring简介 Spring前身：EJB框架 Spring优点 方便解耦，简化开发：IOC容器使对象的依赖关系由Spring控制，编程者更专注于上层的应用 AOP编程的支持：方便面向切面编程 声明式事务的控制：配置的方式简化开发 Junit：方便程序测试 方便集成各种优秀的框架：Mybatis等 降低JavaEE API的使用难度：提供了一些工具的封装类 开源：方便学习 Spring程序大致步骤 导入Spring开发的maven依赖 编写Dao接口和实现类 创建Spring核心配置文件applicationContext.xml 在Spring配置文件中配置实现类 使用Spring的API获得Bean实例 Spring核心配置文件 bean标签 **id：**唯一性标识，通过其获得对象 **class：**bean的全限定名称 **scope：**singleton(默认)，prototype等5个 scope：bean对象在核心配置文件加载时就创建，只有一个，spring容器销毁时才会销毁bean prototype：bean对象在每次getBean时创建一个，对象长时间不用会被GC垃圾回收机制回收 **init-method：**指定类中初始化方法名称，对象创建后执行 **destory-method：**指定类中销毁方法名称，对象销毁前执行 bean实例化的三种方式： 无参构造实例化：默认 工厂静态方法实例化：factory-method=“工厂方法”，class中写工厂类 工厂实例方法实例化：需要先bean一个工厂对象，然后factory-bean=“工厂实例”，factory-method=“工厂方法” 依赖注入 依赖注入是Spring框架核心IOC的具体体现 通过控制反转，把对象的控制权交给Spring容器。IOC解耦可以降低Service业务层和Dao持久层之间的关系，此时依赖关系就由Spring来维护了，Spring容器会自己把持久层对象传入业务层。 如何把UserDao依赖注入到UserService中？ /** 构造方法 **/ public class UserServiceImpl implements UserService{ private UserDao userDao; public UserServiceImpl(UserDao userDao){ this.userDao = userDao; } public userServiceImpl(){ } public void save(){ usreDao.save(); } } //name指的构造函数的参数名 &amp;lt;bean id=&amp;#34;userDao&amp;#34; class=&amp;#34;link.jack1024.dao.impl.UserDaoImpl&amp;#34;&amp;gt;&amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;userService&amp;#34; class=&amp;#34;link.jack1024.service.impl.UserServiceImpl&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;userDao&amp;#34; ref=&amp;#34;userDao&amp;#34;&amp;gt;&amp;lt;/constructor-arg&amp;gt; &amp;lt;/bean&amp;gt; /** set方法 **/ public class UserServiceImpl implements UserService{ private UserDao userDao; public void setUserDao(UserDao userDao){ this.</description>
    </item>
    
    <item>
      <title>web前端-elementUI</title>
      <link>114.116.115.171/post/web%E5%89%8D%E7%AB%AF-elementui/</link>
      <pubDate>Thu, 14 Jan 2021 20:04:58 +0000</pubDate>
      
      <guid>114.116.115.171/post/web%E5%89%8D%E7%AB%AF-elementui/</guid>
      <description>利用vue-cli搭建vue的webpack项目 # 初始化webpack项目 vue init webpack vue01 cd vue01 # 安装依赖 cnpm install vue-router --save-dev cnpm install element-ui --save cnpm install axios vue-axios --save cnpm install # main.js中引入 import ElementUI from &amp;#39;element-ui&amp;#39; import &amp;#39;element-ui/lib/theme-chalk/index.css&amp;#39; import axios from &amp;#39;axios&amp;#39; import VueAxios from &amp;#39;vue-axios&amp;#39; import VueRouter from &amp;#39;vue-router&amp;#39; Vue.use(ElementUI); Vue.use(VueAxios,axios); Vue.use(VueRouter); </description>
    </item>
    
    <item>
      <title>精简版JS:jQuery</title>
      <link>114.116.115.171/post/%E7%B2%BE%E7%AE%80%E7%89%88js-jquery/</link>
      <pubDate>Wed, 13 Jan 2021 22:34:34 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E7%B2%BE%E7%AE%80%E7%89%88js-jquery/</guid>
      <description>JavaScript 和 JQuery jQuery就是一个JavaScript库，里面封装了大量JavaScript函数
推荐一个各种开源项目CDN服务搜索网站：https://www.bootcdn.cn/
&amp;lt;a href=&amp;#34;&amp;#34; id=&amp;#34;text-jquery&amp;#34;&amp;gt;click me&amp;lt;/a&amp;gt; &amp;lt;!--JavaScript的在线cdn引入--&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; //公式：$(css的selector).action(); //document.getElementById(&amp;#34;text-jquery&amp;#34;).onclick = function(){} $(&amp;#34;#text-jquery&amp;#34;).click(function(){ alert(&amp;#34;hello,jquery&amp;#34;); }) &amp;lt;/script&amp;gt; $是什么 //jQuery的文件结构：其实是一个自执行函数,引入了jquery的js文件，会执行这个自执行函数。 (function(){ window.jQuery = window.$ = jQuery;//给window对象添加一个jQuery属性和$属性，用JQuery函数赋值给$ //$是一个函数，所以会根据参数的不同进行不同的处理 $(function(){});//入口函数 $(&amp;#34;#div&amp;#34;);//选择器 $(&amp;#34;&amp;lt;div&amp;gt;我是一个div标签&amp;lt;/div&amp;gt;&amp;#34;);//创建div标签 $(dom对象);//把dom对象转化为jquery对象 }) Dom对象和jQuery对象 dom对象：原生js选择器获取到的对象，只能调用dom属性或者方法，但是不能调用jQuery的属性和方法
var div1 = document.getElementById(&amp;#34;div1&amp;#34;); div1.style.backgroundColor = &amp;#34;red&amp;#34;; jQuery对象：由jQuery选择器获取到的对象，只能调用jQuery的属性或者方法，但是不能调用原生js的属性和方法
var div1 = $(&amp;#34;#div1&amp;#34;); div1.css(&amp;#34;backgroundColor&amp;#34;,&amp;#34;red&amp;#34;); jquery对象是一个伪数组，其实是dom对象的一个包装集
jQuery和JavaScript对象的互相转化：
//JavaScript对象——》jQuery对象 var div1 = document.getElementById(&amp;#34;div1&amp;#34;); var $div1 = $(div1); $div1.css(&amp;#34;backgroundColor&amp;#34;,&amp;#34;red&amp;#34;); //jQuery对象——》JavaScript对象 var $div1 = $(&amp;#34;#div1&amp;#34;); var div1 = $div1[0]; var div2 = $div1.</description>
    </item>
    
    <item>
      <title>JavaScript快速回顾</title>
      <link>114.116.115.171/post/javascript%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Fri, 08 Jan 2021 15:27:36 +0000</pubDate>
      
      <guid>114.116.115.171/post/javascript%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</guid>
      <description>再次回顾前端三件套
HTML（结构）：超文本标记语言，决定网页的结构和内容 CSS（表现）：层叠样式表，设定网页的表现样式 JavaScript（行为）：一种弱类型的脚本语言，其源代码不需要经过编译，由浏览器解释运行，用于控制网页的行为。 历史
Native原生JS开发：按照【ECMAScript】标准的开发方式，特点是所有浏览器都支持。（目前的主流版本是ES6，但是ES5才是所有浏览器都支持，所以需要用webpack把ES6打包为ES5） TypeScript微软标准：微软开发的语言，是JavaScript的超集。除了具备ES的特性之外还有很多不在范围内的新特性，会导致很多浏览器不能直接支持Typescript语法，需要编译后才能被浏览器正确执行。 Javascript流行库 &amp;amp; 框架
jQuery：简化原生JavaScript操作的JS库 Angular：Goole收购的前端框架 React：Facebook开发的高性能JS前端框架 Vue：渐进式JavaScript框架，特点是综合了Angular(模块化)和React(虚拟DOM)的优点 Axios：前端通信框架 UI框架：
Ant-Design：阿里巴巴 ElementUI，iview，ice：饿了么 Boostrap：Twitter AmazeUI：妹子UI JavaScript构建工具
Babel：Typescript编译工具 Webpack：模块打包器 世界上最流行的脚本语言——Javascript ECMAScript是JavaScript的一种规范，目前已经到ES6了。但是大部分浏览器只支持到ES5
作为一名后端程序员，必须要精通Javascript！
快速入门 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;!--第二种外部引入方式--&amp;gt; &amp;lt;script src=&amp;#34;js/a.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--第一种方式--&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; alert(&amp;#34;hello,world!&amp;#34;); &amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 基本语法 基本上按照java语法来写JavaScript一定没有问题：
//定义变量（可带$和_） var num = 1; //条件控制 if(2&amp;gt;1){ alert(&amp;#34;true&amp;#34;); } //JavaScript严格大小写 console.log(score); var 和 let的区别 JavaScript中的变量大致分为局部变量和全局变量
大体上：函数外声明的就是全局变量，函数内声明的就是局部变量
变量是需要用var关键字声明的。但是javascript中也可以隐式的使用变量，就是不用声明，直接使用。但是千万注意，javascript把隐式声明的变量总是当成全局变量来使用的。
let和var的区别体现在作用域上：var的作用域是函数作用域，let作用域则被规定为块作用域，块作用域要比函数作用域小一些，但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。
举个栗子：
&amp;lt;!--有五个按钮--&amp;gt; &amp;lt;div&amp;gt; &amp;lt;button&amp;gt;按钮1&amp;lt;/button&amp;gt; &amp;lt;button&amp;gt;按钮2&amp;lt;/button&amp;gt; &amp;lt;button&amp;gt;按钮3&amp;lt;/button&amp;gt; &amp;lt;button&amp;gt;按钮4&amp;lt;/button&amp;gt; &amp;lt;button&amp;gt;按钮5&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; var btns=document.</description>
    </item>
    
    <item>
      <title>CSS快速回顾</title>
      <link>114.116.115.171/post/css%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Fri, 08 Jan 2021 15:27:24 +0000</pubDate>
      
      <guid>114.116.115.171/post/css%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</guid>
      <description>前端三件套 HTML+CSS+JavaScript
结构+表现+交互
css历史 1.0 2.0 2.1 3.0 怎么学CSS CSS是什么 CSS怎么用 CSS选择器（重难点） 美化网页（文字，阴影，超链接，列表，渐变） 盒子模型（重点） 浮动 定位 网页动画（特效） 什么是CSS 层叠样式表(Cascading Style Sheets)，美化网页（字体，颜色，边距，高度，宽度，背景图片，网页） 发展史： CSS1.0：高耦合内联基础样式 CSS2.0：DIV+CSS，HTML和CSS结构分离的思想，网页变得简单，利于SEO CSS2.1：浮动，定位 CSS3.0：圆角，阴影，动画&amp;hellip;..有浏览器兼容性问题（IE6前端之殇） CSS快速入门 /* 规范语法： 选择器{ 属性1:属性值; 属性2:属性值; ... } */ h1{ color: red; } CSS优势： 内容和表现分离 网页结构表现统一，可以实现复用 样式十分丰富 建议使用独立于html的css文件 利用seo，容易被搜索引擎收录 三种导入方式 &amp;lt;!--1. 行内样式--&amp;gt; &amp;lt;h1 style=&amp;#34;color: red&amp;#34;&amp;gt;中华人民共和国&amp;lt;/h1&amp;gt; &amp;lt;!--2. 内部样式表--&amp;gt; &amp;lt;!DOCTYPE&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;内部样式表&amp;lt;/title&amp;gt; &amp;lt;!--使用内部样式表引入CSS--&amp;gt; &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; div{ background: green; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;我是DIV&amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>HTML快速回顾</title>
      <link>114.116.115.171/post/html%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</link>
      <pubDate>Fri, 08 Jan 2021 15:27:14 +0000</pubDate>
      
      <guid>114.116.115.171/post/html%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/</guid>
      <description>初识HTML Hyper Text Markup Language
超文本：文字，图片，音频，视频，动画等
HTML5：
HTML5和CSS3是未来发展趋势 W3C：World Wide Web Consortium万维网联盟，Web技术领域最权威和具影响力的国际中立性技术标准机构，W3C标准包括：
结构化标准语言（HTML，XML） 表现标准语言（CSS） 行为标准（DOM，ECMAScript） HTML基本结构
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;My Frist Page&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; My First Page &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 网页基本标签 &amp;lt;!--DOCTYPE告诉浏览器使用什么规范--&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt;&amp;lt;!--中文网站设置为zh-CN--&amp;gt; &amp;lt;!--网页头部--&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!--描述网站一些信息，可用做seo--&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;!--页面关键词，用于被搜索引擎收录--&amp;gt; &amp;lt;meta name=&amp;#34;keywords&amp;#34; content=&amp;#34;学习，记录&amp;#34;&amp;gt; &amp;lt;!--页面描述，用于搜索引擎收录--&amp;gt; &amp;lt;meta name=&amp;#34;excerpt&amp;#34; content=&amp;#34;我的第一个网页&amp;#34;&amp;gt; &amp;lt;!--用于控制页面缩放--&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;!--网页标题--&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;!--网页主体--&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 标题标签
&amp;lt;h1&amp;gt;一级标题&amp;lt;/h1&amp;gt; &amp;lt;h2&amp;gt;二级标题&amp;lt;/h2&amp;gt; &amp;lt;h3&amp;gt;三级标题&amp;lt;/h3&amp;gt; &amp;lt;h4&amp;gt;四级标题&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;五级标题&amp;lt;/h5&amp;gt; &amp;lt;h6&amp;gt;六级标题&amp;lt;/h6&amp;gt; 段落标签
&amp;lt;p&amp;gt;段落内容&amp;lt;/p&amp;gt; 换行标签
&amp;lt;br/&amp;gt; &amp;lt;br&amp;gt; 水平线标签</description>
    </item>
    
    <item>
      <title>vue入门指南</title>
      <link>114.116.115.171/post/vue%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Tue, 05 Jan 2021 17:09:07 +0000</pubDate>
      
      <guid>114.116.115.171/post/vue%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>**vue：**一款渐进式（逐步实现新特性）JavaScript框架。其特性综合了Angular(模块化MVVM)和React(虚拟DOM)的优点
**Ajax：**前端通信框架，因为Vue的边界很明确，就是为了处理DOM，所以不具备通信能力，需要额外使用一个通信框架和服务器交互；也可以直接选择使用jQuery提供的Ajax同行功能(只是因为为了使用Ajax要完全导入jQuery的包显得很笨重)
前端MVVM框架：
后端中的MVC框架中V：视图层；C：控制层；M：模型层 传统的使用后端模板引擎渲染的方式，V就是指的jsp，freemarker等技术。 前后端分离的概念渐渐出现，特别是在前端框架出现后，前端根据后端的MVC模式，也对前端进行了层次划分，对原来的V转化前端独立渲染。并且也将V扩展为前端自己的MVC三层：V层，M层，VM层。也就是MVVM模式 V：view M：data VM：数据双向绑定 前端UI框架：
Ant-Desgin：基于React的UI框架 ElementUI，iview，ice：基于Vue的UI框架 Bootstrap：Twitter推出的前端开发工具包 AmazeUI：HTML5跨屏前端框架 JavaScript构建工具：
Babel：JS编译工具，主要用于浏览器不支持的ES新特性 WebPack：模块打包器 NodeJS
前端人员为了方便开发也需要掌握一定的后端技术，但是java后端异常庞大。所以为了方便前端人员开发后台应用，出现了NodeJS这样的技术。 NodeJS由于架构问题和笨重的node_modules，作者已经放弃，不久的将来，Deno可能将会取代NodeJS Express：NodeJS框架 Koa：Express简化版 NPM：项目综合管理工具 YARN：NPM的替代方案，类似于Maven和Gradle的关系 vue-element-admin:
这是一个集成大部分功能的后台管理系统框架，也就是说大多数的组件都帮我们写好了，他是基于vue-element进行开发布局的。
MVVM框架 源自经典的MVC模式，MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用 具体分层： Model：模型层，这里表示JavaScript对象 View：视图层，这里表示DOM ViewModel：连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者 ViewModel MVVM架构中，不允许数据和视图直接通信，只能通过ViewModel通信，而ViewModel就是定义了一个Observer观察者 ViewModel能观察到数据的变化，并对视图相应内容进行更新 ViewModel能监听试图的变化，并能够通知数据发生改变 Vue.js的核心是：DOM监听&amp;amp;数据绑定
**虚拟DOM：**Vue的ViewModel绑定了数据和视图两层，所以无需操作DOM，工作知识修改DOM中的某些数据而已。这让前端资源大大节省了。 View层展现的不是Model层的数据，而是ViewModel的数据，由ViewModel负责和Model层交互，这就完全解耦了View层和Model层，这个解耦是至关重要的，它是前后端分离的关键。 VUE { { } } &amp;amp; v-text,v-cloak &amp;amp; v-html
这就是前端的浏览器模板引擎渲染生成html页面。Vue在背后做了大量工作，现在数据和DOM已经建立了关系，所有东西都是响应式的。在控制台操作对象属性后界面能实时更新。
&amp;lt;!-- 生产环境版本，优化了尺寸和速度 --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/vue&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--创建一个容器，使用Vue对象绑定该容器就可以控制这个容器中的所有DOM元素--&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!--插值表达式中可以写任意合法的JS表达式--&amp;gt; &amp;lt;!--插值表达式会有闪烁问题，用v-cloak解决--&amp;gt; &amp;lt;span&amp;gt;{{ message }}&amp;lt;/span&amp;gt; &amp;lt;span v-text=&amp;#34;message&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span v-html=&amp;#34;message2&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; var app = new Vue({//这个对象app就是MVVM中的VM，核心，提供了双向数据绑定的能力 el: &amp;#39;#app&amp;#39;,//和要控制的容器绑定，MVVM中的V视图层 data: {//要渲染的一些数据，MVVM中的M数据层 message: &amp;#39;Hello Vue!</description>
    </item>
    
    <item>
      <title>javaweb-前后端分离史</title>
      <link>114.116.115.171/post/javaweb-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%8F%B2/</link>
      <pubDate>Sat, 02 Jan 2021 21:55:24 +0000</pubDate>
      
      <guid>114.116.115.171/post/javaweb-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%8F%B2/</guid>
      <description>前后端分离演变史 model1(MVC时代)： 以前一篇博客讲了为了开发开发复杂度，后端开发从model2(MVC)逐渐演变了很多基于MVC的后端框架，例如SSH，SSM **优点：**MVC是一个很好的协作模式，能后有效降低代码的耦合度，从架构上能让开发者明白代码应该写在哪里。为了让View试图层更加存粹，还可以将JSP替换为Thymeleaf，Freemarker等模板引擎，使模板里无法写入java代码，让前后端分工更加清晰 缺点： 前端开发重度依赖开发环境，开发效率低。这种架构下，前后端协作主要有两种模式： 前端写Demo，写好后，让后端去套模板。好处是Demo可以本地开发，很高效。不足时需要后端套模板，套完后还需要前端人员确定，来回沟通调整的成本很大。 另一种协作模式是前端负责浏览器端的所有开发和服务器端的View层模板开发。好处是UI相关的代码都是前端去写就好了，后端不用管前端的数据。不足就是前端开发重度绑定开发环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清，模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写入不少业务代码。还有个很大的灰色地带是Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现的。Controller和Model往往也会纠缠不清，看了让人咬牙的业务逻辑代码经常会出现在Controller层，这些问题不能全纠结于程序员的素养，否则JSP就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用【Comet】，【BigPipe】等技术来优化性能 基于AJAX的SPA时代 使用CDN作为静态资源存储，JavaScript网站归来，Single Page Application
优点：前后端分工清晰，关键是AJAX接口。复杂度从基于服务器引擎的JSP转移到了基于浏览器引擎的JavaScript。这个时代出现了类似后端MVC模式的分层架构
缺点：前后端接口的约定。需要通过接口规则和接口平台等方式来实现前后端的搞笑并行并发。前端由于JavaScript可能出现大量JS代码的组织。
大前端MV*时代 MVC：同步通信：View，Controller，Model MVP：异步通信：View，Presenter，Model MVVM：异步通信：View，ViewModel，Model 为了降低前端开发的复杂度，涌现了大量前端框架：AngularJS，React，Vue.js，EmberJS等，这些框架按类型分为：Templates，Controllers，Models三层，然后在层能分层
优点： 前后端职责很清晰：前端工作在浏览器端，后端工作在服务器端，开发并行。前后端独立开发，独立运行，甚至独立部署上线。 前端开发的复杂度可控：前端代码很重，很合理的分层，让前端代码能各司其职。 缺点： 代码不能复用，例如后端依旧需要对数据各种校验，无法直接复用浏览器端的代码 全异步，对SEO不利，往往还需要服务器端做同步渲染的降级方式 性能并非最佳，特别是移动互联网下 SPA不能满足所有需求，依旧存在大量多页面应用。URL Design需要后端配合，前端无法完全掌握。 NodeJS带来的全栈时代 前端的MVC模式解决了很多问题，但是也有很多不足。随着NodeJS的兴起，JavaScript开始有能力运行在服务端。这意味着可以有一种全新的研发模式。
在这种研发模式下，前后端职责很清晰了。
对前端来说，两个UI层各司其职：
Front-end UI layer：处理浏览器层的展现逻辑，通过CSS渲染样式，通过Javascript添加交互式功能。 Back-end UI layer：处理路由，模板，数据获取，Cookie等。通过路由，前端终于可以自主把控URL Design了。这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以拜托对崭新啊的强关注，转而可以专心业务逻辑层的开发。 通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。
与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。
基于 Node 的全栈模式，依旧面临很多挑战：
需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。 Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效， 过 SOAP 等方式通信更高效。一切需要在验证中前行。 对部署、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 总结 模式没有好坏高下之分，只有合不合适。 Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。 SoC（关注度分离：关注点分离是日常生活和生产中广泛使用的解决复杂问题的一种系统思维方法。大体思路是,先将复杂问题做合理的分解,再分别仔细研究问题的不同侧面(关注点)，最后综合各方面的结果，合成整体的解决方案。） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。 还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。 </description>
    </item>
    
    <item>
      <title>java-JVM</title>
      <link>114.116.115.171/post/java-jvm/</link>
      <pubDate>Sat, 02 Jan 2021 15:59:28 +0000</pubDate>
      
      <guid>114.116.115.171/post/java-jvm/</guid>
      <description>JVM重点问题
JVM位置 JVM体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 三种JVM 栈 堆 新生区，老年区 永久区 堆内存调优 GC机制（常用算法） JMM 单点登录（SSO） JVM位置 JVM体系结构（JVM内存模型） jvm内存模型主要分为5个部分，是java在运行时，jvm虚拟机拿到了自己能支配的内存之后，将内存进行了割分
栈：存储函数运行中的一些引用类型的变量&amp;amp;基础类型变量 堆：存储对象，被栈中的引用类型变量所指向 本地方法栈：存储C++的native方法运行时的栈区 java中有两种方法：java方法和本地方法 java方法由java语言编写，编译为class文件，运行时放在jvm中 本地方法由其他语言编写，编译成和处理器相关的机器代码，本地方法保存在动态链接库中，在windows系统中就是.dll文件中，各个平台都有自己独有的 程序计数器：指向程序当前运行的位置 方法区：存储元数据信息。static，cloader等 类加载器 .class文件经过类加载器，初始化，在方法中形成一个Class类型的对象用来做实例化操作
类加载器分类：（层次从低到高）
应用程序加载器：AppClassLoader：记载自定义的类 扩展加载器：ExtClassCloader：加载java扩展库中的类 引导类(根)加载器：由C++实现，加载java核心库rt.jar，创建扩展类加载器和应用程序类加载器 虚拟机自带的加载器： 双亲委派机制 目的：为了保证安全，重点理解委派 双亲委派机制原理：类加载器收到类加载请求——》一直向上(父类)委托，直到根加载器——》引导类加载器检查是否能加载当前这个类——》能加载就是用当前加载器，否则就通知子加载器进行加载——》重复上个步骤知道将类进行加载 如果最终都没有找到的话，那么会报异常：Class Not Found 用一个classLoader一直重复getCloader，如果出现了null的情况，那么有两种情况：要么不存在，要么就是C++写的native方法(java无法获取到) APP——》EXT——》BOOT（最终执行） 沙箱安全机制 沙箱机制就是一个限制程序运行的环境，通过设置相应的权限。
组成沙箱的基本组件：
字节码校验器：确保java类文件遵循java语言规范，帮助java实现内存保护。核心类不会经过字节码校验。
类加载器：
在3个方面对java沙箱起作用
防止恶意代码干涉善意代码，例如双亲委派（自定义String类根本不会生效） 守护被信任的类库边界 将代码归入保护域，确定了代码可以进行哪些操作（例如自己的代码调不了C++的库） JVM为不同的类加载器载入的类提供不同的命名空间
包含哪些关于沙箱机制类：
存取控制器（access controller） 安全管理器（security manager） 安全软件包（security package） Native关键字 凡是带了native关键字的方法，这个方法会调用C库 带native关键字的方法在执行时会进入本地方法栈，然后调用本地方法接口JNI JNI作用：扩展java的使用，融合不同编程语言为java所用。最初融合的是java诞生时如日中天的C和C++ PC寄存器 Program Counter Register 线程私有 就是一个指针，指向方法区中的方法字节码（用来存储指向一条即将要执行的指令的地址），在执行引擎读取下一条指令。 如果执行的是一个native方法，计数器是空的 方法区 Method Area 所有线程共有：所有字段，方法字节码，构造函数，接口代码 静态变量static，常量final，类信息Class模板(构造方法，接口定义)，运行时的常量池fianl Pool也存在内存中。 实例变量存在堆内存中 栈 先进后出，后进先出</description>
    </item>
    
    <item>
      <title>一点想法-2021-01-01</title>
      <link>114.116.115.171/post/%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95-2021-01-01/</link>
      <pubDate>Fri, 01 Jan 2021 10:59:31 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95-2021-01-01/</guid>
      <description>这学期期末，连续做了三个小项目，最后一个实习最后，叫写个3000字的总结，没啥写的。就扯了了点自己学java这么久以来的感悟。想想也放在博客上吧，随便谈谈。
我之前做过的所有项目的前台静态页面都是用纯css，html，javascript或者jquery自己写的，这样可以锻炼自己对前端三件套的掌握程度。但是这次我们采用了一个后台管理的前端模板adminlte，类似的模板有很多，选择它的原因是有很详细的中文说明。对于大多数的后台管理系统的前台来说，它提供的已足够充足，只需要根据需要选择相应的控件就行了，如果整个项目都是后端程序员开发，大大简化了后端程序员的负担。
对于SSM框架来说，我还是很有感触，我的javaweb之路是一步一步学来的，对javaweb的发展史还是有一定的了解。从最初的servelet，不管页面要显示什么内容，都需要servlet中打印语句到浏览器页面显示，对于servlet中冗长的out语句，简直是噩梦。到后来，借鉴asp的形式，诞生了jsp，这种技术可以在html语句中直接写java代码，如果说servlet是在java代码中写标签，jsp就是在标签中写java代码，这个时候，要完成一个简单的页面，只需要一个几个jsp页面就可以实现了，看似简单，但是随着互联网的迅速发展，当web项目越做越大时，对于庞大代码的首要任务是如何去维护它，如何去践行高内聚低耦合等程序设计原则。然后就是出现了javabean类，将jsp中的部分java代码剥离出来放到专门的java类中达到解耦的目的，此时可以看作MVC的雏形，jsp是表示层，控制层，javabean是模型层，这就是model1开发模式。之后，又将jsp中的控制层单独剥离出来，让servlet来充当，这样，就是大名鼎鼎的model2开发模式即MVC模式的诞生。再然后，就是各种后端java框架的出现了，从Struts2+Spring+Hibernate的SSH，到SpringMVC+Spring+Mybatis的SSM，实际上还是MVC模式，只不过更加人性化，简化了原始的JSP+Servlet+JavaBean的开发模式。需要注意的是，这里的对应关系是JSP是表示层，Servlet是控制层，JavaBean是模型层。但是对于SSH和SSM框架来说，每一个框架对应的是三层模型，分别是Controller层，Service层，Dao层。控制层还是那个控制层，Service层和Dao层都属于模型层。所以，完整的技术栈应该是：JSP+SpringMVC+Spring+Mybatis。这里的逻辑关系很容易混淆，特别是对于新手，很容易把MVC和三层架构搞混。这里理解清晰对与整个后端知识的学习可以说是很重要的。理解一项技术的历史发展我认为对于一个技术学习者来说是很重要的，一个增加专业素养，二是增加学习兴趣，三是能知道自己究竟在学什么，能更加清晰地认识到这项技术在历史中地位，对自己对于新技术的判定页会有很大帮助。
当然，我目前只学到了SSM框架这个地方，SpringBoot和实现分布式部署的SpringCloud作为javaweb系统技术的最前沿，也是目前各大互联网公司的必备技术。这些我都没写开始学习。我认为java发展至今，每个时间都会产生各种新的技术，如果我们一味地追求新技术是没有任何意义的。这里我并不是说新技术不好，我的意思是无论多么高深的技术，都是基于最基础的java语法，java基本特性，例如：发射，注解，多线程机制。现在我发现很多程序员对于这些基础知识并没有弄清楚，但是对新技术趋之若鹜。例如就拿SpringBoot来说，它的很多技术点都是基于SSM的，对于SSM来说，他就是原始MVC模型的进一步简化，原理几乎一致。对于MVC，又可以追述到JSP和Servlet的最原始时代，这又回到了我上面讲的了解一项技术的历史的重要性问题上。当你了解了他的历史，你就会看透这项技术的实质是什么，只要理解技术的核心原理，不管这项技术怎么变你都会认识它。所以我的建议就是对于我们这种初出茅庐的新手来说，最重要的事应该是把个更多的时间花在夯实基础上，而不是追逐新技术上。
记得刚进大一时，那时对于编程来说，认识就是C语言的控制台小黑窗。大二大三也是诸如数据结构，操作系统，计算机组成原理，计算机网络，面向对象设计，设计模式等理论课，我很不明白为什么学校教的都是这些枯燥乏味的理论课呢，稍微讲一些实践课还都是些老掉牙的东西呢，为什么不直接教最新的东西呢，当时的我确实很是困惑。在大三开始，我逐渐开始对javaweb有了兴趣，从java基础开始到javaEE，到SSH，经过这么长时间学习体会，一直到现在的SSM，我终于才有了认识：一个牢固的地基太重要了。所以，从大三开始，我开始补自己欠下的基础债，学的过程中也很是感叹。其实反过来想想：学习一个东西可以先掌握其实践方法，认识到基础知识的重要，再回来学习理论其实也是不错的方法。有交流的学弟学妹，我也会给他们提醒到这一点，不要忽视大学中看似乏味的理论课，这些东西才是日后决定你技术高度的标尺。
接下来一段时间主要复习javase基础，重新学习设计模式，数据结构，操作系统，计算机组成原理，SSM框架深层次理解包括源码理解。这些东西每一个都不是善茬，任重而道远。但话说回来，程序员的一生就是不断学习的一生，对知识的渴望就是一种软实力。对于未来职业方向，暂定方向是java后端开发，我个人对Linux和计算机网络也挺感兴趣，未来也可以有多改变，当然这一切都不是空口说说就行。其实写博客也是一个很好的习惯，一来可以起到类似于日记记录生活的作用，二来可以提交自己学习的欲望，同时加深自己对于知识的理解和记忆程度。一定要在之后的工作中养成写博客的习惯。本次实习我认为很成功，虽然遇到了疫情，但是丝毫不影响，继续努力吧！</description>
    </item>
    
    <item>
      <title>到底啥是VPN</title>
      <link>114.116.115.171/post/%E5%88%B0%E5%BA%95%E5%95%A5%E6%98%AFvpn/</link>
      <pubDate>Tue, 29 Dec 2020 10:51:17 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%88%B0%E5%BA%95%E5%95%A5%E6%98%AFvpn/</guid>
      <description>什么是VPN？ 对于出差的员工，公司的IT部门会在他们的电脑上装上VPN软件。这个VPN软件可以连接到一台由公司内部控制的电脑服务器上，叫“VPN服务器”（VPN Server）。出差员工连上VPN以后，他上网时就不再直接访问公共互联网，而是通过VPN服务器间接访问。本质上是正向代理。
VPN还有一个重要特点：VPN用户和VPN服务器之间的通讯是加密的，这样就不会被黑客盗取内容。这就好比两个人打电话，是有可能被第三方监听的，但是如果打电话的两个人使用的是别人都听不懂的特殊语言（这就是加密），那么即使有人监听，打电话的内容也不会被泄露。
VPN有什么用： VPN可以提高上网的安全性 因为使用VPN时所用的网络访问都是加密进行的，所以使用VPN上网，安全性就更高，黑客很难截取用户的重要信息。如果你使用公共WIFI上网（例如在咖啡馆上网）时，需要做安全性强的操作（比如使用网上银行或网上投资账户），那么建议你连上VPN，因为这样会大大提高安全性。
VPN可以隐藏上网者的身份 因为VPN用户访问任何网站都是通过VPN服务器间接访问的，所以被访问的网站看到的访问者是VPN服务器，而不是VPN用户本人的电脑，这样VPN用户就能对要访问的网站隐藏自己的真正身份。
VPN可以突破网站的地域限制 很多网站都有地域限制，比如视频网站Netflix在不同国家提供不同的内容，美国用户访问Netflix时看到的是美国版的内容，香港用户看到的是香港版的内容。网站的这种功能是通过查看访问者的IP地址属于哪个国家来实现的。而VPN可以用来突破这种IP限制。比如：香港的用户想要看到美国版Netflix的内容，可以先连接到一台位于美国的VPN服务器。这样Netflix网站就会以为访问着来自美国，而提供美国版的内容。同理，使用日本VPN可以以日本用户的身份访问日本网站和服务，使用香港VPN可以以香港用户的身份上网。基于同样的道理，海外华人可以通过VPN翻墙回国，观看仅限国内用户观看的视频内容。另外，VPN还可以用来在网上购物时省钱，因为一些酒店和机票网站对不同国家有不同的价格，通过VPN换成不同国家的IP往往可以省钱。
突破网络封锁（翻墙） 为什么VPN可以用来翻墙呢？先让我们看看网站是如何被墙的。当用户在中国大陆直接访问被封网站（比如Google）时，网络监控发现你要连接到被墙网站，直接就把你拦截了。而如果你通过VPN访问这个网站，我们前面提到，VPN用户访问任何网站都是通过VPN服务器代为访问的，用户连接的其实是VPN服务器，而不是Google（只是告诉VPN服务器你要访问Google），然后VPN服务器去连接Google，把Google的内容回传给你。这样的话，网络监控看到的是你在连接VPN服务器，而不是在连接Google，同时因为VPN传输是加密的，网络监控也无法破解你和VPN服务器之间在传输什么信息，所以，（除非VPN服务器也在被墙网址之内）网络监控就不会切断你的连接，于是你就成功翻墙了。
一点感悟：离开学校会发现没法访问校园网了，我原来认为是校园局域网，然后在家里用VPN通过内网穿透来访问，但是在家里能通过学校的VPN服务器连接校园网进行访问。所以我现在觉得校园网只是出于安全考虑根据你的网络ip地址设置的防火墙。只能通过校园网或者学校的VPN专用服务器进行VPN正向代理访问。不过从目的来看好像确实穿透了内网
关于校园网VPN，我的最新理解：在用户端使用VPN功能的软件，配置为隧道开通器，通过ISP接入Internet并访问校园网内的VPN服务器。到这一步和一般的正向代理都没有差别，让外部机器和VPN正向代理服务器处于了同一局域网。不同的地方在于，这个VPN服务器本身就位于服务终端的内部局域网中，所以此时所有主机（外部访问终端，内部服务终端，VPN服务器）都在一个虚拟的大局域网中了。</description>
    </item>
    
    <item>
      <title>AJAX局部刷新技术</title>
      <link>114.116.115.171/post/ajax%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 28 Dec 2020 20:34:54 +0000</pubDate>
      
      <guid>114.116.115.171/post/ajax%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E6%8A%80%E6%9C%AF/</guid>
      <description>AJAX含义： Asynchromnous JavaScript And XML 异步的Javascript（编程语言）和XML（文件格式） AJAX不是一门新的编程语言，是一个多门已有技术组合后创新产生的新技术 核心点： 核心编程语言是JS 数据交换的工具是XML（现已被JOSN替代） AJAX是一种异步请求方式（和同步请求对立） 同步&amp;amp;异步请求 同步请求： 浏览器发起的传统请求（表单，超链接，地址栏输入地址，location.href） 用户从发起请求开始，到服务器端相应结果完毕，这段时间内不能再操作页面，如果服务端相应结果耗时很长，用户在这段时间内一直等待体验很差。 特点： 一定刷新页面 地址栏一定改变 发起同步请求，会阻塞用户的其他操作 异步请求： AJAX是一种浏览器端的异步请求技术 对于AJAX，服务端响应的不是一个完整页面，而是字符串（页面的数据部分），不会刷新页面 用户在JavaScript发起请求开始，到服务端响应结果完毕，不用等待，用户可以一直操作页面，用户体验好 特点： 不刷新页面 地址栏不改变 异步请求不会阻塞用户的其他操作 原生AJAX操作 AJAX异步请求通用模型 JSON 异步请求下，Server端响应会Client的不是一个完整页面，而是字符串数据，当服务端响应的结果比较复杂时（对象，数组，集合），简单格式的字符串不能满足需求，在传递复杂的数据时，不能使用简单格式的字符串，要使用JSON格式的字符串。
JSON：JavaScript Object Notation，它是JS对象字符串表示形式，定义了对象等复杂数据的特定字符串格式，独立于各个编程语言，是一种轻量级的数据交换格式。
按照java数据类型可分为以下两种JSON字符串转化方式：
普通对象 &amp;amp; Map
数组 &amp;amp; List &amp;amp; Set
Jackson工具的使用 &amp;lt;!-- 引入依赖 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; Student s = new Student(传入参数); ObjectMapper objectMapper = new ObjectMapper(); String studentJson = objectMapper.writeValueAsString(s); System.out.println(studentJson); 属性没有值，可以在对应实体类加上注解，就只会转化非null的数据：
@JsonInlcude(JsonInclude.Include.NON_NULL) 属性名定制，在实体类属性上加注解：</description>
    </item>
    
    <item>
      <title>内网穿透浅析</title>
      <link>114.116.115.171/post/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%B5%85%E6%9E%90/</link>
      <pubDate>Mon, 28 Dec 2020 09:32:58 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%B5%85%E6%9E%90/</guid>
      <description>首先需要明确的是：内网穿透只是目的，不是特指哪一种技术，可以有多种方式来实现通过公网对局域网中的主机的访问。
内网穿透的技术：目前了解的大致分为以下两种
基于client和server，利用公网的一个中间服务器实现流量转发 利用UDP打洞来实现P2P 当然，自己能申请公网ip更好。直接做一个端口映射（常见的端口转发有以下三种模式：手动设计端口转发规则，DMZ，UPNP）利用DDNS动态绑定域名即可。 Tips:其实，我觉得如果从实现目的这个层次去说，VPN的正向代理同样也实现了访问企业/学校内部局域网的目的，所以我觉得这也叫实现了内网穿透（不知道准不准确）
基于C/S架构流量转发实现（传统穿透） 在谈这种方式之前，需要先了解以下计算机网络中的Proxy，既代理。分为正向代理和反向代理
正向代理： 隐藏了真实的请求客户端。服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，最典型的例子就是科学上网工具（访问谷歌被墙，于是在国外搭建一台代理服务器，让代理帮我去请求，代理把请求放回的数据再返回给我。此时，Proxy和Client同属一个LAN，对server透明） 反向代理： 反向代理隐藏里真实的服务端，反向代理服务器会帮我们把请求转发到真实的服务器那里去。最典型的就是Nginx这个性能强大的反向代理服务器（当我们访问百度时，百度在全国分布了上万台服务器，你的每次请求具体是哪台服务器处理你的请求你不用知道，只需要Nginx这个反向代理服务器知道就行了，这实际就是负载均衡的实现原理。此时，Proxy和Server同属于一个LAN，对Client透明） 正向代理： 典型例子就是VPN和shadowsocks等代理上网工具，通过安装工具来让本地机器和代理服务器处于同一局域网 反向代理： 典型例子就是nginx和内网穿透，通过在服务端机器安装工具来让服务端机器和代理服务器处于同一局域网，nginx和内网穿透中的反向代理服务器的区别就是nginx可以根据算法策略自动选择服务终端，而内网穿透反向代理服务器直接通过工具和服务终端机做了ip:端口映射绑定
目前最常用的两个通过公网服务器转发数据实现内网穿透的工具是：frp，ngrok，nat123。远程桌面控制软件TeamViewer也是这样的原理。
具体流程如下：我们需要一个有公网ip的反向代理服务器C，由C代理本地的A主机（但在这个过程中，代理服务器C和本地A没有在一个网段，因此当公网B向代理服务器发送请求时，代理服务器无法连接到处于内网中的主机A。所以就需要上面提到的工具了，需要安装相应的服务或者客户端软件向Proxy主动发出请求并建立连接）。然后从本地A向C握手，建立稳定连接，同时在Proxy上将A的端口映射到公网IP上。之后，一个公网设备B向C发送请求，C通过刚才建立的稳定信道将请求转发给A。A收到请求后将响应发给C，C再将响应返给B。至此，穿透达成。
缺陷就是Proxy最为数据转发的唯一跳板，需要消耗服务器带宽和流量，内网穿透过程中的带宽上行取决于中间反向代理服务器。
利用UDP打洞实现P2P的访问（点对点穿透） 简单说就是：用一个公网服务器当介绍人，直接连接两个不同局域网中的主机，来实现通讯，建立连接后把公网服务器关了，两个不同局域网中的机器依旧可以通信。
要弄清楚UDP打洞（NAT打洞）原理，必须先搞清楚NAT的4种类型
先来看个例子：公网上有两个server，ip和端口分别如图。内网中的NAT网关的ip是3.3.3.3，NAT内部需要穿透的电脑的ip如图。此时，192.168.0.2电脑A，已经和NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了连接
以下四种方式从上至下的要求愈发严格：
完全锥形NAT 如上，当A和server1的一条通信连接建立时，其他的所有server，例如server2也可以通过路由上的3.3.3.3:200来访问电脑A
ip限制型锥形NAT 当A和server1的一条通信连接建立时，其他的server，例如server2不能通过路由上的3.3.3.3:200来访问电脑A，只能是此时正在正在连接当中的server1的ip才能访问电脑A，但是堆server1中的不同端口号并不限制
端口限制型锥形NAT 当A和server1的一条通信连接建立时，其他的server，例如server2不能通过路由上的3.3.3.3:200来访问电脑A，只能是此时正在正在连接当中的server1的ip+端口才能访问电脑A
对称NAT 当A和server1的一条通信连接建立时，在完全满足端口映射锥形NAT的基础上，如果此时电脑A还需要建立和其他server建立连接，比如server2，那么此时不能重复利用3.3.3.3:200，只能重新在路由器上开通一个端口号。
UDP打洞中不同NAT的组合方式 上述介绍四种NAT的类型对其进行两两组合，总共有10中不同的组合方式，不同的组合方式在进行穿透时的方法也不同，有两种情况的组合无法穿透（也有一些骚操作可以让这两种的组合实现内网穿透，但是由于NAT设计之初就没有考虑到这两种的组合情况，所以理论上他们也是不能穿透的）
两种内网穿透方式的比较 打洞：Zerotier，Frp（初级），smargate 转发：花生壳，ngrok，Frp </description>
    </item>
    
    <item>
      <title>Java-GC机制</title>
      <link>114.116.115.171/post/java-gc%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 21 Dec 2020 09:55:07 +0000</pubDate>
      
      <guid>114.116.115.171/post/java-gc%E6%9C%BA%E5%88%B6/</guid>
      <description>背景： Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。对于程序员来说，分配对象使用new关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为&amp;quot;不可达的&amp;quot;.GC将负责回收所有&amp;quot;不可达&amp;quot;对象的内存空间。 堆空间是用来存储new出来的对象的，当new出来的对象填充满时，会让堆爆掉，程序就挂了，这显然时不被允许的。 Garbage Collection的机制就是判断堆内存中哪些对象能被删除，判断的标准就是GCRoot GCRoot GCRoot：指向堆中的对象的引用，包含： 栈上的引用直接或者间接地被引用 方法区上全局的的Static变量&amp;amp;常量直接或者间接被引用 本地方法栈上的的C++直接或者间接被引用 那些可以直接存在的，没有和GCRoot有相连的关系的对象可以被删除 GC机制清理堆中垃圾的思路 **标记-清理：**在堆中要删除对象后面打标
缺点：标记和清除两次扫描会严重浪费时间，同时会产生内存碎片 优点：不需要额外空间 **标记-整理：**堆中删除的对象留下的空间能聚集在一起
缺点：代价太大，除了两次扫描还要把所有整理后的对象前移 优点：减少了内存碎片 **复制算法：**将整个内存一分为二，将1区需要删除的标记，然后将没打标记的对象紧凑复制到2区，既避免了内存碎片问题，整个内存开销又不是很大。
缺点：需要两倍内存空间 优点：不会产生碎片问题 最佳使用场景：对象的成活率较低（新生区就是这样） 实际的GC：将堆区划分
新new的对象都会在Eden（伊甸园）出生，当Eden快满的时候会触发young区域的GC，采用复制算法，将Eden中没有标记的对象复制到Survivor0（幸存0）区域
Eden很大，Survivor更小。因为对象都有一个特点：朝生夕死，很容易就夭折了，生死率大概是1：8
需要两块Survivor区交替工作（From和To的反复交替：谁空谁是To）
E+S1 复制到 S0 E+S0 复制到 S1 E+S1 复制到 S0 &amp;hellip;（如此交替工作） 一个对象每幸存1次，其年龄就会+1，如果满了6岁，（满了6岁基本60岁都不会清理了）就不会复制到Survivor区了，就会直接到Old区了
大对象（例：1000万个元素的int数组）会直接存放到Old区。
Old区满了也会触放GC，OldGC一般也会伴随YoungGC，所以，Old区满了会触发FullGC，此时会触发stoptheworld，java程序全部暂停，报错OOM（java.lang.OutOfMemory :Java heap space），全力进行垃圾回收（采用标记清理 or 标记整理算法）
总结：
标记-清理和标记-整理 主要用在 FullGC机制
复制算法只要用在 YoungGC机制 **内存效率(时间复杂度)：**复制算法&amp;gt;标记清除&amp;gt;标记整理
**内存整齐度：**复制算法=标记整理&amp;gt;标记清除 **内存利用率：**标记整理=标记清除&amp;gt;复制算法 没有最好的算法，只有最合适的算法 垃圾收集器：
年轻代：ParNew：复制算法 老年代：CMS：标记-清理 最新版的JDK采用的是：G1垃圾收集器 永久区
该区域常驻内存，用来存放JDK自身携带的Class对象等。存储的是java运行时的一些环境。
该区域不存在垃圾回收，关闭虚拟机就会释放该区域的内存
jdk1.6之前：永久代，常量池在方法区 jdk1.7：永久代慢慢退化了，常量池在堆中 jdk1.8之后：无永久代，整个方法区（包含常量池）都在元空间 JDK8之后的堆内存模型：
这个元空间：逻辑上存在，物理上不存在
堆内存参数调优初识：在IDEA中，VM options中添加几个参数，可以指定最大内存，最小内存，和是否打印GC的详细信息
-Xms8m -Xmx8m -XX:+PrintGCDetails 相关题目 JVM的内存模型和分区~详细到每个区都放什么？ 堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点？ GC的算法有哪些：标记清除法，标记整理，引用计数法 轻GC和中GC分别在什么时候发生？ #定义对象进入老年区的时间，默认是15 -XX:MaxTenuringThreshold=15 </description>
    </item>
    
    <item>
      <title>java基础快速回顾-上</title>
      <link>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/</link>
      <pubDate>Sat, 19 Dec 2020 15:08:49 +0000</pubDate>
      
      <guid>114.116.115.171/post/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/</guid>
      <description>java语言开发环境搭建 java虚拟机——JVM 实质就是翻译，把.class文件翻译成计算机能认识的机器语言 java所谓的跨平台指的是java程序跨平台。JVM不是跨平台的，各个平台（Windows，Linux，mac）的JVM是不同的。 Java这个语言很非凡。 一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。 二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 JRE和JDK JRE：java Runtime Environment，包含JVM和运行时需要的核心类库 JDK：java Development Kit，是java程序开发工具包，包含JRE和开发人员使用的工具 想要运行一个已有的java程序，那么只需安装JRE即可；想要开发一个全新的java程序，那么必须安装JDK 配置JDK环境变量 在全局系统变量中2个操作 新建JAVA_HOME变量：（jdk的安装路径） 修改Path：添加%JAVA_HOME%\bin HelloWorld入门程序 程序开发步骤 java程序开发三步骤：编写——》.java——》编译（编译器javac.exe）——》.class——》运行（JVM解释执行：java.exe） 新建文件名为HelloWorld的java文件，编辑： public class HelloWorld{//public的类名必须和文件名完全一致 public static void main(String[] args){ System.out.println(&amp;#34;Hello,world!&amp;#34;); } } //编译 javac HelloWorld.java //JVM解释执行 java HelloWorld HelloWorld程序说明 单行注释，多行注释： //单行注释 /*多行注释*/ public static void main(String[] args)是程序入口 关键字说明：java中有特殊含义的保留字 标识符： 指的是在程序中，我们自定义的内容中，如类的名字，方法的名字，变量的名字等都是标识符， 命名规则（硬性要求） 标识符可以包含：英文字符，数字，$符，_下划线 标识符不能以数字开头 标识符不能是关键字 命名规范（软性要求） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式） 变量名规范：首字符小写，后面每个单词首字母小写（小驼峰式） 方法名规范：同变量名 常量 概念：在程序运行期间固定不变的量 分类： 字符串常量：双引号引起来的 整数常量：直接写上的数字，没有小数点 浮点数常量：直接写上的数字，有小数点 字符常量：单引号引起来的单个字符，有且仅有一个字符 布尔常量：true或者false 空常量：null，代表没有任何数据 数据类型 引用数据类型 字符串，数组，类，接口，Lambda等 基本数据类型 整数型：byte，short，int，long 浮点型：float，double 字符型：char 布尔型：boolean 注意事项：</description>
    </item>
    
    <item>
      <title>java-反射</title>
      <link>114.116.115.171/post/java-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 19 Dec 2020 12:56:10 +0000</pubDate>
      
      <guid>114.116.115.171/post/java-%E5%8F%8D%E5%B0%84/</guid>
      <description>静态语言（强类型语言） 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#等。
动态语言（弱类型语言） 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。
强类型定义语言 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
弱类型定义语言 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
什么是反射（反射机制） Java时静态语言，通过反射，Java成为了准动态语言
反射禁止允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。
Class c = Class.forName(&amp;#34;java.lang.String&amp;#34;) 这个存在内存中的Class类型的对象就是一面镜子，我们通过镜子的反射能看到类的结构。
反射机制的功能：
在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射的优点和缺点：
可以实现动态创建对象和编译，很灵活 对性能有影响，反射基本上是一种解释操作 理解Class类并获取Class实例 发射相关的主要API
java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 例子：
class User{ private String name; private int id; private itn age; public User(){} public User(String name,int id,int age){ this.name = name; this.id = id; this.age = age; } //省略get,set方法，toString()方法 } public class Test{ public static void main(String[] args){ Class c1 = Class.</description>
    </item>
    
    <item>
      <title>java-注解</title>
      <link>114.116.115.171/post/java-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Sat, 19 Dec 2020 12:55:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/java-%E6%B3%A8%E8%A7%A3/</guid>
      <description>什么是注解 可以被其他程序读取 可以附加在package,class,method,field上都可以添加注解 可通过反射实现对注解中信息的访问 注解是jdk1.5后的新特性 注解作用 编写文档：通过代码里标识的注解生成doc文档 代码分析：通过代码里标识的注解堆代码进行分析（结合反射） 编译检查：通过代码里标识的注解让编译器能实现基本的编译检查（@Override） 内置注解 @Override：必须重写父类的方法 @Deprecated：已过时的，不推荐使用，存在更好的方式 @SuppressWarning：镇压警告 元注解 负责解释其他注解的注解：Java定义了4个标准的meta-annotation类型，以供其他的annotation类型做说明 @target：描述注解使用范围 @Retention：描述什么级别保存该注释信息，用于描述注解的生命周期(SOURCE&amp;lt;CLASS&amp;lt;RUNTIME) @Documented：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 @Target(value={ElementType.METHOD,ElementType.TYPE}) @Retention(value=RetentionPolicy=RUNTIME) @Documented @Inherited @interface MyAnnotation(){ } 自定义注解 @interface用来声明一个注解 注解体中的每一个方法实际就是一个配置参数，方法名就是参数名，返回值类型就是参数的类型（返回值只能是Class,String,enum） 可以通过default来声明参数的默认值 只有一个参数，参数名是value，赋值时可省略参数名 注解元素必须要有值，我们定义注解元素时，经常使用空字符串0作为默认值 public class Test{ //注解可以显式赋值，如果没有默认值必须给注解赋值 @MyAnnotation(name = &amp;#34;JackYang&amp;#34;,school={&amp;#34;西部开源&amp;#34;,&amp;#34;清华大学&amp;#34;}) public void test(){} } @Target(value={ElementType.METHOD,ElementType.TYPE}) @Retention(value=RetentionPolicy=RUNTIME) @interface MyAnnotation(){ //注解的参数：参数类型+参数名 String name() default &amp;#34;&amp;#34;; int age() default 0; int id() default -1;//默认值是-1代表不存在 String[] school(); } </description>
    </item>
    
    <item>
      <title>初试刷机</title>
      <link>114.116.115.171/post/%E5%88%9D%E8%AF%95%E5%88%B7%E6%9C%BA/</link>
      <pubDate>Sat, 05 Dec 2020 22:14:42 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%88%9D%E8%AF%95%E5%88%B7%E6%9C%BA/</guid>
      <description>
解BL锁 首先需要确保MIUI处于开发版最新版 连续点击全部参数里的MIUI版本将设备处于开发者模式 退出系统中所有登录的账号（小米账号，谷歌账号&amp;hellip;&amp;hellip;） 关机后打开fastboot模式（同时按电源键&amp;amp;音量下键） 向小米官方申请解锁并在电脑上下载miflash解锁工具 电脑usb连接手机，点击解锁，会显示成功。 备份数据 在刷新的rec和新系统之前如果需要备份原系统的数据，可以用小米助手（MiAssistant）来备份数据，官方可下载。 刷入第三方REC 可选的第三方REC很多（TWRP，橙狐，奇兔） 根据选择的REC不同，刷入REC的方式也不同，这里以TWRP为例： 在各种论坛自己找到自己设备（小米平板4）的TWRP刷入工具包，按照规则傻瓜式操作即可操作成功，成功后系统自动启动进入REC 刷入系统&amp;amp;面具&amp;amp;谷歌套件 可以选择各种适配自己设备的系统，以魔趣为例： 登录魔趣官网https://download.mokeedev.com/，根据设备型号选择下载系统包（稳定版&amp;amp;每夜版） 在论坛寻找下载magisk面具zip包 在https://opengapps.org/下载谷歌套件zip包 之前的三个包可以在电脑下载 设备关机并进入REC（同时按电源键&amp;amp;音量上键） 清理data分区和四清，重启进入REC 从电脑拷入三个zip包进入设备根目录 点击安装，选择系统zip包刷入 继续刷入magisk包，成功后重启进入系统 此时基本就可以了，系统基本配置好后就可以关机再次进入REC，刷入谷歌套件zip包，重启即可 注意： 谷歌套件如果只需要谷歌服务的话，推荐用nano版本的，其他版本会有其他不必要的东西 经常出现这种情况：再次进入REC时会让输入data密码确认，否则访问不了data目录，此时可能有两种情况： 系统设置了开机密码，此密码就是开机密码 设备没开机密码，但是还是要输入data密码，此时就没辙了，除了清理data毫无他法。这里的问题就是TWRP包本身的问题，这里最好就多换几个TWRP包试一试，有些包自带data解密的，或者寻找一个data解密文件来解密 推荐魔趣稳定版本，每夜版每天都会更新，非常不稳定，可能会出现各种各样的问题。 </description>
    </item>
    
    <item>
      <title>计网-无线网络</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sat, 21 Nov 2020 15:08:14 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</guid>
      <description>无线网络的比较
PAN：蓝牙 LAN：WiFi MAN：WiMAX WAN：2G，3G，4G，5G 以无线AP（无线交换机）为中心的无线局域网
最原始的单计算机拨号上网：
要实现一个局域网网段的多计算机同时上网，加入一个无线路由器来实现：
通常所说的所谓“无线路由器”实际上是一个三合一设备：路由器功能+交换机功能+无线AP功能
左边教室的所有机器按照上述能上网，右边教师的也想并入左边的网段上网，只需要把右边的无线路由器当作一个路由器来使就行了，拿一根网线把两个交换机连接起来，同时右边的无线设备也可以通过以无线AP为中心的无线局域网并入左边教室的网段。
还有一种无线网络是不需要无线AP接入设备的：临时的无线网络
手机通过3G,4G,5G来上网的原理：
手机打电话的方式：从最近的基站注册然后发出通信，基站之间通过光纤或者其他线连接。手机移动位置的时候需要连接新的基站，然后就会更新基站数据库 上网就是通过基站的光纤连接的网关来访问Internet，2G,3G,4G,5G，一代比一代的带宽高 </description>
    </item>
    
    <item>
      <title>计网-音频服务</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E9%9F%B3%E9%A2%91%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 21 Nov 2020 15:08:03 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E9%9F%B3%E9%A2%91%E6%9C%8D%E5%8A%A1/</guid>
      <description>在Internet上传输音频视频面临的问题？
音频视频：占用的带宽高，网速需要恒定，延迟要低（尤其是交互性的） 数据信息：对带宽，网速是否恒定，有延迟要求不高 延迟：对需要实时交互的音视频影响大。
网速是否稳定：对非交互式的音视频也有很大影响，可以通过在客户端设置缓存来实现
目前因特网提供的音视频服务的三种类型：
流式存储音视频——边下载边播放 只能在线播放，有利于保护版权 节省客户端硬盘空间 流式实况音视频——边录制边播放 通过网络现场直播 交互式音视频——实时交互式通信 视频/音频聊天 一般的流媒体服务器中存放了所有音视频，通过一个web站点调用这些流媒体，一般顾客通过访问这些web站点就可以访问到流媒体了。
利用流媒体服务器实现现场直播：
就近选择流媒体服务器，让就近的流媒体服务器从远处编码器要数据，然后再分发给每台计算机，这样可以极大节省带宽
IP电话
传统电话是用电路交换实现面向连接的通信
IP电话是利用分组交换通过互联网实现通信（交换式音视频），长途电话可以利用语音网关
改进的“尽最大努力交付”：分组标记，路由器加分类，流量管制，路由器调度，呼叫接纳</description>
    </item>
    
    <item>
      <title>计网-网络安全</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</link>
      <pubDate>Sat, 21 Nov 2020 15:07:48 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</guid>
      <description>网络安全问题概述 网络安全面临的4种威胁 截获（被动式攻击）：窃听他人通信内容 中断（主动式攻击）：中断他人的网络通信 篡改（主动式攻击）：故意修改网络上传送的报文 伪造（主动式攻击）：伪造信息在网络上传送 Cain工具：捕获同一网段中用户输入的账号密码；篡改域名解析结果
通过arp欺骗实现（应对方法就是在自己的计算机上安装arp防火墙，但是如果交换机能监视，cain能直接从交换机拿数据，自己机器上的arp防火墙就没用了） **DNS欺骗（篡改DNS解析结果）**的实例：钓鱼网站：你输入工商银行的域名，经由篡改服务机到DNS服务器得到正确的ip地址，回来先到篡改服务机，会把正确的ip改为一个和工商银行界面相似的钓鱼网站的ip，然后你进入钓鱼网站输入工商银行的域名，钓鱼网站就把你的账号密码拿到了。
**伪造：**一个服务器只允许某几台计算机能访问，这时一台范围外的计算机伪造自己的ip为其中一台有访问权限的ip来访问目标服务器，前提是那一台计算机没有运行，否则会出现ip冲突。
**中断：**Dos攻击和DDos攻击
计算机面临的威胁（恶意程序） 计算机病毒：熊猫烧香
能传染，通过修改其他程序来吧自身或者变种复制进入完成的
计算机蠕虫：一般是消耗系统资源，不一定更改系统的设置
通过网络的通信功能将自身从一个节点发送到另一个节点并启动运行的程序
特洛伊木马：盗号木马，灰鸽子远程控制木马，特点是需要和外界通信
一种程序，执行的功能超出其所声称的功能
逻辑炸弹：定时错误
一种当运行环境满足某种特定条件时执行其他特殊功能的程序
如何养病毒：需要把病毒文件加密，否则杀毒软件会清除掉这些文件。
两类密码体制 对称加密： 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。
常见的对称加密算法：DES（分组加密后在解密合并），AES，3DES等等。
缺点：
密钥不能在网上传，只能本地保存，否则不安全
密钥要两个人一对，密钥维护相当麻烦
优点：
加密效率高 非对称加密： 非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。 常见的非对称加密算法：RSA，ECC 公钥可以随便传，私钥需要本地保管。 非对称加密单独使用效率不如对称加密，所以实际过程中的使用方法往往是非对称和对称的融合：用对称加密加密传输内容，用非对称公钥加密加密对称加密的密钥，把这两部分一起发给接收方。接收方先通过非对称加密的私钥解密得到对称加密的密钥，用这个密钥再去解密得到传输内容。 对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用.
数字签名 数字签名是非对称加密的一个实际应用
作用：防止抵赖，能够检查签名之后内容是否被更改
目的不是为了保密，而是确保传输的文件没有被更改而且发送方无法狡辩说不是我发的（例如：中央红头文件发到地方政府）
图示：
注意观察上面的过程，有个细节问题：接收方如何确认解密的公钥是发送方发的。此时就需要第三方的证书颁发机构CA
因特网使用的安全协议 安全套接字层SSL 在应用层和传输层之间加入一个SSL加密层
在发送方，SSL接收应用层的数据，对数据进行加密，然后把加密的数据送往TCP套接字
在接收方，SSL从SSL套接字读取数据，解密后把数据交给应用层
例如：访问web时，不使用安全套接字的协议是http（80端口），使用了安全套接字的协议是https（443端口）
实现SSL需要的配置：也是用非对称密钥加密对称密钥来解决的（上面有介绍）
几个可以加上SSL层的应用层协议：
IMAPS tcp-993 POP3 tcp-995 SMTPS tcp-465 HTTPS tcp-443 其实SSL层可是实现如下三个功能
加密SSL会话：（上面介绍的） SSL服务器鉴别：允许用户证实服务器身份 SSL客户鉴别：允许服务器证实用户身份 网络层安全协议IPSec 网络安全是分层的：
数字签名/数字加密：属于应用层安全，需要应用服务的支持加密解密 SSL层：位于应用层和传输层之间，不需要应用程序的支持，但是需要配置证书才能实现SSL层安全 IPSec：位于网络层(属于底层加密)，不需要应用程序的支持，也不需要配置任何证书，时自动加密的，对上层透明。 使用IPSec建立通信之前，两个节点之间需要建立一个SA安全关联
IPSec中的两个协议AH和ESP
AH：只数字签名 ESP：既要签名又要加密 链路加密与端到端加密 数据链路层的安全：每个网段传输数据加密解密</description>
    </item>
    
    <item>
      <title>计网-应用层</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/</link>
      <pubDate>Sat, 21 Nov 2020 15:07:18 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
      <description>域名系统DNS QQ客户端能登录，但是QQ网站打不开，可能说明DNS出问题了
域名服务器采用分布式的域名查询解析
我个人认为这里的本机缓存指的是本机的DNS缓存，访问网站的时候是先查询本机缓存，再查询hosts配置，之后才去请求本地DNS缓存。
动态主机配置协议DHCP 静态IP地址：手动配置
一般固定的台式机
动态IP地址：通过DHCP协议自动获得
一般的移动的设备，例如wifi连接的笔记本电脑
计算机通过广播向DHCP服务器发送广播请求，DHCP服务器从地址池里选择一个地址给计算机发过去。如果同时有多个DHCP服务器应答，计算机还要选择一个DHCP服务器发一个确认信息，然后DHCP服务器才能把所有设置给计算机。 DHCP服务器要是静态地址，一般只给本网段的计算机分配地址。 了解租期和续约 除了同网段的DHCP分配，还可以跨网段DHCP分配 对比RARP逆向地址解析协议：从功能上说，RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。
文件传送协议FTP 控制连接：标准端口21，用于发送ftp命令信息 数据连接：标准端口22，用于上传下载数据 数据连接的建立类型： 主动模式：ftp客户端告诉ftp服务器使用什么端口侦听，ftp服务器和ftp客户端的这个端口建立连接 被动模式：ftp服务器打开一个端口等待客户端来连接 FTP服务器端如果有防火墙，需要在防火墙上开21和20端口，需要使用主动模式进行连接 远程终端协议TELNET 默认使用TCP 的23端口 远程桌面RDP net user administrator all 更改用户密码 net user han all /add 添加用户 将用户添加到远程桌面组 Remote Desktop Users组 Server多用户操作系统，启用远程桌面可以都用户同时使用服务器 XP和Windows 7是单用户操作系统，不支持多用户同时登录 远程时可以将本地的硬盘资源映射到远程计算机上 万维网WWW 一个网站的标志：可以通过不同端口，不同的IP地址，不同的主机头（域名）来区分； tomcat服务器部署了多个项目，阿里云的域名解析到服务器ip，可以通过配置，让不同域名解析访问不同的项目。 http协议 web代理服务器 节省内网访问Internet的带宽 使用代理服务器连网关，DNS都不需要，只需要和代理的服务器通信就行了，所有访问Internet的工作都是代理服务器做的。 能绕过防火墙直接访问墙外的网站，这是一种正向代理 电子邮件（SMTP，POP3，IMAP） 发送协议：SMTP 接收邮件协议：POP3，IMAP 注意：
DNS占用53号端口，同时使用TCP和UDP协议。DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。
DNS区域传输的时候使用TCP协议：
1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
2.TCP是一种可靠连接，保证了数据的准确性。
域名解析时使用UDP协议：
客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</description>
    </item>
    
    <item>
      <title>计网-运输层</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/</link>
      <pubDate>Sat, 21 Nov 2020 15:07:07 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/</guid>
      <description>传输层两个协议的应用场景：
TCP：基于可靠传输的，丢包重传，分段编号，流量控制，建立会话(三次握手)
QQ传文件，访问网站，下载文件 UDP：基于不可靠传输，一个数据包就能完成数据通信，不建立会话，支持多播
QQ聊天， UDP中IP分片是在IP层完成的， 而TCP分段是在TCP层完成的，TCP在ip层会尽量避免分片
MTU = IP头+【TCP头+(MSS)】
TCP层提前完成了分段， 而且， 两个TCP包中都有TCP头， 这是必然的。 所以到了IP层后， 都保留了TCP头， 当然就有了端口信息啊。 这一点与IP层次的分片是不同的。
​ 而且我们应该看到， 因为TCP包在TCP层已经做了限制， 这就决定了， 等TCP包达到IP层的时候， IP层的数据绝对不会超过MTU, 因此， 对于TCP传输来说， IP层是没有必要分片的， 因为TCP层分段的时候， 已经考虑到了这个限制。
​ 所以， 我们经常会说， UDP传输中， IP分片， 是受到了MTU的限制， TCP传输中， TCP分段， 是受到了MSS的限制（实际上最终还是受到了MTU的限制）
http=TCP+80
https=TCP+443
ftp=TCP+25
SMTP=TCP+25
POP3=TCP+110
RDP=TCP+3389
smb=TCP+445
SQL Server=TCP+1433
MySQL=TCP+3306
DNS=UDP+53 or TCP+53
Telnet=TCP+23
SSH=TCP+22
应用层协议和服务之间的关系：
用ip地址定位计算机，用端口来定位服务，服务本质上是运行在TCP或UDP的某个端口侦听客户端请求的软件
查看自己计算机侦听的端口：netstat -an
测试远程计算机打开的端口：telnet xxx.xxx.xxx.xxx
可以更改服务的端口和只打开必要的端口来增加服务器安全
Windows防火墙安全：
在网卡上加一层过滤器：只允许某些端口的数据进来 防火墙是单向的，只拦截来的，不管出去的，出去的时候自动打开端口，出去了就关了，外面的就不要想进来的。 Windows防火墙程序防不了灰鸽子木马程序
防火墙是严进宽出，灰鸽子利用了这一点，让中木马的计算机灰鸽子客户端主动连到服务端。所以防火墙防不了灰鸽子木马。
解决灰鸽子木马的问题：用IPsec的网络层安全严格控制网络流量
运输层的功能 TCP传送的协议数据的那元是TCP报文段
UDP传送的协议数据单元是UDP报文或者用户数据报
运输层协议UDP和TCP UDP是无连接的，即是发送数据之前不需要建立连接</description>
    </item>
    
    <item>
      <title>计网-网络层</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
      <pubDate>Sat, 21 Nov 2020 15:06:46 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
      <description>网络层提供的两种服务 争论的焦点是可靠交付应当有谁来负责？运输过程中只由运输层来决定，网络层不负责可靠传输，可靠传输应该由端系统决定。
网络层应该向运输层提供怎样的服务？分组交换网提供两种传输服务:
虚电路服务：面向连接的，虚电路表示这只是一条逻辑上的连接，和电路交换的一真正的连接只是类似，但并不完全一样。是一种使所有分组顺序到达目的端的可靠性数据传输服务。 数据报服务：无连接的，网络在发送分组时不需要先建立连接，每一个分组独立发送，与其前后的分组无关。是一种使分组按照独立路由到达目的端的数据传输服务，比虚电路更加灵活。 网际协议IP 虚拟互连网 网络互联的中间设备
物理层中继系统：转发器，集线器 数据链路层终极系统：网桥，交换机 网络层中中继系统：路由器 网络层以上的中继系统：网关 虚拟互连网也就是逻辑互联网络，就是互连起来的各种物理网络的异构性本来就是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络从用户看起来就好像是一个统一的网络。
网络层4个协议
IP协议： ARP/RARP协议： ICMP协议： IGMP协议： IP地址 分层：分网络部分和主机部分
分类：A类（8+24），B类（16+16），C类（24+8），D类（组播），E类（研究）
二进制，十进制
1 1 10 2 100 4 1000 8 10000 16 100000 32 1000000 64 10000000 128 11000000 192 11100000 224 11110000 240 11111000 248 11111100 252 11111110 254 11111111 255 A类 从1.0.0.0 到126.255.255.255 B类 从128.0.0.0到191.255.255.255 C类 从192.0.0.0到223.255.255.255
在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：
A类地址：10.0.0.0～10.255.255.255
B类地址：172.16.0.0～172.31.255.255
C类地址：192.168.0.0～192.168.255.255
注意：网段中主机部分不全为1，不全为0；全0代表这个网段，全1代表网段中的广播
几个特殊ip地址：
0.0.0.0：不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。 255.255.255.255：限制广播地址
244.0.0.1：组播地址
127.0.0.1：本地回环地址
169.254.0.0：一般开启了dhcp服务的设备但又无法获取到dhcp的会随机使用这个网段的ip</description>
    </item>
    
    <item>
      <title>计网-数据链路层</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Sat, 21 Nov 2020 15:06:19 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>数据链路层基本概念及基本问题 基本概念 两种信道类型： 点到点信道 广播信道 链路和数据链路：链路是物理层，数据链路包含物理层和数据链路层 帧：在网络层包的基础上增加头和尾 三个基本问题 封装成帧 在网络层数据报基础上+帧首部&amp;amp;帧尾部，帧的数据部分MTU≤1500Byte 透明传输 用字节填充法解决透明传输问题 差错控制 传输过程中可能会有比特差错（0变1或者1变0），误码率
循环冗余检验CRC（除数由数据链路层协议确定）,通过CRC算法生成FCS帧检验序列
不纠错，有错误直接丢掉（重传不是数据链路层管的事情）
有可能出错也检查不出，CRC不是可靠传输
两场情况下的数据链路层 使用点对点信道的数据链路层（PPP协议） 例子：拨号上网
特点：简单，封装成帧，支持多层网络协议，多种类型链路，差错检验，检测连接状态，最大传送单元，网络层地址协商，数据压缩协商
由三部分组成：
一个将IP数据报封装到串行链路的方法； 一个用来建立、配置和测试数据链路连接的链路控制协议LCP； 一套网络控制协议NCP，其中的每一个协议支持不同的网络层协议 PPP帧格式
解决透明传输：传输比特（零比特填充法），传输字节（字节填充）
PPP协议工作流程
当用户拨号接入ISP后，就建立了一条从用户PC机到ISP的物理连接。 这时用户PC机向ISP发送一系列的LCP分组(封装成多个PPP帧)，以便建立LCP连接。 这些分组及其响应选择了将要使用的一些PPP参数。 接着还要进行网络层配置，NCP给新接入的用户PC机分配一个临时的IP地址。 这样，用户PC机就成为因特网上的一个有IP地址的主机了。 当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。 接着，LCP释放数据链路层连接。 最后释放的是物理层的连接。 PPPoE: 一种建立在以太网上的点到点的隧道技术。以太网本身是基于广播的，无法提供可靠的点到点支持，PPPoE解决了这个问题，在以太网上提供了可靠的点到点连接，可以让运营商验证你的身份并予以计费。
使用广播信道的数据链路层（以太网的CSMA/CS协议） 局域网的拓扑：星形网，总线网，树形网，环形网
共享通信媒体：
静态划分信道：频分/时分/波分/码分复用 动态媒体接入技术：随机接入（以太网），受控接入 多点接入，载波监听
碰撞检测，发现冲突最长时间是2焘
半双工通信
2套=51.2微秒=1争用期=基本退避时间；10Mb/s的以太网争用期发送512bit（64Byte），前64字节没有发现冲突情况，之后也就不会有冲突了。所以10M以太网中最短有效帧为64字节。
退避算法
以太局域网 两个标准：Ethernet V2和802.3
用集线器组以太局域网
以太网信道利用率
MAC层的硬件地址：48位二进制（前24为代表厂家，后24为厂家自己指定）
网卡从网络上每收到一个MAC帧就会用硬件检查MAC帧中的MAC地址，如果是发往本站的帧则收下，其他的丢弃。包括单播帧，广播帧，多播帧 一个局域网不能出现两个相同的mac地址，因为mac可以手动指定自定义的mac地址 帧间最小的间隔时间为9.6微秒，是为了使刚刚收到的数据帧站的接收缓存得以清理，做好接收下一帧的准备 扩展以太网 物理层的扩展
用集线器连网最多不要超过30台机器，否则效率极慢 数据链路层的扩展
网桥：有一个mac记忆表，可存储（来源）转发（目的），可以隔离冲突域
透明网桥：以太网上的站点不知道所发送的帧将经过那几个网桥，是一种即插即用的设备——自学习 源路由网桥：在发送帧时，把最详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。（通过发送 ’ 发现帧 ‘ 来寻找最佳路由信息） 交换机：可以看作多口网桥。基本上每个口直接连一台机器，一台机器一个冲突域，也就是没有冲突了。可以实现全双工。</description>
    </item>
    
    <item>
      <title>计网-物理层</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%89%A9%E7%90%86%E5%B1%82/</link>
      <pubDate>Sat, 21 Nov 2020 15:06:00 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E7%89%A9%E7%90%86%E5%B1%82/</guid>
      <description>物理层的基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 主要任务时确定与传输媒体接口的一些特性 机械特性：接口形状，大小，引脚数量 电气特性：电压范围 功能特性：例如规定-5V表示0，+5V表示1 过程特性：连接时各个部件的工作步骤 数据通信的基础知识 消息：具有意义的数据
数据：运送消息的实体
信号：数据的电气或电磁的表现
模拟信号：消息的参数取值时连续的
数字信号：消息的参数取值是离散的
码元：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度
码元长度：1码元可以携带的nbit信息量
信道：向一个方向传送消息的媒体（一条发送的信道+一条接收的信道）
单工通信：单向高速公路 半双工通信：对讲机 全双工通信：电话 基带信号：来自信源的信号
带通信号：将基带信号经过载波调制（调幅，调频，调相）后（加频）
单极性不归零码，双极性不归零码，单极性归零码，双极性归零码，曼彻斯特编码，差分曼彻斯特编码
奈氏准则：在任何信道中，码元传输速率是有上限的，否则会出现码间串扰导致的干扰和失真，理想的信道的最高码元传输速率=2✖W(信道带宽:Hz) 波特
香农定理：信道的极限信息传输速率C=W✖log2(1+S/N) b/s
物理层下面的传输媒体 导向传输媒体 双绞线：STP，UTP 同轴电缆：50Ω，75Ω 光纤 非导向传输媒体 无线电磁波传播（短波，微波） 物理层设备 集线器：是一个很大的冲突域，采用广播的方式 信道复用技术 充分利用一条共享信道
频分复用技术（FDM） 时分复用技术（TDM） 统计时分复用（STDM） 码分复用技术（CDM） 同一个频率同时传就只能采用码分复用
数字传输系统 PCM（脉码调制）：电话通信局用的，有两个标准（24路和32路） 宽带接入技术 xDSL技术：用电话线提供internet接入。低频留给传统电话，高频给上网用，打电话和上网互不影响。采用频分复用技术
HFC光纤同轴混合网：用有线电视提供internet接入。
FTTx技术：光纤到户</description>
    </item>
    
    <item>
      <title>计网-概述</title>
      <link>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Sat, 21 Nov 2020 15:05:40 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%AE%A1%E7%BD%91-%E6%A6%82%E8%BF%B0/</guid>
      <description>计算机网络在信息时代的作用 连通性，信息共享，软硬件共享
因特网概述 网络 network：结点（计算机，交换机）+链路
互联网 internet（数量距离相对网络增大）：网络+路由器
因特网 Internet：全球最大的互联网
因特网发展三个阶段：
ARPANET向互联网发展 三级结构的因特网（校园网，地区网，主干网） 多层次的ISP结构的因特网 因特网的标准化工作由因特网协会定义：因特网研究部，因特网工程部
因特网组成 C/S：客户机/服务器下载东西，客户机越多下载越慢
P2P：结点越多下载越快
电路交换：需要建立连接搭建专线（建立连接-》通话-》释放资源），适用于实时通讯（打电话）
分组交换：不需要建立连接，没有专线。将一个报文拆分为多包，每一个包不一定走同一条路。路由器由存储转发的功能。但是比电路交换延迟更大。
报文交换：和分许交换类似，但是不用拆分。
计算机网络在我国发展 1994年4月20日PRC接入互联网
计算机网络的类别 局域网：自己购买设备，自己维护，带宽固定。
广域网：花钱买服务，花钱买带宽。
计算机网络的性能 速率：连接在计算机网络上的主机在数字信道（一个接收端到一个发送端）上的传送位数的速率。b/s,kb/s,Mb/s,Gb/s 带宽：数字信道所能传送的最高数据率。b/s,kb/s,Mb/s,Gb/s 吞吐率：单位时间内通过某个网络的数据量（总的）b/s,Mb/s 时延：发送时延，传播时延，处理时延，排队时延 时延带宽积：传播时延✖带宽（一个信道承载数据能力） 往返时间：从发送方发送数据开始，到发送方收到接收方确认 利用率：有数据通过时间/(有无)数据通过时间 非性能指标：费用，质量，标准化，可靠性，可扩展性，可升级性，管理与维护 计算机网络的体系结构 分层的原因：标准化并降低每一层的相互关联
OSI7层 应用层：能够产生网络流量，能和用户交互的应用程序 表示层：加密，压缩，编解码（开发人员需要考虑的问题） 会话层：服务器和客户端建立的会话（可以用来查木马：netstat -nb）木马一般时隐藏盗窃信息 传输层：可靠传输(建立会话)，不可靠传输(QQ发消息，广播发送)，流量控制 网络层：IP地址编址，选择最佳路径 数据链路层：数据如何封装，添加物理层mac地址 物理层：电压，接口标准 网络排错：从底层往高层排错
网络安全和osi参考模型
物理层安全(连线安全) 数据链路层安全(ADSL和AP密码) 网络层安全（网关对某些网段的ip限制访问外网） 应用层安全（SQL注入漏洞，上传漏洞） 应用层 传输层 网络层 数据链路层 物理层 应用程序（传输数据单元PDU） 段（报文） 包（数据报） 帧 比特流 </description>
    </item>
    
    <item>
      <title>Martin Fowler关于微服务架构的论文译文</title>
      <link>114.116.115.171/post/martin-fowler%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BA%E6%96%87%E8%AF%91%E6%96%87/</link>
      <pubDate>Sat, 21 Nov 2020 13:09:52 +0000</pubDate>
      
      <guid>114.116.115.171/post/martin-fowler%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BA%E6%96%87%E8%AF%91%E6%96%87/</guid>
      <description>中文译文地址
Martin Flower原论文地址</description>
    </item>
    
    <item>
      <title>docker进阶指南</title>
      <link>114.116.115.171/post/docker%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 20 Nov 2020 15:51:50 +0000</pubDate>
      
      <guid>114.116.115.171/post/docker%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/</guid>
      <description>docker可视化 # Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制 Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:
FROM ubuntu:18.04 COPY . /app RUN make /app CMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：
事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。
每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。
最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。
commit镜像 docker commit #提交容器成为一个新的副本 docker commit -m=&amp;#34;描述信息&amp;#34; -a=&amp;#34;作者&amp;#34; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络</description>
    </item>
    
    <item>
      <title>linux网络配置</title>
      <link>114.116.115.171/post/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 20 Nov 2020 10:02:31 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</guid>
      <description>网络命令 #配置eth0的IP地址， 同时激活该设备 sudo ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up #添加默认网关 sudo route add default gw 192.168.1.1 #配置DNS sudo vi /etc/resolv.conf #激活设备 ifconfig eth0 up #禁用设备 ifconfig eth0 down 网络配置 #查看相应设备名称对应的设备信息 ethtool eth0 #查看相应设备名称对应的设备位置(回车后与eth0 相对应的网卡接口旁边的指示灯就会闪烁，这样你就能很快确定eth0 网口的位置啦) ethtool -p eth0 #Linux里面有两套管理网络连接的方案,两套方案是冲突的，不能同时共存。 /etc/network/interfaces（/etc/init.d/networking） Network-Manager 都是基于单网卡单ip的配置
静态配置 Redhat类 sudo vim /etc/sysconfig/network-scripts/ifcfg-eth[x]文件([x]为使用的网卡) # xxxxxxx(网卡名称，不用改) DEVICE=eth0 BOOTPROTO=static TYPE=ether HWADDR=xx:xx:xx:xx:xx:xx (网卡mac地址，不用改) IPADDR=x.x.x.x(ip地址) NETMASK=x.x.x.x(子网掩码) BROADCAST=x.x.x.x.(广播地址) NETWORK=x.x.x.x(网络地址) GATEWAY=x.x.x.x(网关地址) ONBOOT=yes(开机自启动) DNS1=x.x.x.x(域名服务器地址) DNS2=x.x.x.x Ubuntu类 sudo vim /etc/network/interfaces # The primary network interface (配置主网络接口) auto eth0 #开机自动激活eth0接口 iface eth0 inet static #配置eth0接口为静态地址 address 192.</description>
    </item>
    
    <item>
      <title>linux服务器搭建ssm项目环境</title>
      <link>114.116.115.171/post/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 19 Nov 2020 20:42:26 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</guid>
      <description>购买服务器 阿里云云翼计划：9.5块钱/月
配置环境 jdk环境 yum -y install java-1.8.0-openjdk.x86_64 java -version mysql环境 安装mysql cd /tmp wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-devel -y 启动mysql systemctl start mysql.service mysqladmin -u root password root mysql -uroot -proot tomcat环境 windwos环境中下载tomcat9的tar.gz后缀的压缩包
https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/
用FileZilla上传到linux服务器/usr/local目录下
解压缩后启动tomcat
cd /usr/local tar xzf apache-tomcat-9.0.17.tar.gz #更名文件夹为tomcat9 cd /usr/local/tomcat9/bin ./startup.sh 打包上传war包 打包上传前需要在阿里云的服务器防火墙中打开8080端口权限
也可以把tomcat的默认款口号设置为80（在tomcat的conf目录下修改server.xml文件的默认端口号）（推荐）
在IDEA中用maven工具先clean后package，在target目录下生成war包，用filezilla上传到tomcat的webapps目录下。
重启tomcat
然后就可以访问你自己的网站了。</description>
    </item>
    
    <item>
      <title>Docker入门指南</title>
      <link>114.116.115.171/post/docker%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 19 Nov 2020 18:09:16 +0000</pubDate>
      
      <guid>114.116.115.171/post/docker%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>docker介绍 下载docker依赖环境 想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样 yum -y install yum-utils device-mapper-persistent-data lvm2 指定docker镜像源头 默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker yum makecache fast yum -y install docker-ce #配置阿里云镜像加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39; { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://46dcjg1g.mirror.aliyuncs.com&amp;#34;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 启动docker 安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker #启动docker服务 systemctl start docker #设置开机自动启动 systemctl enable docker #测试 docker run hello-world docker中央仓库 1.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。 https://hub.docker.com/ 2.国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。 https://c.163yun.com/hub#/home http://hub.daocloud.io/ （推荐使用） 3.在公司内部会采用私服的方式拉取镜像（添加配置） #需要创建 /etc/docker/daemon.json，并添加如下内容 { &amp;#34;registry-mirrors&amp;#34;:[&amp;#34;https://registry.docker-cn.com&amp;#34;], &amp;#34;insecure-registries&amp;#34;:[&amp;#34;ip:port&amp;#34;] } #重启两个服务 systemctl daemon-reload systemctl restart docker docker镜像操作 拉取镜像 从中央仓库拉取镜像到本地 docker pull 镜像名称[:tag] #举个栗子:docker pull daocloud.</description>
    </item>
    
    <item>
      <title>软件生命周期</title>
      <link>114.116.115.171/post/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Sat, 14 Nov 2020 17:22:32 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>需求分析 概念：确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。 需求的获取 概念：软件需求的来源，软件工程师收集这些软件需求的方法 包含 功能性需求：用户和其他系统完成的功能，提供的服务 非功能性需求：必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等。 来源：用户目标，领域知识，投资者，运行环境，组织环境 获取方式：采访，设定情景，原型，会议，观察商业过程和工作流 需求获取面临的挑战： 客户说不清需求 需求易变性：在系统设计时，将软件的核心建筑放在稳定的需求上。 问题的复杂度和对问题空间理解的不完备性与不一致性 需求诱导十原则： 倾听 有准备的沟通 需要有人推动 最好当面沟通 记录所有决定 保持同理协作 聚焦并协调话题 采用图形表示 继续前进原则 谈判双赢原则 需求确认 需求获取
需求提炼：对应用问题及环境的理解和分析，为问题涉及的信息，功能和系统行为建立分析模型，将用户需求精确化，完全化，最终形成下一步的需求规格说明书
需求描述（需求规格说明书）：对待开发系统的行为的完整描述，包含了功能性需求和非功能性需求，完成的标志是形成一份完整规范的需求规格说明书。
需求验证：对需求文档进行检查：有效性检查，一致性检查，完备性检查，现实性检查
需求变更 需求分析的任务 建立分析模型：面向过程，面向对象 面向过程分析模型：用系统工程的思想和工程化的方法，根据用户至上的原则，自始自终按照结构化，模块化，自顶向下地对系统进行分析与设计。
采用结构化分析方法（面向数据流进行需求分析的方法），用抽象模型的概念，按照软件内部数据传递，变换的关系，自顶向下逐层分解，知道找到满足功能要求的左右可实现的软件为止。 面向对象分析模型：由5个层次（主题层，对象类层，结构层，属性层，服务层）和5个活动（标识对象类，标识结构，定义主题，定义属性，定义服务）组成。
编写需求说明：用《需求规格说明书》规范的额形式准确地表达用户的需求 IEEE标准对需求文档提出了以下结构：
引言（需求文档目的，文档约定，预期读者和阅读建议，产品范围，参考文献） 综合描述（产品前景，产品功能与优先级，用户特征，运行环境，设计与实现上的限制，假设与依赖性） 需求描述（功能需求，数据需求，性能需求，外部接口，设计约束，软件质量属性，其他需求） 附录（词汇表，分析模型，特定问题列表） 索引 系统设计 概要设计：描述软件顶层架构和组织，划分不同组件 详细设计：详细描述各组件以便能够编码实现 设计相关概念：
抽象 体系结构 设计模式 模块化 信息隐藏 功能独立 精化 重构 数据设计
架构设计
接口设计
组件设计
面向过程架构设计 变换型软件结构图
事务型软件结构图
混合型软件结构图
面向过程组件设计 面向对象架构设计 面向对象组件设计（类设计和用例设计） </description>
    </item>
    
    <item>
      <title>软件过程模型</title>
      <link>114.116.115.171/post/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 14 Nov 2020 14:33:54 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</guid>
      <description>软件工程 三要素： 方法：软件工程方法为软件开发提供了“如何做”的技术。软件工程方法分为两类：结构化方法和面向对象方法。
工具：软件工具为软件工程方法提供了自动的或半自动的软件支撑环境。集成的软件工程工具再加上人的因素构成了软件工程环境。
过程：软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。
七原则 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制 用现代程序设计技术 结果应能清楚地审查 开发小组的人员应该少而精 承认不断改进软件工程实践的必要性 知识体系 开发与维护过程 软件需求 软件设计 软件构造 软件测试 软件维护 支持组织过程 软件配置管理 软件工程管理 软件过程 软件工具（编码，测试等） 软件质量 软件过程（生命周期） 软件生命周期： 问题定义：项目计划报告 可行性研究：可行性研究报告 需求分析：需求规格说明书 概要设计：概要设计说明书 详细设计：详细设计说明书 编码：源程序 测试：软件测试报告 维护：软件维护说明 软件过程模型/软件生存周期模型 传统软件过程模型 1. 瀑布模型：适用于系统需求明确且稳定，技术成熟，工程管理较严格的场合，如军工，航天，医疗。 2. V模型 3. 原型模型（当客户不清楚系统的具体输入输出；或开发者不确定算法的效率，软件与操作系统是否兼容以及客户与计算机交互的方式时，使用原型模型） 原型：一个部分开发的产品，是客户和开发人员能够对加护开发的系统的相关方面进行检查。
原型化的目的：
明确并完善需求 研究技术选择方案 原型结果：
抛弃原型 把原型发展为最终产品 4. 增量模型（适用于软件开发过程中可能发生变化，具有较大风险，或者希望尽早进入市场的项目） 5. 螺旋模型(适用于需求不明确或需求可能发生变化的大型复杂软件系统) 6. 喷泉模型 现代软件过程模型 1. 基于构件的开发模型（使用于系统之间有共性的情况） 2. 统一过程模型 由Rational公司推出的完整且完美的软件工程方法
基于面向对象方法学
使用统一建模语言UML
实践视角（6条最佳实践）
迭代式开发 管理需求 基于构件体系结构 可视化建模 验证软件质量 控制软甲变更 3.</description>
    </item>
    
    <item>
      <title>SSM框架整合</title>
      <link>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 19 Oct 2020 12:31:09 +0000</pubDate>
      
      <guid>114.116.115.171/post/ssm%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</guid>
      <description>​ Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。
​ Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。
​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。
SSM整合总体思路 //Spring配置文件 ## spring-dao.xml * &amp;lt;context:property-placeholder location=&amp;#34;classpath:database.properties&amp;#34;/&amp;gt;引入propeties配置文件 * datasource数据库连接池对象注入 * sqlSessionFactory对象注入 * 扫描dao配置对象注入 ## spring-mvc.xml * 扫描web相关包中注解&amp;lt;context:component-scan base-package=&amp;#34;com.jack.controller&amp;#34; /&amp;gt; * &amp;lt;mvc:default-servlet-handler/&amp;gt;静态资源放行 * &amp;lt;mvc:annotation-driven /&amp;gt;json返回体时，直接return对象 * 视图解析器对象注入 ## spring-service.xml * 扫描service相关包中注解&amp;lt;context:component-scan base-package=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>浅谈日清1894海战（二）</title>
      <link>114.116.115.171/post/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%E4%BA%8C/</link>
      <pubDate>Wed, 24 Jun 2020 16:56:42 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%E4%BA%8C/</guid>
      <description> 上篇文章简单谈了下洋务运动的时代背景，北洋水师就是在19世纪中叶后的这样一个科技，政治大变革时代下诞生的。这次主要谈谈甲午战争中的大东沟海战，从一场海战放开来看，日本和清国之后的命运似乎就能说得通了。 先看战前。朝鲜内战，清朝以宗主国的身份入朝作战（主要是淮军）。此时，走上帝国主义道路的日本按照福泽谕吉的大陆政策，第一步正是朝鲜。在甲午战争正式爆发前的这个阶段，随着日本源源不断的向半岛派兵，日本逐渐掌握优势。清廷上的一群键盘侠就开始炮轰李鸿章，以前受洋人欺负，现在连日本也打不过，你李鸿章还想讲和。李鸿章心里清楚，此时的清军里就那么几个地方军能打仗，朝鲜战事上非淮军不可，用淮军和日本现代化军队打，无论是出于自保还是现实，避战都是正确的，在外交上依靠英法俄在华利益制衡日本相比之下更合适。奈何光绪也是年轻气盛，权力好不容易回来了（1889年，慈溪试探性地交还权力给了光绪），有大做一番的雄心壮志，加上一部分人的鼓动，不顾李鸿章反对，向日本宣战。国家统治层没有一套现代化的完备的战略决策制度，朝堂仪事+皇帝拍板定案的形式局限性很大。清廷统治层这种只图嘴上痛快就将一个国家推向战争的做法是极不负责的。 再看战时，甲午战争分为陆战和海战，这里谈的是海战中的大东沟海战。主要从军费，军舰（航速，射速，炮弹，老化），战术，官兵，情报几个角度简单谈谈： 先说军费：北洋水师成立的初衷就是一支防御性质的舰队，他的作用是守住京畿海口，配合陆军作战，这就限制了其规模上限。1888年建立初的北洋水师是亚洲最强舰队这一点不假，但是之后几乎未新添一舰，反观日本，虽然前期比不上北洋水师，但是直到1894开战，几乎一直在接收新式军舰。海军是一个需要长期投入才能起到效果的军种，更何况是在海军装备更新换代的关键时期（可以说甲午海战也是之后战列舰发展方向的参考案例）。再说清廷内部的问题，李鸿章和户部尚书翁同龢的私仇，海军衙门高层的人事变动，我觉得也是导致北洋水师后期装备停止更新的重要原因。 再说军舰：北洋水师的核心就是两艘德国制造的7000t铁甲舰，其他的都是2000t左右中规中矩的炮舰。由于年久未修的主观因素和装备革新的时代客观因素，开战前的航速已经明显下滑并落后于时代；火炮在开战前已经和日本形成代差；北洋水师炮弹配置上多为穿甲弹，少有开花弹，与之相比是日本的下濑火药。这些致命问题的根本原因就是军费没有跟上，五年陆军，十年空军，百年海军，这话不是没有道理，更何况是处在“铁甲舰到前无畏舰”的关键过渡时期。 10艘舰艇两两相伴，凭借定镇两舰打头阵冲进敌阵，然后再各自搏杀，寻找机会冲撞。日本这边的舰艇有几艘快速巡洋舰，组成了第一分队，航速远高于北洋舰队，快速绕道北洋侧翼集火超勇扬威，整场战争日本联合舰队没有给北洋水师留近身的机会，一直保持在一定距离利用速射炮快速倾泻弹药。可见，装备很大程度上决定了战术，不同的历史时期下的装备和战术结合产生的结果可能恰恰相反。 官兵素质上，据最新的历史考证发现，整个大东沟海战中，北洋水师的命中率是要高于日本的，甚至不输同时期的欧美海军。北洋海军雇佣洋人教官，模式也采用西方标准，虽然后期撤换掉了郎威理，但北洋水师多年的严格训练是很有成果的。从海战中的实际表现上来看，北洋海军的绝大部分官兵的表现确实都是值得肯定的。 间谍战是最容易被忽视的战争形式，据史料解密，甲午战前活跃在中国的日本间谍数量惊人，其伪装程度很高，通过各种手段获取了大量军事情报。 大东沟海战之后，虽然北洋舰队损失很大，但是家底还是有的，尚有一战之力，奈何陆军增援始终不到，等于是放弃了威海卫，最终难逃覆灭。 不管如何，1894年，大清还能倚靠李中堂的北洋水师在海上和日本真刀真枪地干一场，可谁又能想到，短短6年后，八国联军从中国的内海长驱直入直达紫禁城，讽刺的是，攻占京城时不少大清子民争着给洋人带路，诚然，“普天之下，莫非王土，和我有什么关系”，中国几千年的朝代更迭，底层百姓仍然只是过客。或许，大清只是败给了时代。 </description>
    </item>
    
    <item>
      <title>浅谈日清1894海战（一）</title>
      <link>114.116.115.171/post/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%E4%B8%80/</link>
      <pubDate>Mon, 22 Jun 2020 22:48:01 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%E4%B8%80/</guid>
      <description> “威海卫陷落，北洋舰队全军覆没标志着洋务运动的失败”，这是历史课本记述的那场战争，语文课本和影视作品中关于邓世昌率致远全舰撞击吉野的描述同样深入国人心。提起甲午，大家会想到很多关键词，然而，120多年前，围绕这场战争，当时的日本和大清的都是一个怎样的状态。1888年北洋海军建立，其实力一举被列强排位世界海军前10，是什么原因导致短短6年后被清人口中的矮子日本胖揍，再六年，八国从中国内海长驱直入，直取京畿。 1864年，持续十多年的太平天国运动结束。太平军本来是有能力推翻清王朝的，为什么没有？我觉得一方面是太平天国内部在起义运动后期统治层之间的分裂和战略分兵错误。另一方面，慈溪放开部分军权，让地方练兵，曾国藩的湘军就是镇压太平天国的主力，李鸿章的淮军同样源于此。太平天国结束后，加上之前两次鸦片战争的失败，慈溪支持的洋务派压倒了守旧派，其实慈溪这时很很清楚，如果不做出点改变朝廷只有死路一条，这也是她一开始支持维新变法的原因，但是这里的矛盾就是你改革可以，但是不能威胁慈溪的绝对统治，不然慈溪绝对搞死你。 洋务运动从19世纪60年代开始，持续了大约30年。我们可以看看这个时间段，世界上其他国家在干嘛？1861—1865年，美国通过南北战争实现实质统一。1871年，俾斯麦带领德国走向统一并在普法战争中击败法国。法国虽然在普法战争中战败，但是由于国库殷实，之后迅速复兴。英国在第一次工业革命后成为世界第一强国，正在全世界扩张。日本从1868年开始明治维新。沙俄1856年在克里米亚战争中失败开始搞农奴制改革。可见洋务运动这30年清国周边相对太平，也给了这个机会。但是，要知道，从60年代后期开始，第二次工业革命开始，与第一次几乎英国独享不同，这次是英德美法遍地开花。在其他列前纷纷崛起的19世纪，倡导“中体西用”的洋务运动注定不会一帆风顺。 洋务运动是一场大工程，在慈溪的授权下，中央是以奕昕为代表的满族官员。地方是以林则徐，魏源，左宗棠，曾国藩，李鸿章，沈葆桢，张之洞等等为代表的地方汉族官员。其涉及面较广，我要谈的围绕大清国海防建设，注意，是海防，不是海权。当时的清国，能有诸如李鸿章这样的洋务派的思想就已经很不错了，他们要的是建立海军守住海疆继续封建，没有一个海权的认识。 “师夷长技以制夷”，洋务派随即开始筹备海军建设。最开始的想法就是买，但被英国人李泰国摆了一道。之后沈葆桢逐渐意识到得自己建船厂，海军基地，同时培养自己的海军将领。于是在法国人的帮助下建立了马尾船厂，海军基地和船政学堂，聘请英法教师教学。在这里培养了中国第一批近代海军人才，也可能第一批睁眼看世界的中国人。 这些人当中很多留学英法，是那个时代西方世界中唯一的中国面孔。他们有的成了外交官，有的做了船政讲师、船舶设计师，但大部分都是之后北洋舰队的主要将领。当时的他们并不知道，身处时代浪潮下，自己将会何去何从。 1869年，自主建造的蒸汽化炮舰万年清号下水，1888年，自造铁甲舰平远号下水编入北洋水师。短期来看，洋务运动在海军上的建设很有效果，和同时也在建设海军的日本比起来至少在效果上甚至要更好。但是，清帝国的体系承自千年，已经是集权制的顶峰，正因如此，在人类历史最大变革的19世纪，肯定没有幕府统治下的日本好掉头，更何况倒幕运动已经把明治天皇请回来进行几乎全盘的西化。所以，长期来看，日本对中国的优势从这时就开始了，日本的野心也开始显现。 1874年，日本以琉球事件为借口发动了对台湾的军事行动，这次事件以大清承认日本对琉球的主权和赔款而告终。这次事件刺激了清廷，随机决定创办北洋水师和南洋水师。1884年，中法战争爆发，法国人偷袭了马尾，南洋水师全军覆没。1894年，日本趁着朝鲜内乱，跨海发兵。在牙山和丰岛两次海陆失利后，9月17日，护送运兵船支援平壤战役的北洋海军编队和在海上寻找决战的日本联合舰队在大东沟外海相遇，黄海海战爆发。海战历时5小时，北洋方面被击沉5艘，退回威海卫，失去制海权。关于这场海战的评价有很多，有说编队雁形阵错误的，有说北洋官兵军纪差的，有说慈溪挪用海军军费的，有说劣质炮弹的，诸如此类。海战战术层面上，国家制度落后就必败这类话没有任何意义，要尽可能准确地了解这场战争失败的直接原因，还得实事求是，从实际出发多方面分析。（接下文） </description>
    </item>
    
    <item>
      <title>javaWeb核心:servlet细节</title>
      <link>114.116.115.171/post/javaweb%E6%A0%B8%E5%BF%83-servlet%E7%BB%86%E8%8A%82/</link>
      <pubDate>Wed, 25 Mar 2020 16:42:00 +0000</pubDate>
      
      <guid>114.116.115.171/post/javaweb%E6%A0%B8%E5%BF%83-servlet%E7%BB%86%E8%8A%82/</guid>
      <description>HTTP协议： 概念：Hyper Text Transfer Protocol 特点： 基于TCP/IP的应用层协议 默认端口是80 基于请求响应模型，一次请求一次响应 无状态的；每次请求之间相互独立，不能交互数据 历史版本： 1.0版本：每次请求都会建立新的连接 1.1版本：每次连接建立后会等一会儿，如果有新的请求会复用 请求消息数据格式 请求行
请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 HTTP协议有7中请求方式，常用的就是GET和POST
GET：请求参数在请求行中；请求url长度有限制；相对不安全 POST：请求参数在请求体中；请求url长度没有限制；相对安全 请求头
请求头名称: 请求头值 常见请求头：
**User-Agent：**浏览器告诉服务器浏览器的版本信息 **Accept：**浏览器告诉服务器可以给我响应什么格式的信息 **Referer：**浏览器告诉服务器我从哪里来（防盗链 &amp;amp; 统计） **Connection：**这个请求连接此时的状态（1.0和1.1有区别） 请求空行
用来分隔请求头和请求体
请求体
只有POST请求方式有请求体，
请求参数=请求参数值 username=zhangsan 响应消息数据格式 响应行
协议/版本 响应状态码 状态码描述 HTTP/1.1 200 OK 响应状态码：服务器告诉客户端本次请求和响应的一个状态
1xx：服务端正在接收客户端信息，没有接收完全，等待一段时间后，发送1xx状态码 2xx：成功 3xx：302重定向，304访问本地缓存 4xx：404客户端错误（请求路径没有对应的资源）；405请求方式没有对应的doXXX方法 5xx：500服务器端错误（服务器内部出现异常，控制台和网页一般都会报错） 响应头
响应头名: 响应头值 常见的响应头：
Content-type：服务器告诉浏览器本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 默认：in-line attachment;filename=xxx：以附件形式打开响应体（文件下载） 响应空行
用来分隔响应头和响应体
响应体
网页文件 &amp;amp; 其他打回浏览器的数据（图片，视频等）
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; hello,world!</description>
    </item>
    
    <item>
      <title>JavaWeb核心:理解servlet</title>
      <link>114.116.115.171/post/javaweb%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3servlet/</link>
      <pubDate>Wed, 18 Mar 2020 19:37:53 +0000</pubDate>
      
      <guid>114.116.115.171/post/javaweb%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3servlet/</guid>
      <description>Servlet定义
物理上是一个运行在服务器端的一个小程序（serve applet），可以理解为就是一个接口（规则），定义了服务器端的Java类被tomcat识别的规则
我们需要自定义一个类，来实现servlet接口，复写接口的的方法，tomcat就可以识别这个类，我们就称这个类是个servlet
实际操作：
创建JavaEE项目 定义一个类，实现servlet接口 重写接口中的抽象方法 在web.xml中配置servlet Servlet的执行原理 servlet中的java类和javase中的普通java类是不一样的，它的运行依赖tomcat这个web容器，自己没有main方法。实现的servlet方法不需要自己调用，服务器会自己按照需要调用
当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的servlet的资源路径 查找web.xml文件，是否有对应的标签体内容 如果有，则会找到对应的全类名 tomcat会将字节码文件内加载进内存，并且创建其对象 tomcat按照需要自己调用方法 Servlet中的生命周期 sevlet中的方法 init方法：servlet被创建时执行 service方法：每一次servlet被访问时执行 destroy方法：在服务器正常关闭时执行 上面三个方法对应servlet的三个生命周期
servletConfig方法：获得servletconfig对象，就是servlet的配置对象 getServletInfo方法：获得servlet的一些信息，版本，作者&amp;hellip; Servlet被创建 默认情况下，第一次被访问时，servlet被创建，加载资源 非默认时，可以子啊web.xml中指定servlet的创建时机，配置标签的值，正数表示在服务器启动时创建，负数表示第一次被访问时创建 一个servlet类在内存中只有一个对象，是单例模式。多用户同时访问时，可能不安全，但是加锁会严重影响性能，所有尽量不要在servlet中定义成员变量线程公共资源，定义局部变量就没有安全问题了，因为局部变量在栈中，线程私有。 Servlet提供服务 每次访问都会执行service方法 Servlet被销毁 服务器关闭时，Servlet被销毁，释放资源。但是只有服务器正常关闭，才会执行destroy方法。 Servlet3.0 选择JavaEE时，选择servlet版本3.0以上，可以不选择web.xml了 可以通过注解配置：@WebServlet，不需要web.xml配置文件中配置了 Servlet体系结构 Servlet接口，GenericServlet抽象类，HttpServlet抽象类
GenericServlet抽象类继承Servlet抽象类，已经空实现了除了service方法之外的所有抽象方法。所以，可以让自定义的servelt类继承GenricServlet类，减少工作量。
HttpServlet抽象类也是继承于Servlet接口，并且由doPost和doGet方法，我们可以让自定义的Servlet类继承HttpServlet类复写doGet和doPost方法，但是service方法不用复写了，HttpServlet抽象类已经帮你写好了。用来根据post和get的请求方式做出不同判断。
Servlet相关配置 urlpartten：Servlet的访问路径 一个Servlet可以定义多个访问路径：@webServlet({&amp;ldquo;d4&amp;rdquo;,&amp;ldquo;d44&amp;rdquo;,&amp;ldquo;d444&amp;rdquo;}) 路径定义规则： /XXX /XXX/XX：多层路径，目录结构 *.do Servlet和JSP？ 先上一张图： 要理解servlet和jsp的区别与联系，我们需要回顾javaWeb的发展历史：
最开始的web，用户使用浏览器向web服务器发送的请求都是静态的资源（html,css,javascript）。为了能够根据不同用户的不同请求来动态的处理并且返回资源，servlet就出现了。 前面提到了servlet是在服务器端的java代码，通过java这个高级语言就能动态的处理数据和资源，然后把经过动态处理后的静态资源再打回浏览器客户端。但是有一个问题，servlet类中需要写大量的冗余的out.write代码写html，这就导致后端人员都想骂娘，然后，jsp就诞生了。 jsp是sun公司借鉴微软的asp后，推出的直接在原来的静态页面html中嵌入java代码的技术。但是，这样虽然可以避免冗余，但是前端人员必须要懂后端知识，并且在html中插入大量的java代码会是jsp文件代码看起来凌乱不堪，自己写完了都看不懂，更不要说多人协作了。所以再后来，基于MVC模式的JSP+Servlet+JavaBean就应运而生了（也就是上面图中所表达的） 所以，总结就是： 一个java类必须是serevlet类才能被浏览器访问到，jsp本质上就是一个servlet，jsp简化servlet的繁琐写html代码的操作 servlet是在java代码中写html，jsp是在html中写java代码 注：关于MVC的具体以及Web发展后期框架的出现以及前后端分离的知识现在还在学习中，以后会陆续写出来。</description>
    </item>
    
    <item>
      <title>IDEA中tomcat的神奇走位</title>
      <link>114.116.115.171/post/idea%E4%B8%ADtomcat%E7%9A%84%E7%A5%9E%E5%A5%87%E8%B5%B0%E4%BD%8D/</link>
      <pubDate>Wed, 18 Mar 2020 13:27:32 +0000</pubDate>
      
      <guid>114.116.115.171/post/idea%E4%B8%ADtomcat%E7%9A%84%E7%A5%9E%E5%A5%87%E8%B5%B0%E4%BD%8D/</guid>
      <description>tomcat服务器的三种部署方式： 直接将项目放进webapps目录下即可
/项目名就是访问路径
可以简化部署：将项目里的全部文件打一个war包，然后把war包放进webapps里面会自动解压缩。删除war包会自动删除项目。
conf/server.xml配置文件中，加上&amp;lt;Context docBase=项目地址 path=虚拟访问路径 /&amp;gt;
更加灵活些，范文路径是path，不一定是目录名 但是修改server.xml，不是很安全 热部署：在/conf/Catalina/localhost下面创建任意名称的xml文件，里面加上&amp;lt;Context docBase=项目地址 /&amp;gt;，范文路径就是xml文件的名称
IDEA中的tomcat 与eclipse或则myeclipse那样直接部署就在在tomcat的安装文件夹里生成部署文件不同，IDEA会为每一个tomcat部署的Web项目单独建立一份相关文件，里面包含配置文件，日志和临时目录（如下图），在自己的家目录下：C:\Users\你的用户名\.IntelliJIdea2019.3\system\tomcat\
**重点：**这里的文件对应着tomcat安装根目录下的对应文件，conf目录下是配置文件，idea默认就是热部署，就是在这里面对应的位置生成xml文件。work目录里面是临时文件，包含服务器端jsp被转化为servlet的java代码文件和class字节码文件。
tomcat服务器真正访问的是out目录(tomcat部署的web项目)，而out目录下的部署的项目对应着web工作空间目录下的所有资源，idea的out目录和web目录都在自己创建的项目地址下。
WEB-INF目录下有个classes目录，里面的java字节码文件是从src目录导过来的。
WEB-INF目录是个安全目录，其下的资源不能直接被浏览器访问</description>
    </item>
    
    <item>
      <title>Win10桌面美化</title>
      <link>114.116.115.171/post/win10%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</link>
      <pubDate>Wed, 11 Mar 2020 19:42:16 +0000</pubDate>
      
      <guid>114.116.115.171/post/win10%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/</guid>
      <description>先放上一张我的桌面：
前言：Windows操作系统经过几十年的发展，到目前已经相当成熟，在个人桌面操作系统中也是处于霸主地位，但是对于我而言，如果根据自我审美和操作习惯对Win10进行美化，无疑也是会提高舒适度和办公学习效率的。
everything+Wox 这东西能让你的桌面干干净净，再也不用在桌面码满快捷方式，还能一定程度上摆脱鼠标的束缚，查找软件，文档，甚至网页都是可以的，还有很多功能我没有探索到的。 其实关于全局搜索软件的尝试，我最开始是用的listary，很好用，就是有个缺点，能改样式的高级版收费。所以我就换了Wox，注意：要让Wox能全局搜索，需要配合everything，两个软件都设置成开机自启，美滋滋。 RocketDock win10的任务栏和Mac、Linux的Dock栏的喜爱见仁见智，不过我觉得Mac的dock栏的设计确实更加具有美感，效率性很不差。经过我的一番搜索，其实有很多：ObjectDock，BitDock等等，一些桌面第三方都支持这一功能，我为什么选择RocketDock呢？一个字，小。RocketDock对内存的占用几乎可以忽略不计，开机自启后完全不会拖慢Windows系统的运行。
官网下载，安装后可以在设置界面进行自定义设置，选项很多，这里不一一介绍了，有一点需要注意的是，我在选择了他的“将窗口最小化到Dock栏”这一项时，有部分软件并不能最小化到Dock栏，还是在任务栏最小化，经过我的分析，发现在Program Files和Program Files (x86)目录下的软件的反应不同，我感觉可能是因为该软件停更了几年，对64位的支持不好？也有可能是我的个别情况。
要把图标加到dock栏由两种方法：
直接把快捷方式或者exe文件拖入dock栏 右击dock栏，新建项目——&amp;gt;文件，然后右击新生成的文件图标，可以选择文件位置和图标 关于图标的自定义，这里推荐一个网站：阿里巴巴矢量图标库
如果要有如下stacks docklet的效果，需要下载一个插件，但是官网关闭了，如果百度不到的可以联系我。
Win10任务栏调整 Windows的任务栏是win的精华，并不能被dock完全取代，我是把它放在顶部。右击任务栏——&amp;gt;任务栏设置，里面有很多自定义选项，根据需要调整
我不习惯Win10的原始开始菜单，借助了**&amp;ldquo;腾讯电脑管家&amp;rdquo;的工具箱里面的&amp;ldquo;经典开始菜单&amp;rdquo;**工具，可以换成经典模式
合理利用Windows的键盘快捷键可以极大的提高效率，同时也会让你的系统更加的规范
ok，这篇博文就先介绍这几个最基本的工具，如果有什么不清楚的或者讨论的请留言，或者联系我的QQ（在菜单关于里面）</description>
    </item>
    
    <item>
      <title>linux备份与恢复</title>
      <link>114.116.115.171/post/linux%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Wed, 11 Mar 2020 17:26:23 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid>
      <description>备份概述 Linux中需要备份的数据：/root/目录，/home/目录，/var/spool/mail/目录，/etc/目录，其他目录
安装的服务的数据也需要备份：
apache需要备份的数据：配置文件，网页主目录，日志文件
mysql需要备份的数据：源码包安装的：/usr/local/mysql/data/或者RPM包安装的：/var/lib/mysql
备份策略：
完全备份：效果最高，但需要更大的硬盘空间 增量备份：每次备份只备份新的数据，占用空间少，但是恢复起来麻烦 差异备份：每次备份都只备份完全备份中不存在的，折中方法 备份命令 完全备份完全可以用tar打包压缩来做，但是如果是差异备份就会非常麻烦，这时就需要用到Linux为数据备份量是打造的备份和恢复命令dump命令和restore命令
dump [选项] 备份之后的文件名 原文件名
-级别：0到9个备份级别
-f：指定备份之后的文件名
-u：把备份时间记录在/etc/dumpdates文件中
-v：显示备份过程
-j：把备份文件压缩为.bz2格式
-W：查看详情
注意：dump命令只有在备份分区的时候才能增量备份，备份普通目录只能完全备份
restore [模式选项] [选项]
四个模式：
-C：比较备份数据和实际数据的变化
-i：交互模式
-t：查看模式
-r：还原模式
一个选项：
-f：指定备份文件的文件名 </description>
    </item>
    
    <item>
      <title>linux启动管理</title>
      <link>114.116.115.171/post/linux%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 11 Mar 2020 17:26:08 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/</guid>
      <description>CentOS 6的启动管理 运行级别：7个级别
runlevel：查看运行级别
init 运行级别：改变当前运行级别
vim /etc/inittab：永久修改系统默认运行级别，写上id:3:initdefault
不要把0和6设为默认级别
CentOS6系统启动过程：（针对MBR模式）
配合视频食用
启动引导程序grub Grub配置文件：/boot/grub/grub.conf
格式：
default=0 默认启动第一个系统
timeout=5 等待时间，默认是5秒
splashimage=(hd0,0)/grub/splash.xpm.gz 指定grub启动时的背景图像文件的保存位置
hiddenmenu 隐藏菜单
title CentOS(2.6.32-279.el6.i686) 标题
root (hd0,0) 指启动程序的保存分区
kernel /vmlinuz-2.6.32-279.el6.i686 ro 定义了内核加载时的选项
initrd /initramfs-2.6.32-279.el6.i686.img initramfs内存文件系统镜像文件的所在位置</description>
    </item>
    
    <item>
      <title>hexo博客优化之图床迁移&amp;google收录</title>
      <link>114.116.115.171/post/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BA%8A%E8%BF%81%E7%A7%BB-google%E6%94%B6%E5%BD%95/</link>
      <pubDate>Wed, 11 Mar 2020 11:32:08 +0000</pubDate>
      
      <guid>114.116.115.171/post/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BA%8A%E8%BF%81%E7%A7%BB-google%E6%94%B6%E5%BD%95/</guid>
      <description>前言：
搭建完hexo后，当然就是写博客，markdown的语法插入图片很简单，但是把大量图片放在博客文件里面，未免太臃肿，会大大拖慢博客的打开时间（更别说我的博客是托管在github上的了）。图床就是一个好的解决方案，顾名思义，图床就是一个存储图片个“床”，一个云端的图片库，它把博客和图片分离开来，更好管理的同时也不会拖慢博客的速度。 我写博客虽然都是给自己看的，但是搜索引擎搜不到自己的文章总感觉缺了点什么:laughing:,让谷歌收录自己的博文，再加上自己博文的质量，就能在google搜索引擎上根据关键词搜索到自己的文章了。（百度的收录我没有弄，不过大同小异） 图床迁移： 我之前的图床用的是路过图床，这是个免费的图床，还不错，免费额度完全够用，但是感觉图片打开速度有点慢。所以就百度了一下，发现了一种同样免费且快捷的方式：gitee(码云)+PicGo。迁移过后，实测效果明显，下面就来总结一下
现在码云建立一个仓库，按照下面格式来。没有账号的自己注册。
在gitee的个人设置里选择 私人令牌——&amp;gt;生成新令牌，最后会生成一串密文，保存它，后面和PicGo绑定要用。
下载PicGo软件下载链接，Windows系统选择exe安装程序下载，macos选择dmg程序安装程序下载。
进入PicGo界面，插件搜索gitee-uploader，安装，然后重启。
进入图床设置，选择gitee，然后填入以下信息
repo：gitee中你建立的仓库地址，例如yangfanjack/image branch：填master token：刚才的密文 path：一般填img customPath：不填 customUrl：不填 然后点击设为默认图床——&amp;gt;确认，即可，enjoy it!
Google收录： 前提：看到这里的我相信都有办法进google吧
进入Google Search Console，既然有新的，就选择左边的网域，按照他的格式例如ordinaryman.club填入你的域名，点击继续
会DNS验证，去你的域名购买商添加一条txt record，如果之前更改过DNS服务器地址，就去DNS代理商添加record，我是cloudflare代理的，所以以此为例：
点击**+Add record**，然后type选择TXT，Name填@，Content就填Google给你的txt内容，点击save，完成。
返回Google Search Console界面，点击验证，一般会过一段时间通过，不过我是马上就通过了:neutral_face:。
然后进入你的本地博客根目录，安装站点地图插件：
npm install hexo-generator-sitemap --save 安装完后进入根目录的配置文件_config.yml
在URL下： url: http://XXXXXX //写入你的域名 在最后加上： sitemap: path: sitemap.xml 保存后，hexo三件套：hexo clean hexo g hexo d，访问网页：你的域名/sitemap.xml，出现以下页面说明配置成功
进入Google Search Console的你的域名管理页面，点击站点地图，添加你的站点地图的网址：你的域名/sitemap.xml，等待一天时间，就可以生效啦。</description>
    </item>
    
    <item>
      <title>linux日志管理</title>
      <link>114.116.115.171/post/linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 10 Mar 2020 22:54:07 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</guid>
      <description>日志管理简介 百度百科简介：系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。
服务器出现问题先查看日志，才能找准原因
CentOS7中原来的日志服务syslogd被rsyslogd取代，两者兼容
确认服务是否启动和自启动：
ps aux | grep rsyslogd chkconfig --list | grep rsylog 常见的日志的作用：
RPM包安装的服务日志也会在/var/log/目录下
源码包安装的服务日志在源码包指定目录（一般是/usr/local）中，这些日志不是有rsyslogd服务来管理的，而是由各个服务使用自己的日志管理文档来记录自身日志
rsyslogd日志服务 日志文件格式 事件产生的时间 产生事件的服务器的主机名 产生事件的服务名或程序名 事件的具体信息 /etc/rsyslog.conf配置文件 ​	格式：
authpriv.* /var/log/secure
服务名称[连接符号]日志等级 日志记录位置
服务名称，连接符，日志等级，日志记录位置都有多个，内容很多，自行百度。
日志轮替 如果日志都记录在一个文件中，那么可能会占据大量存储空间，纯文本文档打开会非常慢，所以日志需要处理：切割（把大日志按天切割成小的）+轮换（删除旧的，保存新的）
如果配置文件中由“dateext”参数，那么日志会用日期作为后缀，只需要保存指定的日志个数，删除多余的日志文件即可
如果没有“dateext”参数，那么日志文件就需要改名了，当第一次使用日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志。第二次时，1变2，0变1，又新建0，以此类推
配置文件：/etc/logrotate.conf
包含参数：daily，weekly，monthly，rotate，compress，create mode owner group等
分别表示：轮替周期时每天，每周，每月，保存日志文件的个数，旧日志是否压缩，建立新日志同时指定权限
只要是RPM包安装的服务，它默认已经支持轮替，但是源码包安装的服务需要vim /etc/logrotate.conf，然后手动加入轮替
FOR EXAMPLE:
/usr/local/apache2/logs/access_log{ daily //每天备份 create //备份的时候创建新的日志 rotate 30 //保留30天 } logrotate -v /etc/logrotate.conf：显示日志轮替过程
logrotate -f /etc/logrotate.conf：强制轮替，不管日志轮替的条件是否已经满足</description>
    </item>
    
    <item>
      <title>linux系统管理</title>
      <link>114.116.115.171/post/linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 10 Mar 2020 21:21:48 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</guid>
      <description>进程管理的作用：（下面优先级由高到低）
判断服务器的健康状态 查看系统中的所有进程 杀死进程 进程查看 ps aux：查看系统中所有进程，查看BSD操作系统格式
ps -le：查看系统中所有进程，Linux格式
输出格式的作用：
top（每3秒更新一次）
-d 秒数：默认每3秒更新一次，可指定
？或h：显示交互模式的帮助
P：以CPU使用率排序
M：以内存使用率排序
N：以PID排序
q：退出top
top命令的显示：
pstree：查看进程树
进程终止 kill
-l：查看kill支持的信号
-1 PID：重启进程
-9 PID：终止进程
killall 进程名：按照进程名杀死，选项和kill通用
-i：有询问
-I：忽略进程名的大小写
pkill 进程名：按照进程名杀死，选项和kill通用
也可以加t选项跟终端号：pkill -t 终端号：按照终端号踢出用户，用 w 命令查询系统中登录的用户，然后用终端号来踢
工作管理 把进程放入后台 命令后面加&amp;amp;：后台继续运行 在命令执行过程中，按下ctrl+z快捷键：放入后台即暂停 查看后台的工作：jobs -l：加l会显示工作号 bg %工作号：恢复后台暂停的工作恢复到后台运行，但是不能恢复和前台有交互的命令比如top命令和vim命令 fg %工作号：恢复后台暂停的工作恢复到前台运行 注意：工作号≠PID 系统资源查看 vmstat 刷新延时(s) 刷新次数：监视系统资源使用情况，和top内容差不多，但更简洁
dmesg：开机时内核检测，一般结合grep使用
free：查看内存使用情况
-b：以字节为单位显示
-k：以KB为单位显示（默认就是）
-m：以MB为单位显示
-g：以GB为单位显示
查看CPU信息：
cat /proc/cupinfo:每次开机都会更新 dmesg | grep CPU uptime：实际就是top命令第一行 uname：查看系统与内核相关信息
-a：查看系统所有相关信息
-r：查看内核版本</description>
    </item>
    
    <item>
      <title>linux的服务管理</title>
      <link>114.116.115.171/post/linux%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 10 Mar 2020 17:56:48 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
      <description>服务简介与分类 Linux服务分类 RPM包默认安装的服务 独立的服务 基于xinetd（超级守护进程）服务 源码包安装的服务（第三方源码包） 服务的启动与自启动 查询已安装的服务
RPM包安装的服务：chkconfig --list：查看RPM包安装的服务按照运行级别的自启动状态。如果查询当前启动的服务，用ps aux或者netstat或者service --status-all
源码包安装的服务：没有命令，只能去服务安装位置查看，一般在/usr/local/下
其实源码包和RPM包安装的服务在Linux中的区别就是安装位置不同
RPM包安装服务的管理 ​	RPM包安装的服务默认保存位置：(特殊文件有自己的默认保存位置)
独立服务的管理 启动方式：/etc/init.d/独立服务名和service 独立服务名 自启动方式： chkconfig --level 运行级别 独立服务名：打开自启动 chkconfig 独立服务名 off：关闭自启动 修改/etc/rc.d/rc.local文件,加入需要自启动的服务名 使用ntsysv命令管理自启动，图形界面很直观 基于xinetd(超级守护进程)服务的管理 默认情况下Linux是没有xinted的，需要手动安装yum -y install xinetd 然后用chkconfig --list查看，基于xinetd的服务不占用内存，但是需要的响应时间更长 基于xinetd的服务的启动，修改/etc/xinetd.d/下对应的服务的配置文件,然后service xinetd restart 基于xinetd的服务的自启动： chkconfig 服务名 on和chkconfig 服务名 off 图形界面工具：ntsysv 基于xinetd的启动和自启动是通用的，两者区分不是很严格，这种设置不利于管理，所以现在基于xinetd的服务越来越少了 源码包安装服务的管理 ​	RPM包安装的服务默认保存位置：/usr/local/
源码包安装服务的启动和关闭(用绝对路径的启动脚本启动)：/usr/local/apache2/bin/apachectl start|stop 一般每一个源码包都有安装说明INSTALL，应该查看里面的启动方法 源码包安装服务的自启动： vim /etc/rc.d/rc.local加入/usr/local/apache2/bin/apachectl start 把源码包服务的启动脚本软连接到/etc/init.d/目录下和chkconfig --add 服务名，就可以实现service，chkconfig和ntsysv命令管理源码包安装服务，但是并不推荐，容易混乱。 </description>
    </item>
    
    <item>
      <title>shell编程</title>
      <link>114.116.115.171/post/shell%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 06 Mar 2020 22:51:56 +0000</pubDate>
      
      <guid>114.116.115.171/post/shell%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;基础正则表达式&#34;&gt;基础正则表达式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;和&lt;strong&gt;通配符&lt;/strong&gt;区别：&lt;/p&gt;
&lt;p&gt;通配符：在系统中搜索匹配文件名，是完全匹配。支持命令ls，find，cp，他们不认识正则表达式&lt;/p&gt;
&lt;p&gt;正则表达式：用来在文件中匹配符合条件的字符串，是包含匹配。支持命令：grep，awk，sed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>shell基础</title>
      <link>114.116.115.171/post/shell%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 06 Mar 2020 22:51:25 +0000</pubDate>
      
      <guid>114.116.115.171/post/shell%E5%9F%BA%E7%A1%80/</guid>
      <description>shell就是Linux中的命令解释器，说白了，就是一个命令行的交互界面。与Linux不同Windows中就是图形的交互界面。shell还是一个强大的编程语言，因为它可以直接调用Linux的系统命令。 Shell的种类： Bourne Shell语法类：sh，ksh，Bash，psh，zsh C Shell语法类（只要同于BSD的Linux版本中）：csh，tcsh 目前的主流shell时Bash Shell 在文件/etc/shells中，可以查看Linux中默认支持的Shell类型，在命令行下输入shell的名字就可以切换shell类型 Shell脚本的执行方式 echo命令：输出指定内容
echo -e：支持反斜线的字符转换 First Script：
#!/bin/Bash echo -e &amp;#34;Mr Yang is the most handsome man in the world.&amp;#34; 执行方法：
第一种：先chmod 755 hello.sh 然后./hello.sh 第二种：bash hello.sh 注意：如果一个shell脚本在Windows中编辑完成，在Linux中发现运行出错，这是因为Windows和Linux格式不同，你可以用cat -A来验证，换行符不用。解决方法就是用命令dos2unix将Windows格式转化为Linux格式
Bash的基本功能 history history n：显示最近的n条命令 history -d n：删除第n条命令 history -c：清空历史命令 history -w：把缓存中的历史命令写入每个用户的缓存文件~/.bash_history 可以使用上，下箭头的方式调用历史命令，也可以使用!n，!!，!字串直接执行指定的命令 TAB键 在Linux的bash中，Tab键可以用来不全命令和文件名 命令别名&amp;amp;常用快捷键 命令别名就是给命令定义一个别名，For Example：alias vi=&#39;vim&#39;
直接用alias可以查看当前的所有别名，实际就是查看~/.bashrc文件的内容
命令执行的顺序：
绝对路径或相对路径的命令 别名 Bash的内部命令（内部命令就时用whereis找不到的Linux自带命令） 按找$PATH环境变量定义的目录查找顺序找到的第一的命令（外部命令） 让别名永久生效：写入~/.bashrc配置文件
unalias：删除别名
常用快捷键：Ctrl+下列的字母
c强制终止当前命令
l清屏
u剪切光标之前的内容
k剪切光标后的内容
y粘贴</description>
    </item>
    
    <item>
      <title>linux的文件系统管理</title>
      <link>114.116.115.171/post/linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 06 Mar 2020 20:30:32 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</guid>
      <description>分区和系统文件 对于硬盘分区形式是MBR的，主分区+扩展分区&amp;lt;=4个。如果是IDE硬盘，Linux最多支持59个逻辑分区；如果是SCSI硬盘，Linux最多支持11个逻辑分区 对于GPT分区形式而言，没有上述限制 Windows文件系统为FAT16、FAT32、FAT64和NTFS。而Linux的文件系统可分为ext2、ext3、ext4、swap和vfat。 格式化的目的就是写入文件系统 文件系统常用命令 df命令，du命令，fsck命令，dumpe2fs命令 df -a -h：显示所有分区&amp;amp;人性化显示。(一般用来统计系统空间大小) du -a -h -s：弥补ls命令的不足，可以统计文件夹包括里面的内容的大小而不是单单文件夹的大小。(一般用来统计文件大小) **df和du的区别：**du只是面向文件的，只会计算文件或目录占用的空间；df是从文件系统角度考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除但是程序并没有释放空间） fsck -a -y 分区设备文件名：文件系统修复命令，不需要自己手动执行 dumpe2fs 分区设备文件名：显示ext2、ext3、ext4文件系统的超级块和块组信息 挂载命令 将设备文件名和绑定到盘符(挂载点)上，Windows是自动，Linux默认是手动分配 mount -l：查询异已挂载的设备，加-l会显示卷标名 mount -a：依据配置文件/etc/fstab中的内容，自动挂载 mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点 挂载光盘和U盘 Linux中的分区时开机自动挂载，但是光盘和U盘时手动挂载，系统准备了/mnt/和/media/来挂载
挂载光盘步骤：（sr0和cdrom都可以作为设备文件名）
mkdir /mnt/cdrom/：建立挂载点
mount -t iso9660 /dev/cdrom /mnt/cdrom/或者mount /dev/sr0 /mnt/cdrom：挂载
cd /mnt/cdrom/：去挂载点访问
umount 设备文件名或挂载点：在拿走光盘之前需要先卸载光盘
挂载U盘步骤：（U盘的设备文件名是自动识别的，用fdisk -l查看）
mkdir /mnt/usb/：建立挂载点
mount -t vfat /dev/sdb1 /mnt/usb/：挂载
cd /mnt/usb/：去挂载点访问
umount 设备文件名或挂载点：在拔U盘之前需要先卸载光盘
注意：挂载U盘只能用本机或者虚拟机，不能用远程工具
​	Linux默认是不支持NTFS文件系统的外设的，U盘只能FAT格式的
Linux如何支持NTFS文件系统 Linux系统的内核中已经把市面上常见的驱动包括了，所以安装系统后一般不需要安装驱动，Linux会自动匹配识别，如果Linux默认没有把一个文件系统的驱动加载进来，我们就需要手动去安装驱动。</description>
    </item>
    
    <item>
      <title>linux权限管理</title>
      <link>114.116.115.171/post/linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 06 Mar 2020 10:00:13 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>ACL权限 ACL权限的简介和开启方式 任何一个文件在一个时刻只能有一个所有者和所属组 ACL权限用来解决文件的权限身份不够用的情况 ACL权限需要分区支持：dumpe2fs -h /dev/sda5/查看是否支持acl选项，如果不支持。可以临时开启：mount -o remount,acl/ 或者永久开启：vim /etc/fstab然后重启系统 ACL权限类似于windows的权限设置方法，就是不考虑user，group和others的权限设置，单独添加一个用户或者一个用户组对一个文件或者目录的权限 查看与设定ACL权限 getfacl 文件名：查看ACL的权限
setfacl 选项 文件名
setfacl -m u/g/m:用户名/组名/不写:权限 文件名：设定文件的ACL权限
最大有效权限与删除ACL权限 最大有效权限mask：可以通过getfacl 文件名来查看ACL的权限，里面有mask，可以通过控制mask的值来修改默认最大有效权限。 需要注意的是mask权限不会影响当前文件所有者，只会影响ACL权限和所属组的权限 setfacl -x u/g:用户名/组名 文件名：删除文件指定的ACL权限 setfacl -b 文件名：删除文件所有ACL权限 默认ACL和递归ACL权限（只能针对目录） setfacl -m d:u/g:用户名/组名:权限 文件名：设定父目录的默认ACL权限，父目录里所有的新建文件都会继承父目录的ACL权限
setfacl -k：删除父目录的默认ACL权限
setfacl -m -R ...：递归设定文件夹的ACL权限
文件特殊权限 SetUID：在所有者的x位置上变成了s 四个条件缺一不可：
只有二进制文件（例如命令和脚本文件）才能设定SUID权限
命令执行者必须对该程序有x权限
命令执行者会在执行的时候获得该程序文件的属主身份
SUID权限只在该程序执行过程中生效，也就是身份改变旨在程序执行过程中有效
passwd命令拥有SetUID权限，所以普通用户能修改自己密码
我们通常会看到4777，2777，1777的权限标识，依次是加了SUID，SGID，SBIT权限
可以用chmod来赋予和删除SUID
SetUID是非常危险的，一个命令只要有了s权限，例如passwd命令，普通用户就可以通过执行这个命令获得passwd的属主身份，也就是进入root权限。
SetGID：在所属组的x位置上变成了s 针对二进制文件，三个条件缺一不可：
命令执行者必须对该程序有x权限
命令执行者会在执行的时候获得该程序文件的所属组身份
SUID权限只在该程序执行过程中生效，也就是所属组身份改变旨在程序执行过程中有效
注：例如/usr/bin/locate命令
针对目录，三个条件缺一不可：
普通用户必须对此目录拥有r和x权限，才能进入该目录
普通用户在此目录中的有效组会变成此目录的所著组
若普通用户对此目录拥有w权限时，新建的文件的默认组不是文件自己的初始组，而是这个目录自己的所属组
可以用chmod来赋予和删除SGID
Sticky BIT(黏着位)：在其他人的x位置上变成了t 四个条件缺一不可：
只有目录才能设定SBIT权限</description>
    </item>
    
    <item>
      <title>linux中的用户管理</title>
      <link>114.116.115.171/post/linux%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 05 Mar 2020 21:10:44 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</guid>
      <description>用户配置文件 越是安全性要求高的服务器越需要对用户权限等级制度和服务器操作规范有很高的要求，linux中主要通过用户配置文件来查看和修改用户信息
主要有四个配置文件：/etc/passwd，/etc/shadow，/etc/group，/etc/gshadow
/etc/passwd：用户信息文件 **格式：用户名称；密码标志；UID（0超级用户，1—499系统用户:不能登录，不能删除，500—65535普通用户）；GID（这里是初始组ID不是附加组ID）；用户说明:备注；家目录；**Shell（命令解释器类型，默认是bash） /etc/shadow：影子文件 是passwd的影子
**格式：用户名称；加密密码（SHA512加密，可以暴力破解，!!和*表示没有密码，不能登录）；密码最后一此修改时间（时间戳表示）；两次密码修改间隔（天）；密码时效天数（-1永不失效）；密码修改到期前的警告天数；密码到期后的宽限天数；账号失效时间（时间戳表示）；**包留位
时间戳换算：
时间戳—&amp;gt;日期：date -d &amp;quot;1970-01-01 16066 days&amp;quot;
日期—&amp;gt;时间戳：echo$(($(date --date=&amp;quot;2014/01/06&amp;quot; +%s)/86400+1))
/etc/group&amp;amp;/etc/gshadow：组信息文件&amp;amp;组密码文件 **/etc/group格式：**组名，组密码标志，GID，组中附加用户 **/etc/gshadow格式：**组名，组密码(默认没有，也不推荐使用)，组管理员用户名，组中附加用户 Linux中查看用户的初始组的方法：查询etc/passwd和/etc/group，两两对照查看 用户管理相关文件 用户的家目录：（会自动生成）
/home/用户名/：权限700
/root/：权限550
用户的邮箱：
/var/spool/mail/用户名/
用户模板目录：就是母板，新建用户会默认创建在用户家目录下
/etc/skel/
用户管理命令 useradd：创建用户 useradd 用户名 passwd 用户名 新建一个用户实际上就是在上述六个地方生成了默认信息，所以手工修改上述六个地方就可以手工添加用户 useradd -u UID：指定自定义UID useradd -d 家目录：指定自定义家目录 useradd -c 用户说明：指定自定义用户说明 useradd -g 组名：指定自定义初始组组名 useradd -G 组名1,组名2：指定自定义附加组组名 useradd -s shell：指定自定义shell 用户默认值配置文件：/etc/default/useradd &amp;amp; /etc/login.defs passwd：修改用户密码 超级用户可以改任意用户密码
普通用户只能给自己设密码
whoami：查看当前用户
passwd -S 用户名 ：查看密码状态，就是shadow里面的信息
passwd -l 用户名 ：锁定用户，实际是在shadow中的密码前面加了!
passwd -u 用户名 ：解锁用户</description>
    </item>
    
    <item>
      <title>linux软件包管理</title>
      <link>114.116.115.171/post/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 05 Mar 2020 12:20:07 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>软件包管理简介 ​	软件包分类：
源码包：包括脚本安装包 二进制包：RPM包，系统默认包（ubuntu中是deb包） 源码包的优点 开源 可以自由选择所需的功能 软件是便宜安装，所以更加是个自己的系统，更加稳定也效率更高 卸载方便（直接把目录删除） 源码包的缺点 安装步骤多 编译并安装时间过长 因为是编译安装，安装过程中一旦报错新手很难解决 RPM包优点 包管理系统简单，只需要几个命令就可以实现软件包的安装，升级，查询和卸载 安装速度比源码包快很多 RPM包缺点 不能看见原代码 功能选择不如源码包灵活 依赖性 RPM包管理—rpm命令管理 RPM包名和包全名
RPM包的依赖性：树形依赖，环形依赖，模块依赖(以.iso.数组结束的就是模块依赖，也叫库文件依赖模块依赖查询网站)
安装和升级使用包全名，卸载和查询使用包名（在/var/lib/rpm/中的数据库总搜索）
RPM安装：rpm -ivh 包全名
RPM升级：rpm -Uvh 包全名
RPM卸载：rpm -e 包名,也要考虑依赖性，当有包被依赖时，此时这个包不能删掉
RPM查询包：rpm -q 包名 rpm -qa：所有安装的包
RPM查询包详细信息：rpm -qi 包名
RPM查询未安装包的详细信息：rpm -qip 包全名
RPM查询文件安装位置：rpm -ql 包名
RPM查询未安装包的文件安装的默认位置：rpm -qlp 包名
RPM查询系统文件属于哪个rpm包：rpm -qf 系统文件名
RPM查询软件包的依赖性：rpm -qR 包名
RPM查询未安装软件包的依赖性：rpm -qRp 包全名
RPM包校验：rpm -V 包名
RPM包中文件提取（用来修复系统）：
第一步：rpm2cpio 包全名
第二布：cpio -idv . 包中的文件绝对路径</description>
    </item>
    
    <item>
      <title>强大的文本编辑器:Vim</title>
      <link>114.116.115.171/post/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-vim/</link>
      <pubDate>Thu, 05 Mar 2020 10:41:52 +0000</pubDate>
      
      <guid>114.116.115.171/post/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-vim/</guid>
      <description>Vim是linux中的一款使用最广的文本编辑器，全屏幕编辑器。 可以建立，编辑，显示文本文件。 它没有菜单只有命令. 三种模式 命令模式
插入模式：后：a/A，前：i/I，行：o/O进入
退出模式
常用操作 :set ic————搜索时不区分大小写:set nu————显示行号:set nonu————关闭行号:gg————快速定位到第一行:G————快速定位到最后一行:nG————快速定位到第n行:n————快速定位到第n行$————快速定位到行尾0————快速定位到行首x————删除光标后字符X————删除光标前字符4x————删除光标后n个字符dd————删除一行4dd————删除当前行和下面的n-1行dG————删除当前行到文件末尾D————删除光标到行尾:1,8d————删除第1行到第8行yy————复制当前行nyy————复制当前行和下面的n-1行p————粘贴到光标下一行P————粘贴到光标上一行r————替换当前字符R————从当前位置一直往后替换（进入替换模式，esc退出模式）u————恢复ctrl+r————撤销恢复:/string————搜索命令，按n找下一个:%s/old/new/g————全文替换old为new:n1,n2s/old/new/g————n1到n2行替换old为new:w————保存（相当于Windows的ctrl+r）:w filename————另存为:wq————保存并退出ZZ————保存并退出:q!————不保存退出:wq!————强制保存退出，针对只读文件可以强行保存(只有文件所有者和root才可以) 查看命令的执行结果：
:!命令
导入内容到文件中：
:r 导入文件地址：导入文件内容
:r !命令：导入命令执行结果
查看命令的地址：
:!which 命令名
定义快捷键：
:map 快捷键 触发命令
关键词自动替换
:ab mymail XXXXXXX@gmail.com：输入mymail是自动替换为你的邮箱地址
所有配置都是临时的，要永久需要写入配置文件里，存放在用户的家目录下，.vimrc，如果没有的话就自己新建一个也ok</description>
    </item>
    
    <item>
      <title>linux常用命令</title>
      <link>114.116.115.171/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 04 Mar 2020 15:17:31 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux作为一个网络操作系统，命令行才是王道，而不是图形。 Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。 linux命令在系统中有两种类型：内置Shell命令和Linux命令 linux各目录的作用 /bin/：存放系统命令
/sbin/：存放系统目录，只有超级用户能用
/usr/bin/：存放系统命令，单用户模式不能执行
/usr/sbin/ ：存放系统命令，只有超级用户能用，单用户模式不能执行
/boot/ ：系统启动目录，内核和启动引导程序
/dev/ ：硬件设备文件目录
/etc/ ：linux默认的配置文件保存目录
/home/：普通用户家目录
/root/：超级用户家目录
/lib/：系统调用的函数库
/lost+found/：当系统意外崩溃时，每个分区都含有的存放的文件碎片用来修复
/media/：挂载目录，挂载媒体设备
/mnt/：挂载目录，挂载U盘，移动硬盘，和其他操作系统的分区
/misc/：挂载目录，挂载NFS服务的共享目录
/opt/：第三方安装的软件的保存目录，也可以放到/usr/local/下
/proc/：存放在内存里面，存放系统的内核，进程，外部设备
/sys/：存放在内存里面，存放系统的内核相关的东西
/srv/：服务数据目录
/tmp/ ：临时目录，可以清空
/usr/：系统资源目录
/var/：动态资源保存目录，日志，邮件，数据库
服务器注意事项 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 远程配置防火墙时不要把自己踢出服务器 指定合理的密码规范和定期更新 合理分配权限 定期备份重要数据和日志 Linux常用命令 文件处理命令 ls ls -l：查看文件所有属性 ls -d：查看目录本身 ls -i：查看文件的inode号 ls -h：人性化显示 ls -s：显示文件占用的块的数量 ls -a：查看隐藏文件 mkdir mkdir -p：递归创建目录 cd&amp;amp;pwd rmdir cp cp -r：复制目录
cp -p：原文件和新文件属性完全一致
注：复制的同时可以改名
mv ​	注：移动的同时可以改名
rm rm -r：文件夹递归删除 rm -f：强制删除，不询问 touch cat&amp;amp;tac cat -n：显示行号，tac没有-n选项 more ​	空格翻页，回车换行，q退出</description>
    </item>
    
    <item>
      <title>linux系统简介和安装</title>
      <link>114.116.115.171/post/linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/</link>
      <pubDate>Wed, 04 Mar 2020 10:41:10 +0000</pubDate>
      
      <guid>114.116.115.171/post/linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/</guid>
      <description>UNIX和Linux发展史 ​	1965年，贝尔实验室：MULTICS计划
​	69年，贝尔实验室的肯汤普森：为了游戏开发UNICS/UNIX系统
​	62年，美国军方：ARPA：阿帕网，NCP协议——》TCP/IP协议
​	71年，可汤普森和丹尼斯里奇发明C语言，重写UNIX
​	UNIX主要发行版本：AIX(IBM)、HP-UX(HP)、Solaris(Sun)、Linux(Intel,AMD&amp;hellip;&amp;hellip;)、BSD
​	1991年，芬兰大学生Linus Torvalds开发linux内核。大学教授开发minix，但是不接受外来代码，所以李纳斯独自开发，由社区共同维护。
​	Linux内核版本号：主版本.次版本.末版本 linux内核官网
​	Linux发行版本：两大派系redhat和debian
开源软件简介 ​	商业软件和开源软件（开源≠免费）
​	开源软件：apache、NGINX、MySQL、php、mongoDB、python、Ruby、Perl、Go、Rust、Swift、Java
​	开源软件的特点：使用自由（绝大多数免费）、研究自由（源代码）、散步和改良的自由
​	支撑互联网的开源技术（LAMP）：Linux，Apache，MySQL，PHP
Linux应用领域 基于Linux的企业服务器
踩点网站：发数据包根据相应嗅探服务器
世界前500服务器
嵌入式应用
手机，平板：Android底层是Linux
智能家电，航空系统，银行系统&amp;hellip;&amp;hellip;
在电影娱乐业
特效，图形处理渲染
Linux学习方法 ​	Linux只考虑应用性和稳定性
​	善于观察提示信息，查找文档，自己解决问题
​	学习英文：Command not found和No Such file or directory
​	忘掉Windows的操作习惯
​	计划，专注，坚持，练习
Linux系统安装 VMware虚拟机安装 ​	VMware官网下载，不推荐安装双系统
​	特点：
不需要分区就能在物理机上使用两种以上的操作系统
物理机和虚拟机能实现网络通信
可以设定并随时修改虚拟机操作系统的硬件环境
要求：
CPU：主频1GHz以上
内存：1GB以上
硬盘：8GB以上
镜像下载：
官网下载:几个版本：DVD版本，Everything版本，minimal版本，LiveGnome版本，KdeLive版本，livecd版本，NetInstall版本
系统分区 ​	主分区：最多只能有4个</description>
    </item>
    
    <item>
      <title>Windows包管理器scoop</title>
      <link>114.116.115.171/post/windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8scoop/</link>
      <pubDate>Tue, 03 Mar 2020 18:34:53 +0000</pubDate>
      
      <guid>114.116.115.171/post/windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8scoop/</guid>
      <description>对于熟悉linux的同学，apt和yum等等这些包管理器肯定很熟悉，Windows下也有一个类似的好用的包管理器scoop，用scoop安装一些环境配置软件就会省去手动配置环境变量的步骤，并且里面的软件还很齐全，wonderful!
安装 管理员身份打开终端，设置用户变量
[environment]::setEnvironmentVariable(&amp;#39;SCOOP&amp;#39;,&amp;#39;D:\software\scoop&amp;#39;,&amp;#39;User&amp;#39;) 启用
$env:SCOOP=&amp;#39;D:\software\scoop&amp;#39; install scoop
iex (new-object net.webclient).downloadstring(&amp;#39;https://get.scoop.sh&amp;#39;) 配置全局变量
[environment]::setEnvironmentVariable(&amp;#39;SCOOP_GLOBAL&amp;#39;,&amp;#39;D:\software&amp;#39;,&amp;#39;Machine&amp;#39;) 启用
$env:SCOOP_GLOBAL=&amp;#39;D:\software&amp;#39; 使用 scoop help：查看scoop的使用方式和命令 scoop status：检查scoop是否最新 scoop update：更新scoop库 scoop search XXX：搜索软件 scoop install XXX：安装软件 scoop insrall -g XXX：全局安装软件 scoop uninstall XXX：卸载软件 scoop uninstall -g XXX：全局卸载软件 scoop list：列出安装的软甲 scoop bucket list：列出安装的仓库 scoop bucket add XXX：添加仓库 常用软件 7zip git aria2 vim gcc nodejs oraclejdk tomcat mysql57 #手动开启 mysql --standalone mysql --console #注册mysql为服务 mysqld --install MySQL --defaults-file=&amp;#34;D:\software\apps\mysql57\current\my.ini&amp;#34; #停止服务 sc stop MySQL #删除服务 sc delete MySQL </description>
    </item>
    
    <item>
      <title>hexo博客搭建</title>
      <link>114.116.115.171/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 03 Mar 2020 17:40:54 +0000</pubDate>
      
      <guid>114.116.115.171/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>注：推荐观看bilibili的up主codesheep的hexo视频教程，本博客是参考该视频
1. 部署环境 安装nodejs:官网下载,下载完包括nodejs本身和npm包管理器
管理员身份打开终端(推荐git bash)
node -v和npm -v验证是否安装成功
安装cnpm
用npm安装cnpm的taobao源，防止丢包，提高安装成功率，用cnpm -v验证
npm install cnpm -g --registry=https://registry.npm.taobao.org 同样也可以直接修改npm的仓库源
npm config set registry https://registry.npm.taobao.org #查看npm仓库 npm config get registry 这里其实推荐使用nvm这个nodejs版本管理工具来安装nodejs
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash nvm --version nvm ls-remote nvm install v12.18.0 nvm ls 用 cnpm install -g hexo-cli 全局安装hexo博客框架，用hexo -v验证
2. 初始化博客 建立一个空的文件夹，作为blog博客目录
在blog目录下，hexo init 自动克隆博客框架到本地
hexo s 在本地localhost:4000`端口可以预览本地的博客
3. 写博客 hexo n &amp;quot;blog name&amp;quot; 生成新博文到source文件夹下，就可以愉快的写博客了 hexo clean 清理目录之后，hexo g 更新生成 4.</description>
    </item>
    
    <item>
      <title>makefile基础语法</title>
      <link>114.116.115.171/post/makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 03 Mar 2020 16:53:57 +0000</pubDate>
      
      <guid>114.116.115.171/post/makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>C/C++文件到可执行文件的过程 gcc -E xx.c -o xx.i 预处理gcc -s xx.i -o xx.s 编译gcc -c xx.s -o xx.o 汇编gcc xx.o -o xx 链接 ​	对于单个文件的编译，可以浓缩为一条命令
gcc xx.c -o xx ​	但是在实际开发中，我们的一个项目有多个文件，并且有多层文件夹的嵌套。makefile文件就是为了解决这个问题而出现的
makefile文件的基础语法 1. 第一层次：easiest ​	基本格式：
目标文件： 依赖文件(一个tab)gcc/g++指令 ​	伪目标：
.PHONY:clear（名字自定义）:rm -rf xx.o xx.s xx.i xx.exe(运行的时候：make clear) ​	For Example:
#circle.c circle.h cube.c cube.h main.c main.h test: circle.o cube.o main.o gcc circle.o cube.o main.o -o test circle.</description>
    </item>
    
    <item>
      <title>markdown基础语法</title>
      <link>114.116.115.171/post/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 03 Mar 2020 12:13:04 +0000</pubDate>
      
      <guid>114.116.115.171/post/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>markdown基础——博客必备 推荐编辑器 typora vscode 语法 1. 标题 markdown的标题一共分为六个级别，从大到小依次是：
# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 2. 字体 加粗
**这是加粗** 斜体
*这是斜体* 斜体并加粗
***这是斜体并加粗*** 删除线
~~这是删除线~~ 3. 引用 可嵌套
&amp;gt; 引用1 &amp;gt;&amp;gt; 引用2 &amp;gt;&amp;gt;&amp;gt; 引用3 4. 分割线 需要三个或者三个以上的*或-
********** 5. 图片 ![图片下面的文字解释](图片地址) 6. 超链接 [名字](链接地址) 7. 列表 无序列表 * 无序列表1 + 无序列表2 - 无序列表3 有序列表 1. 有序列表1 2. 有序列表2 3. 有序列表3 嵌套列表 上级列表和下级列表之间敲三个空格
1. 一级列表 * 二级列表1 * 二级列表2 2.</description>
    </item>
    
    <item>
      <title>git基础</title>
      <link>114.116.115.171/post/git%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 03 Mar 2020 11:53:47 +0000</pubDate>
      
      <guid>114.116.115.171/post/git%E5%9F%BA%E7%A1%80/</guid>
      <description>git的安装 ​	官网下载后，在cmd中输入git验证是否安装完成
git的基本配置 git config --global user.name &amp;#34;name&amp;#34;git config --global user.email &amp;#34;email&amp;#34; ​	需要注意的是可以有三种参数，local、global和system，优先级依次降低。global是全局配置，local可以为本地项目添加单独配置
​	查看配置命令：
git config -l --global(或其他两个) git配置文件位置
本地项目配置文件：当前项目/.git/config
git config --local XXX 全局配置文件：~/.gitconfig
git config --global XXX 系统配置文件：/etc/.gitconfig（需要root权限）
git config --system XXX 三种免密登录方式
URL中体现：
原来：https://github.com/YangFanJack/DesignPattern.git免密：https://用户名:密码@github.com/YangFanJack/DesignPattern.gitgit remote add origin https://用户名:密码@github.com/YangFanJack/DesignPattern.gitgit push origin master SSH实现：
//生成公钥和私钥，在用户的.ssh文件夹里面把公钥添加到远程仓库github里面ssh-keygen -t rsa -C &amp;#34;youremail&amp;#34; //生成两把钥匙ssh -T git@github.com //验证ssh配置是否配置好//注意：如果提示找不到ssh-keygen命令的错误，说明你执行这条命令的位置错了，应该在本地的git仓库根目录下执行 git自动管理凭证
//基于操作系统的功能，不同操作系统的实现方式不一样 git基本操作 ​	第一步
git init //初始化，让git帮助管理文件夹git status //检测当前目录下文件状态git add //工作区到暂存区git commit -m &amp;#34;注释&amp;#34; //暂存区到版本库，生成版本/快照git diff //查看修改内容 ​	从现在回溯到历史，和从历史回溯到将来</description>
    </item>
    
    <item>
      <title>JavaScript类型转换</title>
      <link>114.116.115.171/post/javascript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 16 Dec 2019 21:57:57 +0000</pubDate>
      
      <guid>114.116.115.171/post/javascript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>强类型定义语言和弱类型定义语言 1）强类型定义语言： 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
2）弱类型定义语言： 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！ 例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。
js中的数据类型 基本数据类型：string, number, boolean, undefined, null 引用数据类型：Object, Array, Function 转化规律 显示转换 toString()方法：null和undefined没有该方法 null和undefined有String()函数，该函数适应性更加好 Number()函数： 字符串转数字：只能转纯数字字符串，如果是空串或空格串，转为0，否则NaN 布尔转数字：true-&amp;gt;`;false-&amp;gt;0 Null转数字：结果为0 undefined转数字：结果为NaN parseInt()函数和parseIntFloat()函数:将字符串中有效的整数部分提出来转化为整数。如果是对非字符串使用该方法，则会先将其转化为string，然后再运算。 Boolean()函数： number:只有0和NaN是false string:只有空串是false,甚至空格串也是true undefined:false null:false 对象类型：都是true JavaScript中的运算符隐式转换 &amp;ldquo;+&amp;ldquo;运算：对非number的值进行算数运算时，会先将这些值转化为number,然后再运算（string和NaN除外） 任何值和NaN做算数运算结果都是NaN 如果两个字符串相加，会拼串。 任何值和字符串做“+”运算，都需要将其转化为字符串，然后拼串 numbe类型+&amp;rdquo;&amp;quot;(空串)：隐式将number转化为string，和String()和toString()功能相同 对于其他算数运算(&amp;rdquo;-&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;/&amp;quot;)，非number都会转化为number 根据第6条，可知：string类型-0；string类型*1；string类型/1都可以转化为number类型（加0不可以，0会转为string） 正号：对于非number,会先转化为number类型，&amp;quot;+string&amp;quot;也可以将string类型转化为number类型。 !取反符:对非boolean双重取反&amp;quot;!!&amp;quot;，可以将非Boolean类型转化为Boolean类型 </description>
    </item>
    
    <item>
      <title>C&#43;&#43;程序实现演讲比赛成绩打分程序</title>
      <link>114.116.115.171/post/c&#43;&#43;%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%88%90%E7%BB%A9%E6%89%93%E5%88%86%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 26 Nov 2019 23:29:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/c&#43;&#43;%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%88%90%E7%BB%A9%E6%89%93%E5%88%86%E7%A8%8B%E5%BA%8F/</guid>
      <description>程序总体框架 1.speaker类：演讲选手类 class Speaker { public: string m_Name; //严格意义上这俩数据成员应该是私有的，用set和get函数来调用 double m_Sorce[2];//此处是为了简便，严格意义上这样是不规范大气的 Speaker(); ~Speaker(); }; 2.speechManager类：演讲比赛类（主体） class SpeechManager { public: SpeechManager(); ~SpeechManager(); void show_Menu();//打印菜单 void exitSystem();//退出系统 void initSpeech();//初始化speechManager类的各个数据成员 void createSpeaker();//创建参加比赛的12名选手 void startSpeech();//比赛的主函数，包含所有流程，所有分流程又拆分为单独函数 void speechDraw();//抽签 void speechContest();//比赛（重点） void showScore();//显示晋级选手 void saveRecord();//保存每一届冠亚季军到csv文件 void loadRecord();//加载文件中每一届数据到程序中 void showRecord();//显示文件中的数据（每一届的冠亚季军） void clearRecord();//清除文件记录 vector&amp;lt;int&amp;gt; v1;//保存每一届的最初12名选手 vector&amp;lt;int&amp;gt; v2;//保存每一届第一轮比赛晋级的6名选手 vector&amp;lt;int&amp;gt; vVictory;//保存每一届冠亚季军 map&amp;lt;int,Speaker&amp;gt;m_Speaker; map&amp;lt;int,vector&amp;lt;string&amp;gt;&amp;gt; m_Record;//存放往届记录 int m_index;//保存是每一届比赛的第几轮 bool fileIsEmpty;//判断文件是否为空 }; 3.main.cpp(主函数) int main() { int choice=0; while(true) { srand((unsigned int)time(NULL)); SpeechManager sm; sm.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;的几种初始化方式</title>
      <link>114.116.115.171/post/c&#43;&#43;%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 04 Nov 2019 15:54:39 +0000</pubDate>
      
      <guid>114.116.115.171/post/c&#43;&#43;%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/</guid>
      <description>列表初始化 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。
但有局限性：当对内置对象使用列表初始化的时候，若初始值存在丢失的风险时，编译器会报错
拷贝初始化 例子：string s2=s1;
直接初始化 例子：string(); string(&amp;ldquo;hi&amp;rdquo;); string(3,&amp;lsquo;c&amp;rsquo;);
默认初始化 非static局部变量、static局部变量、全局变量、类类型
值初始化 例子：vector a(10);
类成员初始化 只允许进行拷贝初始化和列表初始化</description>
    </item>
    
  </channel>
</rss>
