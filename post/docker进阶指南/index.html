<!DOCTYPE html>
































<html
  class="not-ready text-sm lg:text-base"
  style="--bg: #faf6f1"
  lang="en-US"
>
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, shrink-to-fit=no"
  />

  
  <title>docker进阶指南 - My Hugo Site</title>

  
  <meta name="theme-color" />
  
  <meta name="description" content="docker可视化 # Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制 Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:
FROM ubuntu:18.04 COPY . /app RUN make /app CMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：
事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。
每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。
最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。
commit镜像 docker commit #提交容器成为一个新的副本 docker commit -m=&#34;描述信息&#34; -a=&#34;作者&#34; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络" />
  <meta
    name="author"
    content=""
  />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://yangfanjack.github.io/main.min.css" />

  

  
     
  <link rel="preload" as="image" href="https://yangfanjack.github.io/theme.png" />

  
  
  
  <link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/44813701?v=4" />
  
  

  
  <link rel="preload" as="image" href="https://yangfanjack.github.io/github.svg" />
  

  
  <link rel="icon" href="https://yangfanjack.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://yangfanjack.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.109.0">

  
  

  
  
  
  
  
  
  
  
  
  <meta property="og:title" content="docker进阶指南" />
<meta property="og:description" content="docker可视化 # Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制 Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:
FROM ubuntu:18.04 COPY . /app RUN make /app CMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：
事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。
每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。
最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。
commit镜像 docker commit #提交容器成为一个新的副本 docker commit -m=&#34;描述信息&#34; -a=&#34;作者&#34; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yangfanjack.github.io/post/docker%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-11-20T15:51:50+00:00" />
<meta property="article:modified_time" content="2020-11-20T15:51:50+00:00" />

  
  <meta itemprop="name" content="docker进阶指南">
<meta itemprop="description" content="docker可视化 # Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制 Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:
FROM ubuntu:18.04 COPY . /app RUN make /app CMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：
事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。
每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。
最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。
commit镜像 docker commit #提交容器成为一个新的副本 docker commit -m=&#34;描述信息&#34; -a=&#34;作者&#34; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络"><meta itemprop="datePublished" content="2020-11-20T15:51:50+00:00" />
<meta itemprop="dateModified" content="2020-11-20T15:51:50+00:00" />
<meta itemprop="wordCount" content="415">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="docker进阶指南"/>
<meta name="twitter:description" content="docker可视化 # Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署 docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer # Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。 docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制 Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:
FROM ubuntu:18.04 COPY . /app RUN make /app CMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：
事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。
每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。
最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。
commit镜像 docker commit #提交容器成为一个新的副本 docker commit -m=&#34;描述信息&#34; -a=&#34;作者&#34; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络"/>

  
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header class="mx-auto flex h-[5rem] max-w-3xl px-8 lg:justify-center">
  <div class="relative z-50 mr-auto flex items-center">
    <a
      class="-translate-x-[1px] -translate-y-0.5 text-3xl font-bold"
      href="https://yangfanjack.github.io/"
      >My Hugo Site</a
    >
    <a
      class="btn-dark ml-6 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
    ></a>
  </div>

  <a
    class="btn-menu relative z-50 -mr-8 flex h-[5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
  ></a>

  
  <script>
    
    const htmlClass = document.documentElement.classList;
    setTimeout(() => {
      htmlClass.remove('not-ready');
    }, 10);

    
    const btnMenu = document.querySelector('.btn-menu');
    btnMenu.addEventListener('click', () => {
      htmlClass.toggle('open');
    });

    
    const metaTheme = document.querySelector('meta[name="theme-color"]');
    const lightBg = `"#faf6f1"`.replace(/"/g, '');
    const setDark = (isDark) => {
      metaTheme.setAttribute('content', isDark ? '#000' : lightBg);
      htmlClass[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark);
    };

    
    const darkScheme = window.matchMedia('(prefers-color-scheme: dark)');
    if (htmlClass.contains('dark')) {
      setDark(true);
    } else {
      const darkVal = localStorage.getItem('dark');
      setDark(darkVal ? darkVal === 'true' : darkScheme.matches);
    }

    
    darkScheme.addEventListener('change', (event) => {
      setDark(event.matches);
    });

    
    const btnDark = document.querySelector('.btn-dark');
    btnDark.addEventListener('click', () => {
      setDark(localStorage.getItem('dark') !== 'true');
    });
  </script>

  <div
    class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"
  >
    
    

    
    <nav
      class="mt-12 flex justify-center space-x-10 dark:invert lg:mt-0 lg:ml-12 lg:items-center lg:space-x-6"
    >
      
      <a
        class="h-8 w-8 [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6"
        style="--url: url(./github.svg)"
        href=" https://github.com/YangFanJack "
        target="_blank"
      ></a>
      
    </nav>
    
  </div>
</header>


    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-10rem)] max-w-3xl px-8 pt-20 pb-32 dark:prose-invert"
    >
      

<article>
  <header class="mb-20">
    <h1 class="!my-0 pb-2.5">docker进阶指南</h1>

    
    <div class="text-sm opacity-60">
      
      <time>Nov 20, 2020</time>
      
      
    </div>
    
  </header>

  <section><h2 id="docker可视化">docker可视化</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署</span>
</span></span><span style="display:flex;"><span>docker run -d -p 8088:9000 --restart<span style="color:#f92672">=</span>always -v /var/run/docker.sock:/var/run/docker.sock --privileged<span style="color:#f92672">=</span>true portainer/portainer
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。</span>
</span></span><span style="display:flex;"><span>docker run ‐di ‐‐name<span style="color:#f92672">=</span>rancher ‐p 9090:8080 rancher/server
</span></span></code></pre></div><h2 id="docker的分层机制">docker的分层机制</h2>
<p>Docker镜像是<strong>分层</strong>构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>FROM ubuntu:18.04
</span></span><span style="display:flex;"><span>COPY . /app
</span></span><span style="display:flex;"><span>RUN make /app
</span></span><span style="display:flex;"><span>CMD python /app/app.py
</span></span></code></pre></div><p>以上四条指令会创建四层，分别对应<strong>基础镜像、复制文件、编译文件以及入口文件</strong>，每层只记录本层所做的更改，而这些层都是<strong>只读层(镜像层)</strong>。当你启动一个容器，Docker 会在最顶部添加<strong>读写层</strong>，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为<strong>容器层</strong>，如下图所示：</p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201120162027.jpeg" alt=""></p>
<p>事实上，<strong>容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层</strong>。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。</p>
<p><strong>每个容器都有自己的读写层</strong>，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你<strong>希望多个容器共享或者持久化数据，可以使用 Docker volume</strong>）。</p>
<p>最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。</p>
<h2 id="commit镜像">commit镜像</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker commit <span style="color:#75715e">#提交容器成为一个新的副本</span>
</span></span><span style="display:flex;"><span>docker commit -m<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;描述信息&#34;</span> -a<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;作者&#34;</span> 容器id 自定义目标镜像名:<span style="color:#f92672">[</span>版本号<span style="color:#f92672">]</span>
</span></span></code></pre></div><p><strong>接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络</strong></p>
<h2 id="容器数据卷">容器数据卷</h2>
<p>用来实现&quot;删服务不删数据&quot;，数据可持久化，将<strong>容器内的目录</strong>映射<strong>同步</strong>到<strong>宿主机的目录</strong>中，类似于双向绑定</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>docker run -it -v 宿主机目录:容器内目录 <span style="color:#75715e">#注意目录都是绝对地址</span>
</span></span><span style="display:flex;"><span>docker inspect 容器id <span style="color:#75715e">#查看容器的具体同步目录信息Mount</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#数据卷命令</span>
</span></span><span style="display:flex;"><span>docker volume create <span style="color:#75715e">#创建数据卷</span>
</span></span><span style="display:flex;"><span>docker volume inspect <span style="color:#75715e">#显示数据卷详细信息</span>
</span></span><span style="display:flex;"><span>docker volume ls <span style="color:#75715e">#显示所有数据卷</span>
</span></span><span style="display:flex;"><span>docker volume rm <span style="color:#75715e">#移除数据卷</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#具名和匿名挂载（都不指定路径）</span>
</span></span><span style="display:flex;"><span>docker run -d -P name nginx02 -v juming-nginx:/etc/nginx nginx
</span></span><span style="display:flex;"><span>docker run -d -P name nginx01 -v /etc/nginx ngix
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>所有的docker容器内的卷没有指定具体路径的情况下，都在<span style="color:#e6db74">`</span>/var/lib/docker/volumes<span style="color:#e6db74">`</span>下
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-v /宿主机路径：容器内路径   <span style="color:#75715e">#指定路径挂载</span>
</span></span><span style="display:flex;"><span>-v 数据卷名：容器内路径  <span style="color:#75715e">#具名挂载</span>
</span></span><span style="display:flex;"><span>-v 容器内路径  <span style="color:#75715e">#指定目录挂载</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这里的ro和rw代表读写权限，ro表示只读，rw表示读和写，对挂载出来的内容就进行了限制，ro表示只能通过宿主机进行改变，容器内无法操作</span>
</span></span><span style="display:flex;"><span>docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx
</span></span><span style="display:flex;"><span>docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#DockerFile:用来构建docker镜像的构建文件，相当于一个命令脚本。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#镜像是层次的，脚本里的命令也是层次的</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#格式：指令(大写) 参数</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#每个命令就是镜像的一层</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FROM centos
</span></span><span style="display:flex;"><span>VOLUME <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;volume01&#34;</span>,<span style="color:#e6db74">&#34;volume02&#34;</span><span style="color:#f92672">]</span> <span style="color:#75715e">#匿名挂载</span>
</span></span><span style="display:flex;"><span>CMD echo <span style="color:#e6db74">&#34;------end-------&#34;</span>
</span></span><span style="display:flex;"><span>CMD /bin/bash
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker build -f dockerfile01 -t jack/centos
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#两个/多个容器之间同步数据（数据卷容器）</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#docker02挂载到docker01上，此时docker01就是数据卷容器</span>
</span></span><span style="display:flex;"><span>docker run -d -it --name docker02 --volumes--from docker01 jack/centos
</span></span></code></pre></div><h2 id="dockerfile">DockerFile</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#构建步骤</span>
</span></span><span style="display:flex;"><span>1. 编写dockerfile文件
</span></span><span style="display:flex;"><span>2. docker build <span style="color:#75715e">#构建成为一个镜像</span>
</span></span><span style="display:flex;"><span>3. docker run <span style="color:#75715e">#运行镜像</span>
</span></span><span style="display:flex;"><span>4. docker push <span style="color:#75715e">#发布镜像（dockerhub，阿里云镜像仓库）</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#基础知识</span>
</span></span><span style="display:flex;"><span>1. 每个保留关键字（指令）都大写
</span></span><span style="display:flex;"><span>2. 执行从上到下
</span></span><span style="display:flex;"><span>3. <span style="color:#e6db74">&#34;#&#34;</span>表示注释
</span></span><span style="display:flex;"><span>4. 每一个指令都会创建提交到一个新的镜像层
</span></span></code></pre></div><p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201120220311.png" alt=""></p>
<p><strong>dockerfile是面向开发的，交付环境就是交付一个dockerfile文件：DockFile-&gt;DockerImages-&gt;Docker容器</strong></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201120220723.png" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>FROM <span style="color:#75715e">#基础镜像</span>
</span></span><span style="display:flex;"><span>MAINTAINER <span style="color:#75715e">#镜像是谁写的</span>
</span></span><span style="display:flex;"><span>RUN <span style="color:#75715e">#镜像构建时需要运行的命令</span>
</span></span><span style="display:flex;"><span>ADD <span style="color:#75715e">#添加内容（tocmat，mysql等）</span>
</span></span><span style="display:flex;"><span>WORKDIR <span style="color:#75715e">#镜像的工作目录</span>
</span></span><span style="display:flex;"><span>VOLUME <span style="color:#75715e">#挂载目录</span>
</span></span><span style="display:flex;"><span>EXPOSE <span style="color:#75715e">#暴露的端口</span>
</span></span><span style="display:flex;"><span>CMD <span style="color:#75715e">#指定容器启动的时候要运行的命令，只有最后一个会生效</span>
</span></span><span style="display:flex;"><span>ENTRYPOINT <span style="color:#75715e">#指定容器启动的时候要运行的命令，可以追加命令</span>
</span></span><span style="display:flex;"><span>ONBUILD <span style="color:#75715e">#只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行ONBUILD后的指令</span>
</span></span><span style="display:flex;"><span>COPY <span style="color:#75715e">#将文件拷贝到目录中</span>
</span></span><span style="display:flex;"><span>ENV <span style="color:#75715e">#构建的时候设置环境变量（例：mysql用户名）</span>
</span></span></code></pre></div><p><strong>实战：自定义centos</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>vim mydocker-centos
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>FROM centos
</span></span><span style="display:flex;"><span>MAINTAINER jack&lt;yangfanjack1024@qq.com&gt;
</span></span><span style="display:flex;"><span>ENV MYPATH /usr/local
</span></span><span style="display:flex;"><span>WORKDIR $MYPATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN yum -y install vim
</span></span><span style="display:flex;"><span>RUN yum -y install net-tools
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXPOSE <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CMD echo $MYPATH
</span></span><span style="display:flex;"><span>CMD echo <span style="color:#e6db74">&#34;-----end-----&#34;</span>
</span></span><span style="display:flex;"><span>CMD /bin/bash
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ADD </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#VOLUME </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ENTRYPOINT </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ONBUILD </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#COPY </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#得到自定义镜像mycentos:0.1</span>
</span></span><span style="display:flex;"><span>docker build -f mydocker-centos -t mycentos:0.1 .
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#编写包含tomcat的centos自定义镜像</span>
</span></span><span style="display:flex;"><span>1. 准备镜像文件tomvat和jdk的压缩包
</span></span><span style="display:flex;"><span>2. 编写dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Dockerfile文件</span>
</span></span><span style="display:flex;"><span>FROM centos
</span></span><span style="display:flex;"><span>MAINTAINER jack&lt;yangfanjack1024@qq.com&gt;
</span></span><span style="display:flex;"><span>COPY readme.txt /usr/local/readme.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ADD jdk-8u271-linux-x64.tar.gz /usr/local
</span></span><span style="display:flex;"><span>ADD apache-tomcat-9.0.40.tar.gz /usr/local
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>RUN yum -y install vim
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ENV MYPATH /usr/local
</span></span><span style="display:flex;"><span>WORK $MYPATH
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#设置环境变量</span>
</span></span><span style="display:flex;"><span>ENV JAVA_HOME<span style="color:#f92672">=</span>/usr/local/jdk1.8.0_271
</span></span><span style="display:flex;"><span>ENV CLASSPATH<span style="color:#f92672">=</span>$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</span></span><span style="display:flex;"><span>ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.40
</span></span><span style="display:flex;"><span>ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.40
</span></span><span style="display:flex;"><span>ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EXPOSE <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CMD /usr/local/apache-tomcat-9.0.40/bin/startup.sh <span style="color:#f92672">&amp;&amp;</span> tail -F /usr/local/apache-tomcat-9.0.40/bin/logs/catalina.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#构建自定义tomcat的镜像</span>
</span></span><span style="display:flex;"><span>docker build -t diytomcat .
</span></span><span style="display:flex;"><span><span style="color:#75715e">#启动tomcat</span>
</span></span><span style="display:flex;"><span>docker run -d -p 8080:8080 --name jacktomcat -v /root/test/:/usr/local/apache-tomcat-9.0.40/webapps/test/ -v /root/tomcatlogs/:/usr/local/apache-tomcat-9.0.40/logs/ diytomcat
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#然后直接在宿主机的test中发布网站即可</span>
</span></span></code></pre></div><p><strong>发布镜像到dockerhub和阿里云</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#先注册</span>
</span></span><span style="display:flex;"><span>https://hub.docker.com/
</span></span><span style="display:flex;"><span><span style="color:#75715e">#在宿主机登录</span>
</span></span><span style="display:flex;"><span>docker login -u XXX -p XXX
</span></span><span style="display:flex;"><span><span style="color:#75715e">#发布前先用tag命令修改为规范的镜像</span>
</span></span><span style="display:flex;"><span>docker tag 镜像id jack/diytomcat:1.0
</span></span><span style="display:flex;"><span>docker push jack/diytomcat:1.0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#提交的时候就是按照层级来发布的</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#先注册</span>
</span></span><span style="display:flex;"><span>https://www.aliyun.com/?spm<span style="color:#f92672">=</span>5176.12901015.ahjq0uaqt.1.a8fd525cv7uh0R
</span></span><span style="display:flex;"><span><span style="color:#75715e">#找到容器镜像服务</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#创建命名空间（一个账号只能创建三个）</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#创建镜像仓库</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#之后阿里云会有官方详细步骤</span>
</span></span><span style="display:flex;"><span>docker login XXXXXXXXXXXXXXX
</span></span><span style="display:flex;"><span>docker tag XXXXXXXXXXXXX
</span></span><span style="display:flex;"><span>docker push jack/diytomcat:1.0
</span></span></code></pre></div><p><strong>docker所有流程</strong></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201121084949.png" alt=""></p>
<h2 id="docker网络容器编排集群部署">Docker网络（容器编排，集群部署）</h2>
<p><strong>docker网络模式</strong>：有如下四种：</p>
<p>host模式(&ndash;net=host)      container模式         none模式(&ndash;net=none)          bridge模式(&ndash;net=bridge)</p>
<p><strong>host模式</strong>： 需要使用<strong>docker run</strong>是指定： <strong>&ndash;net=host</strong>   使用的网络实际上和宿主机是一样,在容器内的IP和宿主机的IP是一样,类似于<strong>vmare桥接模式</strong>；</p>
<p>container模式：使用 <strong>&ndash;net=container:container_id/container_name</strong>，多个容器使用共同的网络,看到的IP是一样的；</p>
<p>none模式： -<strong>-net=none</strong>  这种模式下,不会配置任何网络；</p>
<p><strong>bridge模式</strong>：<strong>&ndash;net=bridge</strong>，不指定是默认也是这种模式，这种模式会为每个容器分配一个独立的network 网卡，同一个宿主机是在同一个网段下可以通信的，类似于 <strong>VMware 的 NAT模式</strong>；</p>
<p><strong>桥接模式</strong>（类似于vm的nat模式）</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p><strong>host模式</strong>（类似于vm的桥接模式）</p>
<!-- raw HTML omitted -->
<p><strong>两个docker网络如何通信呢？</strong></p>
<ul>
<li>一台bai计算机是可以有多个IP地址的，如果我们给一台du服务器绑定两个以上zhiIP地址dao，其中一个IP地址在一个网段中(如192.168.1.0)，另一个IP地址在另一个网段中(如192.168.2.0)，如果给服务器提供路由功能，这两个IP地址充当网关，就可以把两个网段连接在一起了。</li>
</ul>
<p><strong>接下来是实战：Docker Compose，Docker Swarm，CI/CD Jenkins</strong></p>
<h2 id="devops">DevOps</h2>
<!-- raw HTML omitted -->
<p><strong>DevOps（Development和Operations</strong>的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p>
<p>它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p>
<p>它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运维工作必须紧密合作。</p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201121111806.png" alt=""></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201121112357.png" alt=""></p>
<p><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20201121112358.png" alt=""></p>
</section>

  
  

  
  
  
  <nav
    class="mt-24 flex rounded-lg bg-black/[3%] p-1.5 text-lg dark:bg-white/[8%]"
  >
    
    <a
      class="flex w-1/2 items-center rounded-md p-6 pr-3 no-underline hover:bg-black/[2%]"
      href="https://yangfanjack.github.io/post/martin-fowler%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BA%E6%96%87%E8%AF%91%E6%96%87/"
      ><span class="mr-1.5">←</span><span>Martin Fowler关于微服务架构的论文译文</span></a
    >
    
    
    <a
      class="ml-auto flex w-1/2 items-center justify-end rounded-md p-6 pl-3 no-underline hover:bg-black/[2%]"
      href="https://yangfanjack.github.io/post/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"
      ><span>linux网络配置</span><span class="ml-1.5">→</span></a
    >
    
  </nav>
  

  
  
  <div class="mt-24" id="disqus_thread"></div>
  <script>
    const disqusShortname = 'Jack';
    const script = document.createElement('script');
    script.src = 'https://' + disqusShortname + '.disqus.com/embed.js';
    script.setAttribute('data-timestamp', +new Date());
    document.head.appendChild(script);
  </script>
  

  
  
  <div class="mt-24" id="graphcomment"></div>
  <script type="text/javascript">
    var __semio__params = {
      graphcommentId: 'YOUR_GRAPH_COMMENT_ID',
      behaviour: {
        
      },
      
    };

    function __semio__onload() {
      __semio__gc_graphlogin(__semio__params);
    }

    (function () {
      var gc = document.createElement('script');
      gc.type = 'text/javascript';
      gc.async = true;
      gc.onload = __semio__onload;
      gc.defer = true;
      gc.src =
        'https://integration.graphcomment.com/gc_graphlogin.js?' + Date.now();
      (
        document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]
      ).appendChild(gc);
    })();
  </script>
  
</article>


    </main>

    <footer
  class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"
>
  <div class="mr-auto">
    &copy; 2023
    <a class="link" href="https://yangfanjack.github.io/">My Hugo Site</a>
  </div>
  <a class="link mx-6" href="https://gohugo.io/" rel="noopener" target="_blank"
    >Powered by Hugo️️</a
  >️
  <a
    class="link"
    href="https://github.com/nanxiaobei/hugo-paper"
    rel="noopener"
    target="_blank"
    >▷ Paper 6</a
  >
</footer>

  </body>
</html>
