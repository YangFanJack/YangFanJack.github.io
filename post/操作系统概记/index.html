<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>操作系统概记 - Jack&#39;s Blog Site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Jack Yang" /><meta name="description" content="操作系统概述 什么是操作系统 计算机硬件和应用之间的一层软件 操作系统的五大管理功能： 进程管理（CPU管理） 存储管理（内存管理） 设备管理（磁盘管理" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.109.0 with theme even" />


<link rel="canonical" href="http://yangfanjack.top/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%B0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script src="https://cdn.jsdelivr.net/npm/eruda@1.2.6/eruda.min.js" integrity="sha256-Jmz4bc3kp+rRrXX2tGadNBKFLwtzMapr8kHABxSAAP8=" crossorigin="anonymous"></script>
<script>eruda.init();</script>

<link href="/sass/main.min.cb68f97bc9cece255d217346d970e3c62623408634e500c330a62fadabbbe77c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="操作系统概记" />
<meta property="og:description" content="操作系统概述 什么是操作系统 计算机硬件和应用之间的一层软件 操作系统的五大管理功能： 进程管理（CPU管理） 存储管理（内存管理） 设备管理（磁盘管理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://yangfanjack.top/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%B0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-04-25T21:23:52+08:00" />
<meta property="article:modified_time" content="2023-04-25T21:23:52+08:00" />
<meta itemprop="name" content="操作系统概记">
<meta itemprop="description" content="操作系统概述 什么是操作系统 计算机硬件和应用之间的一层软件 操作系统的五大管理功能： 进程管理（CPU管理） 存储管理（内存管理） 设备管理（磁盘管理"><meta itemprop="datePublished" content="2023-04-25T21:23:52+08:00" />
<meta itemprop="dateModified" content="2023-04-25T21:23:52+08:00" />
<meta itemprop="wordCount" content="7193">
<meta itemprop="keywords" content="操作系统," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统概记"/>
<meta name="twitter:description" content="操作系统概述 什么是操作系统 计算机硬件和应用之间的一层软件 操作系统的五大管理功能： 进程管理（CPU管理） 存储管理（内存管理） 设备管理（磁盘管理"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jack&#39;s Blog Site</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Jack&#39;s Blog Site</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">操作系统概记</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-04-25 </span>
        <div class="post-category">
            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> 学习笔记 </a>
            </div>
          <span class="more-meta"> 7193 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#操作系统概述">操作系统概述</a>
      <ul>
        <li><a href="#什么是操作系统">什么是操作系统</a></li>
        <li><a href="#开始揭开钢琴的盖子">开始揭开钢琴的盖子</a></li>
        <li><a href="#操作系统启动">操作系统启动</a></li>
        <li><a href="#操作系统接口">操作系统接口</a></li>
        <li><a href="#系统调用的实现">系统调用的实现</a></li>
        <li><a href="#操作系统历史">操作系统历史</a></li>
      </ul>
    </li>
    <li><a href="#进程管理和作业管理">进程管理和作业管理</a>
      <ul>
        <li><a href="#cpu管理的直接想法">CPU管理的直接想法</a></li>
        <li><a href="#多进程图像">多进程图像</a></li>
        <li><a href="#用户级线程">用户级线程</a></li>
        <li><a href="#内核级线程">内核级线程</a></li>
        <li><a href="#内核级线程实现">内核级线程实现</a></li>
        <li><a href="#操作系统之树">操作系统之“树”</a></li>
        <li><a href="#cpu调度策略">CPU调度策略</a></li>
        <li><a href="#一个实际的schedule函数">一个实际的schedule函数</a></li>
        <li><a href="#进程同步与信号量">进程同步与信号量</a></li>
        <li><a href="#信号量临界区保护">信号量临界区保护</a></li>
        <li><a href="#信号量的代码实现">信号量的代码实现</a></li>
        <li><a href="#死锁处理">死锁处理</a></li>
      </ul>
    </li>
    <li><a href="#存储管理">存储管理</a>
      <ul>
        <li><a href="#内存使用与分段">内存使用与分段</a></li>
        <li><a href="#内存分区与分页">内存分区与分页</a></li>
        <li><a href="#多级页表与快表">多级页表与快表</a></li>
        <li><a href="#段页结合的实际内存管理">段页结合的实际内存管理</a></li>
        <li><a href="#内存换入请求调页">内存换入——请求调页</a></li>
        <li><a href="#内存换出">内存换出</a></li>
      </ul>
    </li>
    <li><a href="#设备管理">设备管理</a>
      <ul>
        <li><a href="#io与显示器">I/O与显示器</a></li>
        <li><a href="#键盘">键盘</a></li>
        <li><a href="#生磁盘的使用">生磁盘的使用</a></li>
      </ul>
    </li>
    <li><a href="#文件管理">文件管理</a>
      <ul>
        <li><a href="#从生磁盘到文件">从生磁盘到文件</a></li>
        <li><a href="#文件使用磁盘的实现">文件使用磁盘的实现</a></li>
        <li><a href="#目录与文件系统">目录与文件系统</a></li>
        <li><a href="#目录解析代码实现">目录解析代码实现</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="操作系统概述">操作系统概述</h1>
<h2 id="什么是操作系统">什么是操作系统</h2>
<ul>
<li>计算机硬件和应用之间的一层软件</li>
<li>操作系统的五大管理功能：
<ul>
<li>进程管理（CPU管理）</li>
<li>存储管理（内存管理）</li>
<li>设备管理（磁盘管理）</li>
<li>文件管理</li>
<li>作业管理（终端管理）</li>
</ul>
</li>
<li>斯坦福学生的怎么学操作系统：
<ul>
<li>扩展线程：实现线程调度</li>
<li>实现系统调度：将整个接口剥掉，添加</li>
<li>实现虚存管理：扩展实现内存管理</li>
<li>扩展文件系统：扩展实现一个文件管理</li>
</ul>
</li>
<li>绝知此事要躬行</li>
</ul>
<h2 id="开始揭开钢琴的盖子">开始揭开钢琴的盖子</h2>
<ul>
<li>从通用图灵机到冯诺依曼的存储程序思想
<ul>
<li>将程序放进内存，用PC指针指向它，然后取值，执行，取值，执行&hellip;&hellip;</li>
</ul>
</li>
<li>计算机由五大部件组成：输入设备，输出设备，存储器，运算器，控制器</li>
<li>打开电源，计算机执行的第一句指令是什么？
<ul>
<li>开机时，CS=0xFFFF，IP=0x0000，寻址BIOS（0xFFFF0）（CS：段寄存器，IP：段内偏移）</li>
<li>BIOS程序检查内存，赋存，外设&hellip;</li>
<li>BIOS程序将磁盘0扇面0磁道0扇区读入地址：0x7c00</li>
<li>BIOS程序设置CS=0x07c0，IP=0x0000</li>
<li>开始分段读入整个操作系统：</li>
<li>开始执行引导扇区512字节的程序（硬盘的第一个扇区存放着开机后执行的第一段我们可以控制的程序）、</li>
<li>通过boot扇区读setup扇区：通过int 0x13中断读磁盘：从第2个扇区开始，读4个扇区</li>
<li>在boot扇区中通过int 0x10中断打印logo并读system模块</li>
<li>通过跳转指令跳转到setup扇区，交出控制权到setup扇区</li>
</ul>
</li>
<li>BIOS的主要功能是系统自检与初始化工作。它会对设备进行检测与初始化,设置运行环境,加载boot设备的第一个扇区到内存执行。Boot扇区的作用是准备系统环境,加载操作系统启动代码</li>
</ul>
<h2 id="操作系统启动">操作系统启动</h2>
<ul>
<li>setup模块：
<ul>
<li>setup将完成OS启动前的设置</li>
<li>读硬件参数存储到内存数据结构中</li>
<li>将system移动到0地址</li>
<li>初始化GDT表（GDT全局描述符表用于存储段描述符：基地址，限长，权限；IDT中断描述符表用于存储中断向量和中断处理程序入口点之间的映射；idt和gdt可以放在内存中任意位置，相关寄存器指向起始地址）</li>
<li>启动保护模式，跳转到0地址处</li>
</ul>
</li>
<li>保护模式：
<ul>
<li>操作系统启动过程中，CPU初始化后工作在实模式下，此时只有1MB的地址空间，不足以实现内存保护和虚拟内存等功能。</li>
<li>通过mov cr0，1进入保护模式：CPU、寄存器、地址线从16位切换到32位模式，段寄存器仍为16位，寻址方式改变，走另外一条电路，不再是CS*16+IP；CS里放的是段选择子，用于查gdt表项，取基址，再加偏移，查表是硬件实现的</li>
</ul>
</li>
<li>System模块：
<ul>
<li>操作系统源码通过Makefile编译为image</li>
<li>system中的第一个模块是head.s，完成初始化idt、gdt的工作，通过ret main从进入main函数</li>
<li>main.c完成初始化工作，如trap_init、mem_init，推出后进入死循环</li>
<li>mem_init初始化了mem_map页表</li>
</ul>
</li>
</ul>
<h2 id="操作系统接口">操作系统接口</h2>
<ul>
<li>接口就是用户和计算机的交互：命令行，图形按钮</li>
<li>命令行：shell程序在死循环中执行命令，命令就是一段程序</li>
<li>图形按钮：硬件输入存到系统消息队列中，通过消息循环GetMessage获取消息并处理</li>
<li>用户使用计算机的本质是通过程序，即普通c代码或者重要函数进入操作系统内核；操作系统提供的这类重要函数，就是操作系统接口，也叫系统调用</li>
</ul>
<h2 id="系统调用的实现">系统调用的实现</h2>
<ul>
<li>系统调用的作用：提供统一接口供上层使用；作为用户态通往内核态的大门。
<ul>
<li>内核中存储重要数据，不让用户态访问</li>
<li>用户态不能通过jmp到内核中，也不能通过mov指令访问内核数据</li>
</ul>
</li>
<li>隔离用户态和内核态的具体实现：
<ul>
<li>Intel的CPU提供了特权环机制实现特权级检查（硬件检查）</li>
<li>CPL（当前特权级）和DPL（描述符特权级）：在访问/跳转到一个目标内存区域（段）之时，只有CPL&lt;=DPL时，指令才能被执行</li>
<li>CPL位于CS段寄存器的最后两位，即当前指令所在段的特权级</li>
<li>DPL位是GDT表中的段描述符，即目标内存段的特权级</li>
</ul>
</li>
<li>系统调用进入内核态细节：中断是进入内核的唯一手段
<ul>
<li>系统调用的核心：就是一段包含中断的代码</li>
<li>系统调用的实现：应用程序调用printf-&gt;库函数printf-&gt;库函数write-&gt;系统调用write；系统调用write中包含软中断int 0x80，通过EAX寄存器的值选择具体的系统调用服务进行调用</li>
<li>细节：
<ul>
<li>IDT表初始化：sched_init——&gt;set_system_gate设置中断处理，向IDT表中写入system_call偏移地址，段选择符和DPL=3；由于DPL=3，所以当前指令能够执行，成功调用内核态函数system_call，并且CS段选择符被置为内核区域</li>
<li>int0x80中断的处理：在跳转中断处理程序时，DPL被强行置为3，成功跳转到内核态；跳转后CPL被置为0，可以访问任何内存区域；执行中断处理程序system_call</li>
<li>system_call：call _sys_call_table(, %eax, 4)，全局函数指针数组；通过eax传入系统调用号，找到sys_write；调用sys_write内核态函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="操作系统历史">操作系统历史</h2>
<ul>
<li>操作系统的接口可以分为5个层次：
<ol>
<li>硬件层：包括CPU、内存、存储设备、外部设备等。操作系统需要管理与调度硬件资源,为上层提供抽象接口</li>
<li>内核层：包括进程管理、内存管理、文件系统、设备管理等模块。内核层是操作系统的核心,负责系统资源的管理与调度</li>
<li>系统调用层：提供程序界面(API)让进程调用内核服务。系统调用层包括用于进程、文件、内存操作的函数接口</li>
<li>库层：封装底层的细节,提供更易用的函数接口给程序使用。库层包括C库、数学库、网络库等</li>
<li>应用层：包括用户程序、编译器等,最终为用户提供服务</li>
</ol>
</li>
<li>多进程图谱：CPU、内存，伴随着Unix的出现</li>
<li>文件操作图谱：文件、磁盘、IO，伴随着DOS/Windows的出现</li>
</ul>
<h1 id="进程管理和作业管理">进程管理和作业管理</h1>
<blockquote>
<p>插入一个对比：批处理操作系统&amp;分时操作系统；作业&amp;进程：</p>
</blockquote>
<ol>
<li>作业是批处理系统的执行单元，进程是分时交互性系统的执行单元</li>
<li>作业以非交互性和断续的方式执行，进程以交互性和并发的方式执行</li>
<li>作业执行时占用临时的物理空间，进程则有自己的虚拟地址空间</li>
<li>作业没有权限管理，进程可以为不同用户分配不同的权限</li>
<li>作业的调度主要依靠优先级，进程的调度更加复杂</li>
<li>任意时刻只有一个作业的程序在内存中执行，一个作业的执行通常需要分成多个段来完成,在两个执行段之间作业程序会被换出内存，高优先级作业的程序会抢占低优先级作业的内存空间执行，作业结束后,其程序及数据会从内存中删除,内存空间会被回收供下一个作业使用</li>
</ol>
<h2 id="cpu管理的直接想法">CPU管理的直接想法</h2>
<ul>
<li>CPU的核心，也是计算机的核心：取指执行</li>
<li>单程序系统的问题：遇到IO执行卡住，CPU利用率太低。解决方法就是内存中加载多程序，并进行不停切换，充分利用CPU资源。这也就需要PC等寄存器结构来保存程序运行中的信息，引入进程概念：运行中的程序，使用PCB来存放运行信息</li>
<li>CPU管理的核心：多进程并发执行</li>
</ul>
<h2 id="多进程图像">多进程图像</h2>
<ul>
<li>System模块中main函数，创建初始化进程，启动shell/图形化，在其中启动其他进程</li>
<li>操作系统使用PCB来组织多进程，将相应的PCB放到队列中：运行态，就绪态，阻塞态，终止态</li>
<li>多进程交替执行：将pCur指向的当前PCB放入阻塞队列，调用schedule函数通过getNext采用调度算法选择下一个PCB，并用pNew指向</li>
<li>多进程内存隔离：进程之间使用映射表实现进程间的内存隔离，解决了进程相互访问可能带来的问题</li>
<li>多进程的合作：生产者进程和消费者进程通过进程共享技术对某个数据进行操作，可能造成处理异常，需要通过给进程上锁实现进程同步</li>
</ul>
<h2 id="用户级线程">用户级线程</h2>
<ul>
<li>进程=内存资源（堆，代码区，全局区）+指令执行序列（PC指针、栈），所以进程的切换也分为两部分：指令和内存切换</li>
<li>线程共享内存资源，切换线程只需切换指令执行序列，保留并发的同时降低了切换代价</li>
<li>Chrome多标签采用多进程，Firefox多标签采用多线程</li>
<li>用户级线程的创建和切换：
<ul>
<li>TCB结构：
<ol>
<li>threadID：线程的唯一标识</li>
<li>status：线程的运行状态</li>
<li>register：线程关于CPU中寄存器的情况</li>
<li>PC程序计数器：线程执行的下一条指令的地址</li>
<li>优先级：线程在操作系统调度的时候的优先级</li>
<li>线程的专属存储区：线程单独的存储区域</li>
<li>用户栈：线程执行的用户方法栈，用来保存线程当前执行的用户方法的信息</li>
<li>内核栈：线程执行的内核方法栈，用来保存线程当前执行的内核方法信息</li>
</ol>
</li>
<li>创建Create：通过malloc动态分配内存创建TCB和栈，将函数地址压栈，TCB保存栈顶指针</li>
<li>切换Yield：每个线程都需要自己的栈，栈切换需要TCB保存栈顶指针，不需要主动切换PC，因为pc已经在栈里了（不用jmp，直接返回）</li>
<li>操作系统完全感知不到用户级线程，用户级线程阻塞时CPU会切换到另一进程，而不是另一用户级线程；内核级线程由操作系统托管，并发性能更好</li>
</ul>
</li>
</ul>
<h2 id="内核级线程">内核级线程</h2>
<ul>
<li>多处理器和多核的区别：多处理器是每个CPU都有一套Cache和MMU，多核是多个CPU公用一套Cache和MMU。只有内核级线程才能发挥多核特点。</li>
<li>内核级线程的创建：ThreadCreate系统调用，内核负责管理TCB、切换线程</li>
<li>每个内核级线程都是一套栈：用户栈&amp;内核栈；切换的时候用户栈和内核栈都切换</li>
<li>用户栈&amp;内核栈的关联：
<img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/2997171-20221003204454931-1793722551.png" alt="用户栈&amp;内核栈的关联">
对比用户级线程的切换使用TCB进行切换，核心级线程也用TCB切换，不过这个TCB在内核中，而且根据TCB的切换来切换一套栈，内核栈和用户栈都得切换</li>
<li>内核级线程切换的五段论：
<ol>
<li>线程Aint中断引发中断处理进入内核栈</li>
<li>read函数的中断处理函数使线程进入阻塞状态，引入CPU调度，调用schedule</li>
<li>schedule中根据调度策略找到另一个线程B的内核栈的指针,准备切换上下文，根据找到的TCB，调用switch_to</li>
<li>保存线程A的上下文到其TCB（寄存器状态、内核栈指针和用户栈指针），恢复线程B上下文，通过TCB进行线程B的内核栈切换</li>
<li>线程B执行,直到再次中断或被抢占,返回用户模式使用其用户栈，通过iret返回线程B的用户栈</li>
</ol>
</li>
<li>内核级线程的创建：创建TCB——&gt;创建用户栈和内核栈并关联——&gt;TCB指向内核栈顶——&gt;TCB进入队列</li>
</ul>
<h2 id="内核级线程实现">内核级线程实现</h2>
<p>以fork为例，通过中断进入内核，复制了一份子进程后退出内核</p>
<ul>
<li>切换
<ul>
<li>schedule</li>
<li>linux0.1使用TSS而不是TCB内核栈切换</li>
<li>linux0.1通过长跳转指令进行切换，因为不能使用指令流水所以很慢（ljmp：把当前CPU的寄存器现场放到TSS中，根据TSS(n)找到新TSS，覆盖到CPU的寄存器上）</li>
<li>EIP也通过TSS覆盖，没有用到栈传递</li>
</ul>
</li>
<li>创建
<ul>
<li>_sys_fork中调用了_copy_process，将当前所有寄存器作为参数传入</li>
<li>申请一页内存作为PCB和TSS</li>
<li>在PCB上方创建内核栈并用tss-&gt;esp0指向栈顶</li>
<li>和父进程共用一个用户栈，并用tss-&gt;esp指向栈顶</li>
<li>tss的eip和cs通过传入参数赋值，eax置为0（作为子进程的返回值）</li>
</ul>
</li>
<li>执行目标代码
<ul>
<li>子进程调用exec(cmd)函数</li>
<li>调用sys_execve系统调用，进入内核态</li>
<li>调用do_execve，将内核栈的ret_eip置为cmd程序的入口地址（从可执行文件的head处读取，SS：SP处被置为新的用户栈顶</li>
<li>iret返回后，执行目标程序代码</li>
</ul>
</li>
</ul>
<h2 id="操作系统之树">操作系统之“树”</h2>
<p>操作系统的核心就是：CPU管理和内存管理</p>
<ul>
<li>实现在屏幕交替打出A和B
<ul>
<li>父进程进入内核，将两个子进程的PCB创建好，并修改tss-eip为打印A和打印B</li>
<li>父进程执行到wait时阻塞，进入内核调用schedule，调度策略选择next，通过执行switch_to(next)将目标子进程的tss覆盖到当前CPU寄存器，切换到子进程</li>
<li>两个子进程之间利用时钟中断进入内核，分配时间片counter，为0的时候调用schedule切换tss进而切换进程</li>
</ul>
</li>
</ul>
<h2 id="cpu调度策略">CPU调度策略</h2>
<ul>
<li>前台任务（I/O约束性任务）关注响应时间，后台任务（CPU约束性任务）关注周转时间</li>
<li>任务响应时间和任务周转时间存在一定的矛盾关系：提高响应时间可能会导致切换次数多，减少任务可用处理器时间,从而降低系统吞吐量</li>
<li>最简单的CPU调度策略：FCFS，会导致任务集的平均周转时间很长。</li>
</ul>
<h2 id="一个实际的schedule函数">一个实际的schedule函数</h2>
<h2 id="进程同步与信号量">进程同步与信号量</h2>
<h2 id="信号量临界区保护">信号量临界区保护</h2>
<h2 id="信号量的代码实现">信号量的代码实现</h2>
<h2 id="死锁处理">死锁处理</h2>
<h1 id="存储管理">存储管理</h1>
<h2 id="内存使用与分段">内存使用与分段</h2>
<ul>
<li>编译时重定位，载入时重定位，运行时重定位
<ul>
<li>编译时重定位在编译结束前完成，只能放到固定位置</li>
<li>载入时重定位在程序载入内存前完成，不能满足换入换出的需求</li>
<li>运行时重定位随程序执行持续进行，每执行一条指令都要从逻辑地址计算出物理地址（地址翻译），基址放到PCB中，进程运行时赋值给基地址寄存器</li>
</ul>
</li>
<li>分段：
<ul>
<li>将程序按照功能划分为不同段，分段放入内存</li>
<li>段表：用来保存每个段的地址，包括段号，段基址，长度和段属性</li>
<li>操作系统的段表叫GDT，每个进程的段表叫LDT</li>
<li>载入时将LDT赋值给PCB，进程运行时再由PCB进行重定位修改LDT的值，重新计算各段指令的物理地址</li>
</ul>
</li>
</ul>
<h2 id="内存分区与分页">内存分区与分页</h2>
<ul>
<li>内存分区：
<ul>
<li>内存分区是段的存放载体，程序的各个段载入到相应的内粗分区</li>
<li>可变分区算法：最先适配，最差适配，最佳适配</li>
</ul>
</li>
<li>分页：
<ul>
<li>采用内存分区+分段的方式很容易造成内存碎片的问题，为了解决这个问题，引入了分页</li>
<li>分区用于虚拟内存的划分，分页用于物理内存的划分</li>
<li>将每个段分成多个4K的页</li>
<li>通过逻辑地址根据段表计算出虚拟地址，再通过虚拟地址根据页表计算出物理地址</li>
<li>页表：保存页号和页框的对应关系，CR3寄存器用于存储页目录表的物理基地址（页框是对内存进行分框，页是对进程进行分页）</li>
</ul>
</li>
</ul>
<h2 id="多级页表与快表">多级页表与快表</h2>
<ul>
<li>问题所在：
<ul>
<li>页存在的目的就是为了充分利用空间，所以页很小，导致页数量激增，页表异常大</li>
<li>但是每个进程实际上只用到了很小部分的页，大部分的页是用不到的；解决方法如果是只存放用到的页表项，页表查找很费时，所以不行，页表项必须连续存放，那怎么办呢？答案就是多级页表</li>
</ul>
</li>
<li>多级页表：
<ul>
<li>通过“页目录表”和“页表”形成多杰页表查找，通过页目录表为用到的页表提供索引，没用到的页表无需放入内存；这样既保证了页表项连续存放，又能减少页表对内存空间的占用</li>
<li>在32位地址空间下，多级页表一般采用2级结构：10+10+12
<ul>
<li>第1级是页目录表：定义1k个4字节的目录项，对应4G虚拟地址空间</li>
<li>第2级是页表：定义1k个4字节的页表项，对应4M虚拟地址空间</li>
<li>页框大小固定4KB，存储实际数据或指令</li>
</ul>
</li>
<li>图示：
<img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/2997171-20221003204723030-397309585.png" alt="2级页表页式内存管理"></li>
</ul>
</li>
<li>快表：
<ul>
<li>多级页表能减少内存的占用，但增加了访存次数，故引入了TLB</li>
<li>TLB是一组快速存储寄存器，保存经常用到的页表项，通过硬件实现查找</li>
<li>TLB命中直接取TLB中的页表项对应的物理内存，未命中通过多级页表补充查找</li>
<li>TLB页表项很少的理论依据：程序的空间局部性原理</li>
<li>TLB和Cache的区别：
<ul>
<li>功能上：Cache是数据缓冲区，加速CPU的数据读取；TLB是地址翻译缓冲区，加速地址翻译映射</li>
<li>粒度上：Cache粒度大，以64字节为Cache行进行数据映射；TLB粒度小，以4字节为页地址进行地址映射</li>
<li>类型上：Cache是数据映射，TLB是地址映射</li>
<li>硬件实现上：Cache通常再CPU芯片上实现；TLB通常在MMU中实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="段页结合的实际内存管理">段页结合的实际内存管理</h2>
<ul>
<li>操作系统的虚拟内存：用户角度的段式和物理内存角度的页式，使用内存需要经过两次地址翻译</li>
<li>以fork为例介绍一个实际的段页式内存管理：
<ul>
<li>分配虚存，建段表</li>
<li>分配内存，建页表</li>
<li>父子进程共用同一个物理页（并设置为Read Only），子进程按照虚拟地址换算来建立新的顶级页表项，并分配内存建立新的二级页表，并拷贝父进程的二级页表</li>
<li>修改新进程的CR3寄存器</li>
<li>为共享的页框增加引用计数，表示该页框同时被多个进程共享和使用</li>
<li>处理写时复制。如果原进程对共享的页框进行写操作,就会触发写时复制,产生该页框的独立副本给新进程使用,并更新对应的页表项和引用计数</li>
</ul>
</li>
<li>父子进程共享物理页主要是指用户空间,利用写时复制机制来节省内存并实现共享执行环境。而内核空间仍然是相互隔离的,以维护内核空间的安全性和正确性</li>
</ul>
<h2 id="内存换入请求调页">内存换入——请求调页</h2>
<ul>
<li>分段分页内存管理的核心是虚拟内存，虚拟内存的核心是内存换入换出</li>
<li>虚拟地址=线性地址</li>
<li>用内存的换入换出实现比物理内存更大的内存（虚拟地址空间大于物理地址空间的实现机理就是多个虚拟内存页绑定同一个物理内存页框）</li>
<li>内存换入的核心：缺页中断从磁盘读入缺页到内存空间</li>
<li><img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/2997171-20221003204827814-539911125.png" alt="缺页中断-请求调页"></li>
<li>处理缺页中断（do_no_page）
<ul>
<li>获取物理空闲页：<code>page=get_free_page()</code></li>
<li>从磁盘设备读入到物理页：<code>bread_page(page, current-&gt;executable-&gt;i_dev, )</code></li>
<li>虚拟地址和物理页关联：<code>put_page(page, address)</code></li>
</ul>
</li>
</ul>
<h2 id="内存换出">内存换出</h2>
<ul>
<li>内存有限，不可能一直get_free_page，有进就有出，内存不够了需要按照页面置换算法选择一页淘汰，换出到磁盘</li>
<li>页面置换算法：目标是降低缺页次数
<ul>
<li>FIFO：先进来的先置换</li>
<li>MIN：选择未来最远使用的页置换，理想最优方案，但由于不能未卜先知，所以只能依据程序的时间局部性原理设计出LRU算法（假设最近访问过的页面在不远的将来很可能再次访问,所以应该保留在内存中）</li>
<li>LRU：最近最少使用，Least Recently Used
<ul>
<li>两种精确实现方案：每页维护一个时间戳、维护一个页码栈，时间代价都很高，所以采用LRU的高效率近似算法：Clock算法</li>
</ul>
</li>
<li>Clock：
<ul>
<li>将时间计数变为0或1，表示是或否，记录最近一段时间是否使用；这样每次访问页就可以顺便写入并且只用修改一位，时间代价很低、</li>
<li>缺页的时候转动指针，为1置为0继续转动，为0换出</li>
<li>当缺页很少时，退化为FIFO算法：因为当几乎不发生缺页中断的时候，指针不会转动，所以指针会很长时间都不会做转动，这和LRU中的最近矛盾，所以需要对算法做出改进</li>
<li>再增加一个定时清除R位的扫描指针
<img src="https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/2997171-20221003204916919-1871172492.png" alt="Clock算法"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="设备管理">设备管理</h1>
<h2 id="io与显示器">I/O与显示器</h2>
<h2 id="键盘">键盘</h2>
<h2 id="生磁盘的使用">生磁盘的使用</h2>
<h1 id="文件管理">文件管理</h1>
<h2 id="从生磁盘到文件">从生磁盘到文件</h2>
<h2 id="文件使用磁盘的实现">文件使用磁盘的实现</h2>
<h2 id="目录与文件系统">目录与文件系统</h2>
<h2 id="目录解析代码实现">目录解析代码实现</h2>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Jack Yang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-04-25
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%B1%87%E7%BC%96%E5%85%A5%E9%97%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">汇编入门</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%B0/">
            <span class="next-text nav-default">计算机组成原理概记</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:yangfanjack1024@qq.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/yangfanjack" class="iconfont icon-github" title="github"></a>
      <a href="https://space.bilibili.com/383186587" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://yangfanjack.top/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>Jack Yang</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
