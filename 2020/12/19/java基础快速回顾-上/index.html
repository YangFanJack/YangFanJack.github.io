<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>java基础快速回顾-上 - JACK&#039;s BLOG</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="JACK&#039;s BLOG"><meta name="msapplication-TileImage" content="/image/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JACK&#039;s BLOG"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java是一门纯粹的面向对象的高级的平台无关的编程语言"><meta property="og:type" content="blog"><meta property="og:title" content="java基础快速回顾-上"><meta property="og:url" content="https://jack1024.link/2020/12/19/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/"><meta property="og:site_name" content="JACK&#039;s BLOG"><meta property="og:description" content="Java是一门纯粹的面向对象的高级的平台无关的编程语言"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://gitee.com/yangfanjack/blogimage/raw/master/img/20210101162218.jpg"><meta property="article:published_time" content="2020-12-19T07:08:49.000Z"><meta property="article:modified_time" content="2021-06-16T10:27:58.861Z"><meta property="article:author" content="Jack1024"><meta property="article:tag" content="笔记"><meta property="article:tag" content="Java"><meta property="article:tag" content="JavaSE"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://gitee.com/yangfanjack/blogimage/raw/master/img/20210101162218.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jack1024.link/2020/12/19/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/"},"headline":"java基础快速回顾-上","image":["https://gitee.com/yangfanjack/blogimage/raw/master/img/20210101162218.jpg"],"datePublished":"2020-12-19T07:08:49.000Z","dateModified":"2021-06-16T10:27:58.861Z","author":{"@type":"Person","name":"Jack1024"},"publisher":{"@type":"Organization","name":"JACK's BLOG","logo":{"@type":"ImageObject","url":"https://jack1024.link/image/logoko.png"}},"description":"Java是一门纯粹的面向对象的高级的平台无关的编程语言"}</script><link rel="canonical" href="https://jack1024.link/2020/12/19/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/"><link rel="icon" href="/image/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JACK's BLOG" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/image/logoko.png" alt="JACK&#039;s BLOG" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20210101162218.jpg" alt="java基础快速回顾-上"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-12-19T07:08:49.000Z" title="2020-12-19 3:08:49 ├F10: PM┤">2020-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-06-16T10:27:58.861Z" title="2021-6-16 6:27:58 ├F10: PM┤">2021-06-16</time></span><span class="level-item"><a class="link-muted" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="level-item">32 minutes read (About 4859 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">java基础快速回顾-上</h1><div class="content"><h2 id="java语言开发环境搭建"><a href="#java语言开发环境搭建" class="headerlink" title="java语言开发环境搭建"></a>java语言开发环境搭建</h2><h3 id="java虚拟机——JVM"><a href="#java虚拟机——JVM" class="headerlink" title="java虚拟机——JVM"></a>java虚拟机——JVM</h3><ul>
<li>实质就是翻译，把.class文件翻译成计算机能认识的机器语言</li>
<li>java所谓的跨平台指的是java程序跨平台。JVM不是跨平台的，各个平台（Windows，Linux，mac）的JVM是不同的。</li>
<li><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201219152513.png" style="zoom:80%;" /></li>
<li><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201219153329.jpeg" style="zoom: 80%;" /></li>
<li><strong>Java这个语言很非凡。</strong><br>一、你可以说它是<strong>编译型</strong>的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。<br>二、你可以说它是<strong>解释型</strong>的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 </li>
</ul>
<h3 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h3><ul>
<li>JRE：java Runtime Environment，包含JVM和运行时需要的核心类库</li>
<li>JDK：java Development Kit，是java程序开发工具包，包含JRE和开发人员使用的工具</li>
<li>想要运行一个已有的java程序，那么只需安装JRE即可；想要开发一个全新的java程序，那么必须安装JDK</li>
</ul>
<img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201219152929.png" style="zoom:80%;" />

<h3 id="配置JDK环境变量"><a href="#配置JDK环境变量" class="headerlink" title="配置JDK环境变量"></a>配置JDK环境变量</h3><ul>
<li>在全局系统变量中2个操作<ul>
<li>新建JAVA_HOME变量：（jdk的安装路径）</li>
<li>修改Path：添加%JAVA_HOME%\bin</li>
</ul>
</li>
</ul>
<h2 id="HelloWorld入门程序"><a href="#HelloWorld入门程序" class="headerlink" title="HelloWorld入门程序"></a>HelloWorld入门程序</h2><h3 id="程序开发步骤"><a href="#程序开发步骤" class="headerlink" title="程序开发步骤"></a>程序开发步骤</h3><ul>
<li>java程序开发三步骤：<strong>编写</strong>——》.java——》<strong>编译</strong>（编译器javac.exe）——》.class——》<strong>运行</strong>（JVM解释执行：java.exe）</li>
<li>新建文件名为HelloWorld的java文件，编辑：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;<span class="comment">//public的类名必须和文件名完全一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//编译</span><br><span class="line">javac HelloWorld.java</span><br><span class="line">//JVM解释执行</span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>

<h3 id="HelloWorld程序说明"><a href="#HelloWorld程序说明" class="headerlink" title="HelloWorld程序说明"></a>HelloWorld程序说明</h3><ul>
<li>单行注释，多行注释：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*多行注释*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>public static void main(String[] args)</code>是程序入口</li>
</ul>
<h3 id="关键字说明：java中有特殊含义的保留字"><a href="#关键字说明：java中有特殊含义的保留字" class="headerlink" title="关键字说明：java中有特殊含义的保留字"></a>关键字说明：java中有特殊含义的保留字</h3><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201219161346.png" style="zoom:80%;" />

<h3 id="标识符："><a href="#标识符：" class="headerlink" title="标识符："></a>标识符：</h3><ul>
<li>指的是在程序中，我们自定义的内容中，如类的名字，方法的名字，变量的名字等都是标识符，</li>
<li>命名规则（硬性要求）<ul>
<li>标识符可以包含：<strong>英文字符，数字，$符，_下划线</strong></li>
<li>标识符不能以数字开头</li>
<li>标识符不能是关键字</li>
</ul>
</li>
<li>命名规范（软性要求）<ul>
<li>类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）</li>
<li>变量名规范：首字符小写，后面每个单词首字母小写（小驼峰式）</li>
<li>方法名规范：同变量名</li>
</ul>
</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li>概念：在程序运行期间固定不变的量</li>
<li>分类：<ul>
<li>字符串常量：双引号引起来的</li>
<li>整数常量：直接写上的数字，没有小数点</li>
<li>浮点数常量：直接写上的数字，有小数点</li>
<li>字符常量：单引号引起来的单个字符，有且仅有一个字符</li>
<li>布尔常量：true或者false</li>
<li>空常量：null，代表没有任何数据</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li>字符串，数组，类，接口，Lambda等</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>整数型：byte，short，int，long</li>
<li>浮点型：float，double</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
<img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201219182115.png" style="zoom:67%;" />

<p>注意事项：</p>
<ul>
<li>字符串不是基本类型，是引用类型</li>
<li>浮点型可能只是一个近似值</li>
<li>数据范围与字节数不一定相关</li>
<li>浮点数默认是double，float需要加后缀F</li>
<li>整数默认是int，long需要加上后缀L</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>程序运行期间，内容可以发生改变的量</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称; <span class="comment">//创建一个变量</span></span><br><span class="line">变量名称 = 数据值; <span class="comment">//赋值</span></span><br><span class="line">数据类型 变量名称 = 数据值; <span class="comment">//一步到位</span></span><br></pre></td></tr></table></figure></li>
<li><p>局部变量没有默认值，没有进行赋值不能直接使用</p>
</li>
<li><p>变量使用不能超过作用域（从定义变量开始，一直到直接所属的大括号结束为止）的范围</p>
</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul>
<li>当等号两边的数据类型不一致时，将会发生数据类型转化，分为自动类型转换（隐式）&amp;强制类型转换（显式）</li>
</ul>
<h3 id="自动转换（隐式）"><a href="#自动转换（隐式）" class="headerlink" title="自动转换（隐式）"></a>自动转换（隐式）</h3><ul>
<li>规则：数据范围小的转化为大的。与字节数不一定相关。</li>
</ul>
<h3 id="强制转换（显式）"><a href="#强制转换（显式）" class="headerlink" title="强制转换（显式）"></a>强制转换（显式）</h3><ul>
<li>规则：范围小的类型 范围小的变量名 = （范围小的类型）范围大的数据</li>
<li>整形强制转换可能发生数据溢出：long——》int</li>
<li>浮点型强制转换可能精度损失：double——》int</li>
<li>byte/short/char三种类型都可以发生数学运算，在运算时首先会提升为int，再进行运算</li>
<li>boolean类型不能发生任何数据类型转换</li>
</ul>
<h2 id="ASCII-amp-Unicode"><a href="#ASCII-amp-Unicode" class="headerlink" title="ASCII&amp;Unicode"></a>ASCII&amp;Unicode</h2><ul>
<li>48代表’0’，65代表’A’，97代表’a’</li>
<li>数字和字符的对照关系表：是ASCII码表（American Standard Code for Information Interchange）</li>
<li>Unicode码表（万国码）：也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始含有更多字符，包含中文字符。</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>运算符：运算特定操作的符号</p>
</li>
<li><p>表达式：用运算符连起来的式子叫做表达式</p>
</li>
<li><p>运算符分类：</p>
<ul>
<li><p>算数运算符：+，-，*，/，%，++，–</p>
<ul>
<li>如果运算中有不同类型的数据，那么结果将会是数据类型范围大的那种（类型自动转换）</li>
<li>加法：对于数值来说，就是数学加法；对于char来说，先按照ascii或unicode提升为int，然后再计算；对于String来说，是字符串的连接操作。</li>
<li>任何数据类型和字符串进行加法操作时，结果都会连接变成字符串。</li>
<li>常量不能使用自增or自减</li>
</ul>
</li>
<li><p>赋值运算符：</p>
<ul>
<li><p>=，+=，-=，*=，/=，%=</p>
</li>
<li><p>只有变量才能写在赋值运算符左边</p>
</li>
<li><p>复合赋值运算符隐含了一个强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> num = <span class="number">30</span>;</span><br><span class="line">num += <span class="number">5</span>;<span class="comment">//num = (byte) (int + int)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>比较运算符：</p>
<ul>
<li>==，&lt;，&gt;，&lt;=，&gt;=，!=</li>
<li>比较运算符的结果一定是一个boolean值</li>
<li>多次判断不能连着写</li>
</ul>
</li>
<li><p>逻辑运算符：</p>
<ul>
<li>&amp;&amp;，||，！</li>
<li>&amp;&amp;和||具有短路效果，从而节省一定的性能</li>
<li>逻辑运算符只能用于boolean值</li>
<li>&amp;&amp;和||可以连续写</li>
<li>对于<code>1&lt;x&lt;3</code>的连续情况，应该拆分为两个部分，然后使用运算符连接起来<code>1&lt;x&amp;&amp;x&lt;3</code></li>
</ul>
</li>
<li><p>三元运算符：</p>
<ul>
<li>格式：数据类型 变量名称 = 条件判断？表达式A：表达式B</li>
<li>条件判断true，表达式A的值赋给变量；条件判断false，表达式B的值赋给变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>引入：先把握整体，再把握局部</p>
</li>
<li><p>方法的定义</p>
<ul>
<li><p>方法定义的<strong>先后顺序无所谓</strong></p>
</li>
<li><p>方法定义必须是挨着的，不能在一个方法的内部定义另一个方法</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名称(参数类型 参数名称,...)&#123;</span><br><span class="line">    方法体;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法的调用</p>
<ul>
<li><p>方法定义后要执行需要在另一个方法中调用</p>
</li>
<li><p>三种调用格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独调用</span></span><br><span class="line">方法名称(参数);</span><br><span class="line"><span class="comment">//打印调用</span></span><br><span class="line">System.out.println(方法名称(参数));</span><br><span class="line"><span class="comment">//赋值调用</span></span><br><span class="line">数据类型 变量名称 = 方法名称(参数);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法三要素：返回值，方法名称，参数列表</p>
</li>
<li><p>return两个作用：结束方法执行；返回一个返回值。</p>
</li>
<li><p>方法注意事项：</p>
<ul>
<li>方法应该定义在类当中，不能在方法中定义方法。</li>
<li>如果方法有返回值，必须写上return 返回值;</li>
<li>如果方法返回值类型为void，可以不写return语句，或者写return;（此时return是结束方法的作用）</li>
<li>return 后面的值类型必须和方法的返回值类型对应</li>
<li>一个方法中可以有多个return语句，但是必须保证一次执行只有一个会被执行到</li>
</ul>
</li>
</ul>
<h2 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h2><ul>
<li>Java Shell工具（JShell）是一个用于学习Java编程语言和Java代码原型的交互式工具。JShell是一个Read-Evaluate-Print循环（REPL），它在输入时评估声明，语句和表达式，并立即显示结果。该工具从命令行运行。</li>
</ul>
<h2 id="编译器的两点优化"><a href="#编译器的两点优化" class="headerlink" title="编译器的两点优化"></a>编译器的两点优化</h2><ul>
<li>对于byte/short/char三种类型来说，如果右侧赋值数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)/(short)/(char)；如果右侧超过了左侧范围，那么会直接编译器报错</li>
<li>在给变量赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul>
<li>单if</li>
<li>if ；else</li>
<li>if ；else if；else if；else</li>
<li>switch ；case break；default [break]<ul>
<li>最后一个break语句可以省略，但是一般不省略</li>
<li>switch后面的小括号中之只能是byte/short/char/int/String/enum枚举</li>
<li>switch语句格式可以很灵活，前后顺序可以颠倒。匹配哪一个case就从哪一个位置向下执行，直到遇到break或者整体结束为止。</li>
<li>如果执行到某个case且该case没有break，会穿透它下面的那个case</li>
</ul>
</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul>
<li><p>循环结构一般分为<strong>四部分</strong>：</p>
<ul>
<li>初始化语句：在循环开始最初执行，而且只执行一次</li>
<li>条件判断：如果成立循环继续，否则循环退出</li>
<li>循环体：重复要做的内容，若干语句</li>
<li>步进语句：每次循环后的扫尾工作</li>
</ul>
</li>
<li><p>for语句：</p>
<ul>
<li><p>结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;条件判断布尔表达式;步进表达式)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>while语句</p>
<ul>
<li><p>结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(条件判断)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>do-while语句</p>
<ul>
<li><p>结构：无条件执行第一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="三种循环区别"><a href="#三种循环区别" class="headerlink" title="三种循环区别"></a>三种循环区别</h3><ul>
<li>如果条件判断从来没有满足过，那么for和while执行0次，但是do-while<strong>至少</strong>会执行1次</li>
<li>for循环的变量定义在小括号中，那么循环内部才能使用</li>
<li>次数确定用for循环，否则多用while循环</li>
</ul>
<h3 id="break关键字和continue关键字"><a href="#break关键字和continue关键字" class="headerlink" title="break关键字和continue关键字"></a>break关键字和continue关键字</h3><ul>
<li>break用在switch中：一旦执行，整个switch立刻结束</li>
<li>break用在循环中：一旦执行，break的外第一层循环语句立刻结束</li>
<li>continue用在循环中：一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环</li>
</ul>
<h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><p><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201220205132.png"></p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><ul>
<li>对于功能类似的方法来说，因为参数列表不同却需要不同的方法名，太麻烦，所以引入了方法的重载。</li>
<li>方法的重载（override），<strong>多个方法的方法名一样，但是参数列表不一样</strong>。只需一个方法名，就可以实现多个功能</li>
<li>所谓的参数列表不一样，指的是：<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
<li>但是和“参数名称，返回值类型，方法修饰符”无关</li>
</ul>
</li>
<li>Java中的典型重载：<code>System.out.println()</code>方法</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>概念：一种容器，可以同时存放多个同类型数据</p>
</li>
<li><p>特定：</p>
<ul>
<li>是一种引用类型</li>
<li>数组中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行中不可改变</li>
</ul>
</li>
<li><p>数组的初始化：在内存中创建一个数组，并且向其中赋予一位默认值</p>
<ul>
<li><p>动态初始化：指定长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[数组长度];</span><br><span class="line"><span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];</span><br><span class="line">String[] stringA = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>静态初始化：指定内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据类型[] 数组名称 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String[] stringA = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态初始化的省略格式</span></span><br><span class="line">数据类型[] 数组名称 = &#123;元素<span class="number">1</span>,元素<span class="number">2.</span>..&#125;;</span><br><span class="line">String[] stringA = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>注意：</strong></p>
<ul>
<li><p>静态初始化没有直接指定长度，但是可以根据大括号里的元素的具体内容直接推算出长度</p>
</li>
<li><p>静态初始化&amp;动态初始化的标准格式可以差分为两个步骤，但是静态初始化的省略格式不能拆分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] array1;</span><br><span class="line">array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>直接打印数组名，得到的是数组对应的内存地址哈希值</p>
</li>
<li><p>访问数组元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arrayA = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">System.out.println(arrayA[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p>如果<strong>动态初始化</strong>数组的时候，元素会自动拥有<strong>默认值</strong>，规则如下：</p>
<ul>
<li>整数类型：0</li>
<li>浮点类型：0.0</li>
<li>字符类型：’\u0000’</li>
<li>布尔类型：false</li>
<li>引用类型：null</li>
</ul>
</li>
<li><p><strong>静态初始化也有默认值</strong>，只是系统自动马上将默认值的替换成为了大括号当中的具体数值</p>
</li>
<li><p>数组经常遇到的问题：</p>
<ul>
<li><p>数组索引越界异常：<code>ArrayIndexOutOfBoundsException</code></p>
</li>
<li><p>```java<br>//未初始化<br>int[] array1;<br>System.out.println(array1[0]);</p>
<p>//空指针异常NullPointerExcetion<br>int[] array2 = null;<br>System.out.println(array2[0]);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 获取数组长度：`数组名称.length`；数组一旦创建，程序运行期间+长度不可改变</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  for(int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">      System.out.println(array[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遍历数组：就是对数组中每一个元素进行逐一处理。</p>
</li>
<li><p>数组作为<strong>方法参数</strong>和<strong>方法返回值</strong>：</p>
<ul>
<li>当调用方法的时候，向方法小括号传递的参数实际上是<strong>数组的地址值</strong></li>
<li>任何数据类型都能作为方法的参数类型和返回值类型，数组作为参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    printArray(array);<span class="comment">//传进去的就是一个地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] result = calculator(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    System.out.println(result[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(result[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        System.out.println(array[i]);<span class="comment">//地址值[i]使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] calculate(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">int</span> avg = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    array[<span class="number">0</span>] = sum;</span><br><span class="line">    array[<span class="number">1</span>] = avg;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>java类的成员变量new的时候会有初始值，但是方法中的局部变量不会有初始值。这条性质能用java的内存模型来解释。</p>
<ul>
<li><strong>栈：</strong>存放的是方法中的局部变量<ul>
<li>局部变量：方法的参数，方法内部的变量，局部变量有作用域，一旦超出作用域，立刻从栈内存中消失</li>
</ul>
</li>
<li><strong>堆：</strong>凡是new出来的东西，都在堆中<ul>
<li>堆内存中的数据都有默认值：整数类型：0；浮点类型：0.0；字符类型：’\u0000’；布尔类型：false；引用类型：null</li>
</ul>
</li>
<li><strong>方法区：</strong>存储.class相关信息，包含方法的信息，包括static方法&amp;变量，类加载器classloader。<ul>
<li>注意：方法区只是包含了方法固定的相关信息，但是方法真正运行的数据都在栈中</li>
</ul>
</li>
<li><strong>本地方法栈：</strong>：与操作系统相关</li>
<li><strong>寄存器：</strong>与CPU相关</li>
</ul>
<img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20210101180659.png" style="zoom:80%;" />

<p>数组内存图：</p>
<img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201221092337.png" style="zoom: 67%;" />

<img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20201221092837.png" style="zoom:67%;" />

<h3 id="使用对象类型作为方法的参数-amp-返回值"><a href="#使用对象类型作为方法的参数-amp-返回值" class="headerlink" title="使用对象类型作为方法的参数&amp;返回值"></a>使用对象类型作为方法的参数&amp;返回值</h3><ul>
<li>当一个对象or数组作为参数，传递到方法中时，实际上传递的是对象or数组的地址值</li>
<li>当一个对象or数组作为返回值时，实际上返回的是对象or数组的地址值</li>
</ul>
<h3 id="局部变量-and-成员变量"><a href="#局部变量-and-成员变量" class="headerlink" title="局部变量 and 成员变量"></a>局部变量 and 成员变量</h3><table>
<thead>
<tr>
<th></th>
<th>定义位置</th>
<th>作用域</th>
<th>默认值</th>
<th>位置</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量</td>
<td>方法内</td>
<td>方法内</td>
<td>没有</td>
<td>栈</td>
<td>同方法栈的诞生&amp;消失</td>
</tr>
<tr>
<td>成员变量</td>
<td>方法外</td>
<td>类中</td>
<td>有(同数组)</td>
<td>堆</td>
<td>同对象的诞生&amp;消失</td>
</tr>
</tbody></table>
<h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><ul>
<li>面向过程：当需要实现一个功能时，每一个具体的步骤都要亲力亲为，详细处理每一个细节</li>
<li>面向对象：当需要实现一个功能时，不关心具体步骤，而是找一个能实现该功能的人帮我做事，帮你做事的这个人就是对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"><span class="comment">//希望能把数组打印为[10,20,30,40,50]</span></span><br><span class="line"><span class="comment">//面向过程</span></span><br><span class="line">System.out.println(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == array.length-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(array[i]+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(array[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//面向对象</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>类是对象的模板，对象是类的实例</strong></p>
</li>
<li><p><strong>类：</strong></p>
<ul>
<li><p>成员变量（属性）：直接定义在类中方法之外</p>
</li>
<li><p>成员方法（行为）：普通方法有static，成员方法灭有static</p>
</li>
<li><p>通常类不能直接使用，需要根据类创建一个对象</p>
<ol>
<li>导包：<code>import 包名.类名</code>，如果两个类同属一个包，可以不import</li>
<li>创建：<code>类名称 对象名 = new 类名称()</code></li>
<li>使用：<code>对象名.成员变量名</code>，<code>成员方法名()</code></li>
</ol>
</li>
<li><p>new一个对象时，如果成员变量没有赋值会有一个默认值，规则和数组一样</p>
</li>
<li><p>一个对象的内存区：</p>
<ul>
<li>对于堆中的一个对象来说，他的成员方法保存的实际上是一个地址值，指向方法区中的成员方法内容</li>
</ul>
</li>
<li><p>一个对象的内存图：</p>
<p><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/20210102114811.png"></p>
</li>
<li><p>两个对象使用同一个方法的内存图：</p>
<p><img src="https://s3.ax1x.com/2021/01/02/rzHuvV.png"></p>
</li>
<li><p>两个引用指向同一个对象的内存图：</p>
<p><img src="https://s3.ax1x.com/2021/01/02/rzHV4s.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><ul>
<li>方法就是一种封装：将不同功能模块提取出来单独成一个方法，可以说成面向方法编程</li>
<li>关键字private也是一种封装：使用private修饰成员变量和方法。本类中可以随意访问，但是超出了本类无法<strong>直接</strong>访问。可通过public方法访问（例如setter和getter）</li>
</ul>
<p>含义：将一些细节信息隐藏起来，对外界不可见。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>方法中的局部变量和类中的成员变量从名的时候，根据“就近原则”，优先局部变量。如果方法中重名了，并且需要本类中的成员变量，需要加this关键字。</p>
<p><strong>重点：通过谁调用的方法，谁就是this</strong></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>专门用来创建对象的方法，我们通过关键字new来创建对象的时候，其实就是调用了构造方法。</p>
<ul>
<li>构造方法名称需要和类的名称一模一样</li>
<li>构造方法没有返回值，不能return，方法前连void都不要写</li>
<li>如果没有编写任何构造方法，编译器会默认一个什么都不做的构造方法。如果自己写了一个有参构造函数，最好加一个无参构造函数，因为编译器不会赠送。</li>
<li>一旦编写了至少一个构造方法，编译器不会赠送构造方法了</li>
<li>构造方法可以进行重载<ul>
<li>重载：方法名相同，参数不同</li>
</ul>
</li>
</ul>
<h3 id="标准的类（JavaBean）"><a href="#标准的类（JavaBean）" class="headerlink" title="标准的类（JavaBean）"></a>标准的类（JavaBean）</h3><ul>
<li>所有成员变量都使用private关键字修饰</li>
<li>为每一个成员变量编写一对 Getter和Setter 方法</li>
<li>编写一个无参构造方法</li>
<li>编写一个全参构造方法</li>
</ul>
<h3 id="几个重要的Java-API"><a href="#几个重要的Java-API" class="headerlink" title="几个重要的Java API"></a>几个重要的Java API</h3><ul>
<li>导包：import 包路径.类名称（同包可不导，java.lang下可不导）</li>
<li>创建：类名称 对象名 = new 类名称();</li>
<li>使用：对象名.成员方法名();</li>
</ul>
<h4 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//从键盘输入</span></span><br><span class="line"><span class="keyword">int</span> a = sc.nextInt();<span class="comment">//获取从键盘输入的int变量</span></span><br><span class="line">String str = sc.next();<span class="comment">//获取从键盘输入的字符串变量</span></span><br></pre></td></tr></table></figure>

<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">    </span><br><span class="line">Random r = <span class="keyword">new</span> Random();<span class="comment">//随机数种子</span></span><br><span class="line"><span class="keyword">int</span> num1 = r.nextInt();</span><br><span class="line"><span class="keyword">int</span> num2 = r.nextInt(<span class="number">3</span>);<span class="comment">//范围：左闭右开[0,3)</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型只能是引用类型，不能是基本类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">boolean</span> isAdd = list.add(<span class="string">&quot;Sam Smith&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Mariah Carey&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Colbie Caillat&quot;</span>);</span><br><span class="line">String name = list.get(<span class="number">0</span>);</span><br><span class="line">String delName = list.remove(<span class="number">1</span>);<span class="comment">//返回值是删除的元素</span></span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="comment">//ArrayList保存基本类型包装类</span></span><br><span class="line"><span class="comment">//Byte,Short,Integer,Long,Float,Double,Character,Boolean</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);<span class="comment">//从jdk1.5后，支持自动装箱/自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i0 = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="String：字符串"><a href="#String：字符串" class="headerlink" title="String：字符串"></a>String：字符串</h4><ul>
<li>字符串内容不可变</li>
<li>存在字符串常量池中的字符串可共享</li>
<li>字符串效果上相当于char[]字符数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建字符串</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String();</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] array);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">byte</span>[] array);</span><br><span class="line">String s4 = <span class="string">&quot;hahahahaha&quot;</span>;<span class="comment">//在字符串常量池中</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/01/DqkKswfeu3PhVQ8.png" alt="image-20210301121309678"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//equals() &amp; equalsIgnoreCase()</span></span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(s1==s2);</span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.pringln(s1.equalsIgnoreCase(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="comment">//length()</span></span><br><span class="line"><span class="keyword">int</span> l = s1.length();</span><br><span class="line"><span class="comment">//concat()</span></span><br><span class="line">String s3 = s1.concat(<span class="string">&quot;,world!&quot;</span>);<span class="comment">//返回新的字符串，字符串是常量不变</span></span><br><span class="line"><span class="comment">//charAt()</span></span><br><span class="line"><span class="keyword">char</span> ch = s1.charAt(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//indexOf()</span></span><br><span class="line"><span class="keyword">int</span> index = s1.indexOf(<span class="string">&quot;ll&quot;</span>);</span><br><span class="line"><span class="comment">//subString():截取</span></span><br><span class="line">String s4 = s3.subString(<span class="number">6</span>);<span class="comment">//world</span></span><br><span class="line">String s5 = s3.subString(<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//hello</span></span><br><span class="line"><span class="comment">//toCharArray():转换为char数组</span></span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line"><span class="comment">//getBytes():转换为byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//replace():替代</span></span><br><span class="line">String str1 = <span class="string">&quot;What&#x27;s the matter with you,fuck U!&quot;</span>;</span><br><span class="line">String str2 = str1.replace(<span class="string">&quot;fuck&quot;</span>,<span class="string">&quot;***&quot;</span>);</span><br><span class="line"><span class="comment">//split():分割</span></span><br><span class="line">String str3 = <span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">String[] array1 = str3.split(<span class="string">&quot;,&quot;</span>);<span class="comment">//参数是正则表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：String的getBytes()方法将String转化为字节使用的编码是当前.java文件的编码。</strong></li>
</ul>
<h4 id="工具类Arrays，Math"><a href="#工具类Arrays，Math" class="headerlink" title="工具类Arrays，Math"></a>工具类Arrays，Math</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Arrays</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">//toString():以字符串的形式打印数组</span></span><br><span class="line"><span class="keyword">int</span>[] intArray = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">String intStr = Arrays.toString(intArray);</span><br><span class="line"><span class="comment">//sort():如果排序自定义类型数组，该自定义类必须实现Comparable or Comparator接口</span></span><br><span class="line">Arrays.sort(intArray);<span class="comment">//会直接修改intArray数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math</span></span><br><span class="line"><span class="keyword">import</span> java.util.Math;</span><br><span class="line"><span class="comment">//abs()</span></span><br><span class="line">System.out.println(Math.abs(-<span class="number">3.14</span>));</span><br><span class="line"><span class="comment">//ceil():向上取整</span></span><br><span class="line">System.out.println(Math.ceil(<span class="number">3.14</span>));</span><br><span class="line"><span class="comment">//floor():向下取整</span></span><br><span class="line">System.out.println(Math.floor(<span class="number">3.14</span>));</span><br><span class="line"><span class="comment">//round():四舍五入</span></span><br><span class="line">System.out.println(Math.round(<span class="number">3.14</span>));</span><br><span class="line"><span class="comment">//Math.PI:近似圆周率</span></span><br></pre></td></tr></table></figure>

<h3 id="其他知识点："><a href="#其他知识点：" class="headerlink" title="其他知识点："></a>其他知识点：</h3><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><ul>
<li><p>格式：new 类名称();</p>
</li>
<li><p>确定某个对象只需用使用一次，那么可以使用匿名对象，之后会被自动回收。</p>
</li>
<li><p>匿名对象可以作为 参数 &amp; 返回值</p>
</li>
<li><p>```java<br>new Person().name = “Mariah Carey”;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### static关键字</span><br><span class="line"></span><br><span class="line">* 一个成员变量 or 成员方法 有了static关键字，就是属于类的，本类所有对象共享同一份</span><br><span class="line"></span><br><span class="line">* 静态成员方法只能访问静态成员变量（因为静态方法是class初始化就建立在了内存的方法区，此时对象中的普通成员变量可能还没有在内存的堆中建立）</span><br><span class="line"></span><br><span class="line">* 静态方法中不能用 this 关键字，**static和类相关，和对象无关**</span><br><span class="line"></span><br><span class="line">* 静态代码块</span><br><span class="line"></span><br><span class="line">  比构造方法先执行，并且只执行一次</span><br><span class="line"></span><br><span class="line">  用来一次性对静态成员变量进行赋值</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  static&#123;</span><br><span class="line">      //内容</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><ul>
<li><p>子类和父类关系是 “子类 is a 父类” 的关系</p>
</li>
<li><p>```java<br>public class Employee{</p>
<pre><code>private int name;
private int age;
</code></pre>
<p>}<br>public class Teacher extends Employee{</p>
<pre><code>private int level;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 父子类继承关系中，如果成员变量重名，创建子类对象时，有两种方式</span><br><span class="line"></span><br><span class="line">  1. 直接通过**子类对象**访问成员变量：等号左边是谁，就优先用谁，没有就向上找</span><br><span class="line">  2. 间接通过**成员方法**访问成员变量：方法属于谁就优先用谁的，没有就向上找</span><br><span class="line"></span><br><span class="line">* **重写特点：**（方法重写/覆盖：方法名，参数相同）</span><br><span class="line"></span><br><span class="line">  1. 父子类的方法重名，访问成员变量的规则：new创建的对象是谁，就优先用谁，没有就往上找</span><br><span class="line"></span><br><span class="line">  2. `@override`注解用来检测是否覆盖正确</span><br><span class="line"></span><br><span class="line">  3. 子类方法的返回值类 必须 低于等于 父类方法的返回值类</span><br><span class="line"></span><br><span class="line">  4. 子类方法的权限修饰符 必须 大于等于 父类方法的权限修饰符</span><br><span class="line"></span><br><span class="line">     * public &gt; protected &gt; (default) &gt; private</span><br><span class="line"></span><br><span class="line">  5. 设计原则：对于已经投入使用的类，不要改动它。定义一个新类继承老类重复利用父类共性并添加新的改动</span><br><span class="line"></span><br><span class="line">     ```java</span><br><span class="line">     public class Phone&#123;</span><br><span class="line">         public void call()&#123;</span><br><span class="line">             System.out.println(&quot;打电话&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         public void send()&#123;</span><br><span class="line">             System.out.println(&quot;发短信&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         public void show()&#123;</span><br><span class="line">             System.out.println(&quot;显示号码&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public class NewPhone extends Phone&#123;</span><br><span class="line">         public void snow()&#123;</span><br><span class="line">             super.show();</span><br><span class="line">             System.out.println(&quot;显示姓名&quot;);</span><br><span class="line">             System.out.println(&quot;显示头像&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>子类构造方法中的<strong>第一个语句</strong>是一个赠送的<code>super()</code>，但是不会赠送有参父类构造，需要自己显式声明<code>super(参数)</code>来调用父类重载构造</li>
</ol>
</li>
<li><p><strong>super关键字</strong>三种用法：</p>
<ol>
<li>子类成员方法中，访问父类成员变量</li>
<li>子类成员方法中，访问父类成员方法</li>
<li>子类构造方法中，访问父类构造方法</li>
</ol>
</li>
<li><p><strong>this关键字</strong>三种用法：</p>
<ol>
<li>本类成员方法中，访问本类成员变量</li>
<li>本类成员方法中，访问本类成员方法</li>
<li>本类构造方法中，访问本类另一个构造方法</li>
</ol>
</li>
<li><p>**this 和 super **不能同时存在于一个构造方法中</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/01/eUIu7fjZxE4Xtch.png" alt="image-20210301194433254"></p>
<ul>
<li>Java语言是单继承，多级继承的</li>
</ul>
<h3 id="抽象类-amp-抽象方法"><a href="#抽象类-amp-抽象方法" class="headerlink" title="抽象类 &amp; 抽象方法"></a>抽象类 &amp; 抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法所在的类必须是抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalMethod</span><span class="params">()</span></span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能直接new抽象类对象。但是抽象类中可以有构造函数，用来供子类对象创建时初始化父类成员变量</li>
<li>必须用子类继承抽象类 并 覆盖重写所有的抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat eat fish.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类</li>
<li>抽象类的子类必须重写父类中的抽象方法，除非子类也是抽象类</li>
</ul>
<h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul>
<li><p>接口类中，不同jdk版本能包含的内容不同</p>
<ol>
<li><p>jdk7：常量，抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="comment">//常量：public,static,final是固定的,可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_OF_MY_CLASS  = <span class="number">10</span>;<span class="comment">//必须赋值</span></span><br><span class="line">    <span class="comment">//public和abstract是固定的,可以省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;first method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>jdk8：默认方法，静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认方法：实现类不必实现，因为接口中的默认方法有实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodAbs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不能通过接口实现类对象来调用静态方法：因为一个类可以实现多个接口。应该通过接口名调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodAbs2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>jdk9：私有方法</p>
<p>需要解决的问题：需要一个共有方法来解决两个默认方法之间的重复代码问题，但是这个共有方法不该让实现类实现，应该是私有化的。</p>
<ol>
<li>普通私有方法：解决多个默认方法之间的重复代码问题</li>
</ol>
</li>
<li><p>静态私有方法：解决多个静态方法之间的重复代码问题</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/03/01/yjF51ITcwOpZ4SK.png" alt="image-20210301224807631"></p>
<p><img src="https://i.loli.net/2021/03/01/lHI7xpe93nDScA8.png" alt="image-20210301225536727"></p>
</li>
<li><p><strong>接口-接口：多继承</strong></p>
<p>类-类：单继承</p>
<p>类-接口：多实现</p>
</li>
</ul>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><ul>
<li><p>继承是多态的前提：学生既是学生，也是人，同事拥有多种形态</p>
</li>
<li><p>```java<br>父类名称 对象名 = new 子类名称();<br>接口名称 对象名 = new 实现类名称();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 注意：继承 or 实现中，成员方法能覆盖重写，但是成员变量不能。所以：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  Fu obj = new Zi();</span><br><span class="line">  obj.成员变量;//看等号左边是谁就访问谁的成员变量，没有就向上找（编译看左边，运行还看左边）</span><br><span class="line">  obj.成员方法();//new的谁就优先用谁的成员方法，没有就向上找（编译看左，运行看右）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象向上转型"><a href="#对象向上转型" class="headerlink" title="对象向上转型"></a>对象向上转型</h3><ul>
<li>向上转型一定是安全的</li>
<li>但是一旦上转为父类，就无法调用子类特有的方法</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一只猫，当做动物看待</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">//类似于自动类型转化(范围大&lt;---范围小)</span></span><br><span class="line"><span class="keyword">double</span> num = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对象向下转型"><a href="#对象向下转型" class="headerlink" title="对象向下转型"></a>对象向下转型</h3><ul>
<li><p>上转后，如果需要调用子类特有的方法，需要再原路下转</p>
</li>
<li><p>可以使用instanceof判断类的所属</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上转后，还原为猫</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat  = (Cat)animal;</span><br><span class="line"><span class="comment">//类似于强制类型转换(范围小&lt;---范围大)</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)<span class="number">10.0</span>;</span><br><span class="line"><span class="comment">//只能原路还原，如果把animal还原为狗，会报错ClassCastException,就像强制类型转换的精度损失</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="final关键字：“断子绝孙”关键字"><a href="#final关键字：“断子绝孙”关键字" class="headerlink" title="final关键字：“断子绝孙”关键字"></a>final关键字：“断子绝孙”关键字</h3><ol>
<li><p>可以修饰一个类：不能有任何子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;<span class="comment">//和abstract关键字矛盾</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以修饰一个方法：不能覆盖重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//和abstract关键字矛盾</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以修饰一个局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">//常量</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num;num=<span class="number">10</span>;<span class="comment">//也可以</span></span><br><span class="line"><span class="comment">//对基本数据类型来说，是变量的数据不可改变</span></span><br><span class="line"><span class="comment">//对于引用数据类型来说，是引用的数据不可改变，即是引用所指向的地址不可改变</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以修饰一个成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和局部变量的区别是成员变量有默认值，所以一旦是final的成员变量，如果不第一时间初始化，他就只能是默认值常量</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">final成员变量赋值的两种方式</span></span><br><span class="line"><span class="comment">	1. 直接赋值</span></span><br><span class="line"><span class="comment">	2. 构造方法赋值</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4种权限修饰符-public-gt-protected-gt-default-gt-private"><a href="#4种权限修饰符-public-gt-protected-gt-default-gt-private" class="headerlink" title="4种权限修饰符 (public &gt; protected &gt; (default) &gt; private)"></a>4种权限修饰符 (public &gt; protected &gt; (default) &gt; private)</h3><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>不同包子类</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>内用外，随意访问；外用内，需要内部类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span></span>&#123;<span class="comment">//成员内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类方法&quot;</span>);</span><br><span class="line">            System.out.println(name);<span class="comment">//内用外</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> methodBody&#123;</span><br><span class="line">        <span class="keyword">new</span> Heart().beat();<span class="comment">//外用内</span></span><br><span class="line">        System.out.println(<span class="string">&quot;外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MainTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Body body = <span class="keyword">new</span> Body();</span><br><span class="line">        </span><br><span class="line">        body.methodBody();<span class="comment">//间接使用成员内部类</span></span><br><span class="line">        </span><br><span class="line">        Body.Heart heart = <span class="keyword">new</span> Body().<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;<span class="comment">//直接使用成员内部类</span></span><br><span class="line">        heart.beat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部类成员变量重名情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">            System.out.println(num);<span class="comment">//30</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num);<span class="comment">//20</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num);<span class="comment">//10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul>
<li>只有当前所属的方法内部才能使用</li>
<li>从jdk8开始，只要局部内部类的局部变量事实不变，那么final关键字可以省略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">//jdk8后,final关键字可省略</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.methodInner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MainTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.methodOuter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><ul>
<li>如果接口的实现类 or 父类的继承类 只需要使用<strong>唯一的一次</strong>，那么可以省略该类的定义，直接使用【匿名内部类】</li>
<li>匿名内部类是省略了【单独实现子类】，匿名对象是省略了【对象引用名称】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">MainTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyInterface obj = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现了方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.method();</span><br><span class="line">        MyInterface obj2 = <span class="keyword">new</span> MyInterface()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类实现了方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">//匿名内部类的匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>外部类权限：public任何包都可以访问 / (default同一个包可以访问)</p>
<p>成员内部类权限：所有都可以</p>
<p>局部内部类权限：什么都不能写</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>java基础快速回顾-上</p><p><a href="https://jack1024.link/2020/12/19/java基础快速回顾-上/">https://jack1024.link/2020/12/19/java基础快速回顾-上/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Jack1024</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-12-19</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-06-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a><a class="link-muted mr-2" rel="tag" href="/tags/JavaSE/">JavaSE</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6043a11d32910c0018e217f7&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/21/Java-GC%E6%9C%BA%E5%88%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java-GC机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/19/java-%E5%8F%8D%E5%B0%84/"><span class="level-item">java-反射</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "76136e49eaddc2c801731ad0c966aea5",
            repo: "gitalk-comment",
            owner: "yangfanjack",
            clientID: "c12e18c31ac7cd568589",
            clientSecret: "f381392cab6b4fd6c0526092be05029fbdc00215",
            admin: ["yangfanjack"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#java语言开发环境搭建"><span class="level-left"><span class="level-item">1</span><span class="level-item">java语言开发环境搭建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#java虚拟机——JVM"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">java虚拟机——JVM</span></span></a></li><li><a class="level is-mobile" href="#JRE和JDK"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">JRE和JDK</span></span></a></li><li><a class="level is-mobile" href="#配置JDK环境变量"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">配置JDK环境变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HelloWorld入门程序"><span class="level-left"><span class="level-item">2</span><span class="level-item">HelloWorld入门程序</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#程序开发步骤"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">程序开发步骤</span></span></a></li><li><a class="level is-mobile" href="#HelloWorld程序说明"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">HelloWorld程序说明</span></span></a></li><li><a class="level is-mobile" href="#关键字说明：java中有特殊含义的保留字"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">关键字说明：java中有特殊含义的保留字</span></span></a></li><li><a class="level is-mobile" href="#标识符："><span class="level-left"><span class="level-item">2.4</span><span class="level-item">标识符：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#常量"><span class="level-left"><span class="level-item">3</span><span class="level-item">常量</span></span></a></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">4</span><span class="level-item">数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#引用数据类型"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">引用数据类型</span></span></a></li><li><a class="level is-mobile" href="#基本数据类型"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">基本数据类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变量"><span class="level-left"><span class="level-item">5</span><span class="level-item">变量</span></span></a></li><li><a class="level is-mobile" href="#数据类型转换"><span class="level-left"><span class="level-item">6</span><span class="level-item">数据类型转换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#自动转换（隐式）"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">自动转换（隐式）</span></span></a></li><li><a class="level is-mobile" href="#强制转换（显式）"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">强制转换（显式）</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ASCII-amp-Unicode"><span class="level-left"><span class="level-item">7</span><span class="level-item">ASCII&amp;Unicode</span></span></a></li><li><a class="level is-mobile" href="#运算符"><span class="level-left"><span class="level-item">8</span><span class="level-item">运算符</span></span></a></li><li><a class="level is-mobile" href="#方法"><span class="level-left"><span class="level-item">9</span><span class="level-item">方法</span></span></a></li><li><a class="level is-mobile" href="#Jshell"><span class="level-left"><span class="level-item">10</span><span class="level-item">Jshell</span></span></a></li><li><a class="level is-mobile" href="#编译器的两点优化"><span class="level-left"><span class="level-item">11</span><span class="level-item">编译器的两点优化</span></span></a></li><li><a class="level is-mobile" href="#流程"><span class="level-left"><span class="level-item">12</span><span class="level-item">流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#顺序结构"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">顺序结构</span></span></a></li><li><a class="level is-mobile" href="#选择结构"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">选择结构</span></span></a></li><li><a class="level is-mobile" href="#循环结构"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">循环结构</span></span></a></li><li><a class="level is-mobile" href="#三种循环区别"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">三种循环区别</span></span></a></li><li><a class="level is-mobile" href="#break关键字和continue关键字"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">break关键字和continue关键字</span></span></a></li></ul></li><li><a class="level is-mobile" href="#IDEA快捷键"><span class="level-left"><span class="level-item">13</span><span class="level-item">IDEA快捷键</span></span></a></li><li><a class="level is-mobile" href="#方法重载"><span class="level-left"><span class="level-item">14</span><span class="level-item">方法重载</span></span></a></li><li><a class="level is-mobile" href="#数组"><span class="level-left"><span class="level-item">15</span><span class="level-item">数组</span></span></a></li><li><a class="level is-mobile" href="#Java内存模型"><span class="level-left"><span class="level-item">16</span><span class="level-item">Java内存模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用对象类型作为方法的参数-amp-返回值"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">使用对象类型作为方法的参数&amp;返回值</span></span></a></li><li><a class="level is-mobile" href="#局部变量-and-成员变量"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">局部变量 and 成员变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#面向对象思想"><span class="level-left"><span class="level-item">17</span><span class="level-item">面向对象思想</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#面向对象三大特征"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">面向对象三大特征</span></span></a></li></ul></li><li><a class="level is-mobile" href="#封装性"><span class="level-left"><span class="level-item">18</span><span class="level-item">封装性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#this关键字"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">this关键字</span></span></a></li><li><a class="level is-mobile" href="#构造方法"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">构造方法</span></span></a></li><li><a class="level is-mobile" href="#标准的类（JavaBean）"><span class="level-left"><span class="level-item">18.3</span><span class="level-item">标准的类（JavaBean）</span></span></a></li><li><a class="level is-mobile" href="#几个重要的Java-API"><span class="level-left"><span class="level-item">18.4</span><span class="level-item">几个重要的Java API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Scanner"><span class="level-left"><span class="level-item">18.4.1</span><span class="level-item">Scanner</span></span></a></li><li><a class="level is-mobile" href="#Random"><span class="level-left"><span class="level-item">18.4.2</span><span class="level-item">Random</span></span></a></li><li><a class="level is-mobile" href="#ArrayList"><span class="level-left"><span class="level-item">18.4.3</span><span class="level-item">ArrayList</span></span></a></li><li><a class="level is-mobile" href="#String：字符串"><span class="level-left"><span class="level-item">18.4.4</span><span class="level-item">String：字符串</span></span></a></li><li><a class="level is-mobile" href="#工具类Arrays，Math"><span class="level-left"><span class="level-item">18.4.5</span><span class="level-item">工具类Arrays，Math</span></span></a></li></ul></li><li><a class="level is-mobile" href="#其他知识点："><span class="level-left"><span class="level-item">18.5</span><span class="level-item">其他知识点：</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#匿名对象"><span class="level-left"><span class="level-item">18.5.1</span><span class="level-item">匿名对象</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#继承性"><span class="level-left"><span class="level-item">19</span><span class="level-item">继承性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#抽象类-amp-抽象方法"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">抽象类 &amp; 抽象方法</span></span></a></li><li><a class="level is-mobile" href="#接口类"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">接口类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多态性"><span class="level-left"><span class="level-item">20</span><span class="level-item">多态性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#对象向上转型"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">对象向上转型</span></span></a></li><li><a class="level is-mobile" href="#对象向下转型"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">对象向下转型</span></span></a></li><li><a class="level is-mobile" href="#final关键字：“断子绝孙”关键字"><span class="level-left"><span class="level-item">20.3</span><span class="level-item">final关键字：“断子绝孙”关键字</span></span></a></li><li><a class="level is-mobile" href="#4种权限修饰符-public-gt-protected-gt-default-gt-private"><span class="level-left"><span class="level-item">20.4</span><span class="level-item">4种权限修饰符 (public &gt; protected &gt; (default) &gt; private)</span></span></a></li><li><a class="level is-mobile" href="#内部类"><span class="level-left"><span class="level-item">20.5</span><span class="level-item">内部类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#成员内部类"><span class="level-left"><span class="level-item">20.5.1</span><span class="level-item">成员内部类</span></span></a></li><li><a class="level is-mobile" href="#局部内部类"><span class="level-left"><span class="level-item">20.5.2</span><span class="level-item">局部内部类</span></span></a></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">20.5.3</span><span class="level-item">小结</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2021/06/14/%E5%AE%9E%E4%BD%93%E6%9C%BA%E5%AE%89%E8%A3%85Arch/"><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/image-20210317103120855.png" alt="实体机安装Arch"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-06-14T01:18:48.000Z">2021-06-14</time></p><p class="title"><a href="/2021/06/14/%E5%AE%9E%E4%BD%93%E6%9C%BA%E5%AE%89%E8%A3%85Arch/">实体机安装Arch</a></p><p class="categories"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/17/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/"><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/English-Grammar.jpg" alt="英语语法框架构建"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-17T07:49:41.000Z">2021-05-17</time></p><p class="title"><a href="/2021/05/17/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/">英语语法框架构建</a></p><p class="categories"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/15/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/cheapest-online-economics-degree.jpg" alt="经济学原理学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-15T13:49:01.000Z">2021-05-15</time></p><p class="title"><a href="/2021/05/15/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">经济学原理学习</a></p><p class="categories"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/15/%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2/"><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/cheapest-online-economics-degree.jpg" alt="基金理财"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-15T09:31:39.000Z">2021-05-15</time></p><p class="title"><a href="/2021/05/15/%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2/">基金理财</a></p><p class="categories"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2021/05/15/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/"><img src="https://gitee.com/yangfanjack/blogimage/raw/master/img/cheapest-online-economics-degree.jpg" alt="股票入门"></a></figure><div class="media-content"><p class="date"><time dateTime="2021-05-15T06:58:12.000Z">2021-05-15</time></p><p class="title"><a href="/2021/05/15/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/">股票入门</a></p><p class="categories"><a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/image/logoko.png" alt="JACK&#039;s BLOG" height="28"></a><p class="is-size-7"><span>&copy; 2021 Jack1024</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>