{"pages":[{"title":"About The Blog","text":"一个普通IT人的博客站 思考、记录、分享 欢迎访问我的博客，交流或者有问题请留言 或QQ联系。我的QQ：1144536063","link":"/about/index.html"},{"title":"","text":"sup { position: relative; top: -0.4em; vertical-align: baseline; } sub { position: relative; top: 0.4em; vertical-align: baseline; } a:link {text-decoration:none;} a:visited {text-decoration:none;} @media screen and (min-device-pixel-ratio:0), (-webkit-min-device-pixel-ratio:0), (min--moz-device-pixel-ratio: 0) { .view { font-size:10em; transform:scale(0.1); -moz-transform:scale(0.1); -webkit-transform:scale(0.1); -moz-transform-origin:top left; -webkit-transform-origin:top left; } } .layer { }.ie { font-size: 1pt; } .ie body { font-size: 12em; } .stl_01 { position: absolute; white-space: nowrap; } .stl_02 { height: 70.08334em; font-size: 1em; margin: 0em; line-height: 0.0em; display: block; border-style: none; width: 49.58333em; } .stl_03 { position: relative; } .stl_04 { position: absolute; left: 0em; top: 0em; } .stl_05 { position: relative; width: 49.58333em; } .stl_06 { height: 7.008333em; } .ie .stl_06 { height: 70.08334em; } @font-face { font-family:\"MMPWKS+MicrosoftYaHei-Bold\"; src:url(\"3371fe3b-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_07 { font-size: 1.829167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #44546B; } .stl_08 { line-height: 1.041992em; } .stl_09 { letter-spacing: 0.0004em; } .ie .stl_09 { letter-spacing: 0.0125px; } @font-face { font-family:\"DIKHKL+MicrosoftYaHei\"; src:url(\"1b0cfbf9-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_10 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #525252; } .stl_11 { letter-spacing: -0.0036em; } .ie .stl_11 { letter-spacing: -0.0582px; } @font-face { font-family:\"AJAHDD+MicrosoftYaHeiLight\"; src:url(\"ec0f8afa-0000-0000-0000-000000000000.woff\") format(\"woff\"); } .stl_12 { font-size: 0.870833em; font-family: \"AJAHDD+MicrosoftYaHeiLight\", \"Times New Roman\"; color: #525252; } .stl_13 { letter-spacing: 0em; } .ie .stl_13 { letter-spacing: 0px; } .stl_14 { letter-spacing: -0.2519em; } .ie .stl_14 { letter-spacing: -3.5103px; } .stl_15 { letter-spacing: -1.007em; } .ie .stl_15 { letter-spacing: -14.0303px; } .stl_16 { letter-spacing: -0.046em; } .ie .stl_16 { letter-spacing: -0.6408px; } .stl_17 { letter-spacing: -0.0905em; } .ie .stl_17 { letter-spacing: -1.2611px; } .stl_18 { letter-spacing: -0.1571em; } .ie .stl_18 { letter-spacing: -2.1883px; } .stl_19 { font-size: 1.079167em; font-family: \"MMPWKS+MicrosoftYaHei-Bold\", \"Times New Roman\"; color: #FFFFFF; } .stl_20 { letter-spacing: -0.0003em; } .ie .stl_20 { letter-spacing: -0.0054px; } .stl_21 { font-size: 1em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_22 { letter-spacing: 0.0005em; } .ie .stl_22 { letter-spacing: 0.0083px; } .stl_23 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #585858; } .stl_24 { letter-spacing: -0.0004em; } .ie .stl_24 { letter-spacing: -0.0062px; } .stl_25 { letter-spacing: 0.0018em; } .ie .stl_25 { letter-spacing: 0.0255px; } .stl_26 { letter-spacing: 0.001em; } .ie .stl_26 { letter-spacing: 0.014px; } .stl_27 { letter-spacing: 0.0047em; } .ie .stl_27 { letter-spacing: 0.0662px; } .stl_28 { letter-spacing: 0.0029em; } .ie .stl_28 { letter-spacing: 0.041px; } .stl_29 { letter-spacing: 0.0036em; } .ie .stl_29 { letter-spacing: 0.0504px; } .stl_30 { letter-spacing: -0.0008em; } .ie .stl_30 { letter-spacing: -0.0115px; } .stl_31 { letter-spacing: 0.0011em; } .ie .stl_31 { letter-spacing: 0.0147px; } .stl_32 { letter-spacing: -0.0075em; } .ie .stl_32 { letter-spacing: -0.1049px; } .stl_33 { letter-spacing: 0.0022em; } .ie .stl_33 { letter-spacing: 0.0307px; } .stl_34 { letter-spacing: -0.0051em; } .ie .stl_34 { letter-spacing: -0.0705px; } .stl_35 { letter-spacing: 0.0044em; } .ie .stl_35 { letter-spacing: 0.0609px; } .stl_36 { font-size: 0.870833em; font-family: \"DIKHKL+MicrosoftYaHei\", \"Times New Roman\"; color: #595959; } .stl_37 { letter-spacing: 0.0038em; } .ie .stl_37 { letter-spacing: 0.0524px; }","link":"/resume/style.css"},{"title":"文章标签","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"About The Plan","text":"不以物喜，不以己悲。——2021.08.13 生活安排早6点40起床 工作期间按照小时安排工作，小时间隔站立适当调整 锻炼30min 晚11:00睡上床：读书30min 晚11:30睡觉 近期计划 开始时间 结束时间 内容 情况 2022.07.09 精品 2022.07.09 配件第一部分 2022.07.09 Java基础 长期计划 开始时间 结束时间 内容 情况 2022.07.09 Java基础 SpringBoot Dubbo+zookeeper SpringSecurity SpringCloud DevOps：docker+k8s+jenkins ElasticSearch SQL进阶：索引、视图 工作流","link":"/plan/index.html"}],"posts":[{"title":"AJAX局部刷新技术","text":"AJAX含义： Asynchromnous JavaScript And XML 异步的Javascript（编程语言）和XML（文件格式） AJAX不是一门新的编程语言，是一个多门已有技术组合后创新产生的新技术 核心点： 核心编程语言是JS 数据交换的工具是XML（现已被JOSN替代） AJAX是一种异步请求方式（和同步请求对立） 同步&amp;异步请求同步请求： 浏览器发起的传统请求（表单，超链接，地址栏输入地址，location.href） 用户从发起请求开始，到服务器端相应结果完毕，这段时间内不能再操作页面，如果服务端相应结果耗时很长，用户在这段时间内一直等待体验很差。 特点： 一定刷新页面 地址栏一定改变 发起同步请求，会阻塞用户的其他操作 异步请求： AJAX是一种浏览器端的异步请求技术 对于AJAX，服务端响应的不是一个完整页面，而是字符串（页面的数据部分），不会刷新页面 用户在JavaScript发起请求开始，到服务端响应结果完毕，不用等待，用户可以一直操作页面，用户体验好 特点： 不刷新页面 地址栏不改变 异步请求不会阻塞用户的其他操作 原生AJAX操作 AJAX异步请求通用模型 JSON 异步请求下，Server端响应会Client的不是一个完整页面，而是字符串数据，当服务端响应的结果比较复杂时（对象，数组，集合），简单格式的字符串不能满足需求，在传递复杂的数据时，不能使用简单格式的字符串，要使用JSON格式的字符串。 JSON：JavaScript Object Notation，它是JS对象字符串表示形式，定义了对象等复杂数据的特定字符串格式，独立于各个编程语言，是一种轻量级的数据交换格式。 按照java数据类型可分为以下两种JSON字符串转化方式： 普通对象 &amp; Map 数组 &amp; List &amp; Set Jackson工具的使用123456&lt;!-- 引入依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt; 1234Student s = new Student(传入参数);ObjectMapper objectMapper = new ObjectMapper();String studentJson = objectMapper.writeValueAsString(s);System.out.println(studentJson); 属性没有值，可以在对应实体类加上注解，就只会转化非null的数据： 1@JsonInlcude(JsonInclude.Include.NON_NULL) 属性名定制，在实体类属性上加注解： 1@JsonProperty(&quot;别名&quot;) 对象回环问题解决： 日期格式输出： 日期格式默认转化为时间戳来显示的（1970年1月1日开始到现在的毫秒数） 在实体类的日期属性上加上注解： 1@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;) 需要注意： POST和GET区别： POST请求时必须带一个：content-type 指定参数的类型 POST的请求参数不能直接写在请求地址后 在SpringMVC中使用@responsebody的注解需要先引入jackson-core和jackson-databind两个依赖（我的惨痛教训，以后使用非传统功能事前，一定要先看看是否引入了外部依赖）","link":"/2020/12/28/AJAX%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E6%8A%80%E6%9C%AF/"},{"title":"C++的几种初始化方式","text":"列表初始化 作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。 但有局限性：当对内置对象使用列表初始化的时候，若初始值存在丢失的风险时，编译器会报错 拷贝初始化 例子：string s2=s1; 直接初始化 例子：string(); string(“hi”); string(3,’c’); 默认初始化 非static局部变量、static局部变量、全局变量、类类型 值初始化 例子：vector a(10); 类成员初始化 只允许进行拷贝初始化和列表初始化","link":"/2019/11/04/C++%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/"},{"title":"Docker入门指南","text":"docker介绍下载docker依赖环境12想安装Docker，需要先将依赖的环境全部下载下来，就像Maven依赖JDK一样yum -y install yum-utils device-mapper-persistent-data lvm2 指定docker镜像源头12默认下载Docker会去国外服务器下载，速度较慢，可以设置为阿里云镜像源，速度更快yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker1234567891011yum makecache fastyum -y install docker-ce#配置阿里云镜像加速器sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot;: [&quot;https://46dcjg1g.mirror.aliyuncs.com&quot;]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker 启动docker1234567安装成功后，需要手动启动，设置为开机启动，并测试一下 Docker#启动docker服务systemctl start docker#设置开机自动启动systemctl enable docker#测试docker run hello-world docker中央仓库12345678910111213141.Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度较慢。https://hub.docker.com/2.国内的镜像网站：网易蜂巢，daoCloud等，下载速度快，但是镜像相对不全。https://c.163yun.com/hub#/home http://hub.daocloud.io/ （推荐使用）3.在公司内部会采用私服的方式拉取镜像（添加配置）#需要创建 /etc/docker/daemon.json，并添加如下内容{ &quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;], &quot;insecure-registries&quot;:[&quot;ip:port&quot;]}#重启两个服务systemctl daemon-reloadsystemctl restart docker docker镜像操作拉取镜像123从中央仓库拉取镜像到本地docker pull 镜像名称[:tag]#举个栗子:docker pull daocloud.io/library/tomcat:8.5.15-jre8 查看本地全部镜像12查看本地已经安装过的镜像信息，包含标识，名称，版本，更新时间，大小docker images 删除本地镜像12镜像会占用磁盘空间，可以直接手动删除，标识通过查看获取docker rmi 镜像的标识 镜像的拉入拉出1234567如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改#将本地的镜像导出docker save -o 导出的路径 镜像id#加载本地的镜像文件docker load -i 镜像文件#修改镜像文件docker tag 镜像id 新镜像名称：版本 容器的操作运行容器12345678运行容器需要定制具体镜像，如果镜像不存在，会直接下载#简单操作docker run 镜像的标识|镜像的名称[:tag]#常用的参数docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]#-d:代表后台运行容器#-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口#--name 容器名称:指定容器的名称 查看正在运行的容器1234查看全部正在运行的容器信息docker ps [-qa]#-a 查看全部的容器，包括没有运行#-q 只查看容器的标识 查看容器日志123查看容器日志，以查看容器运行的信息docker logs -f 容器id#-f：可以滚动查看日志的最后几行 进入/退出容器内部12345678#进入容器内部docker exec -t 容器id /bin/bash#启动镜像并进入容器docker run -it centos /bin/bash#从容器停止并退出到宿主机exit#容器不停止并退出Ctrl+P+Q 复制内容到容器1docker cp 宿主机路径 容器id:容器路径 重启&amp;启动&amp;停止&amp;删除容器1234567891011121314容器的启动，停止，删除等操作，后续会经常使用到#重新启动容器docker restart 容器id#启动停止运行的容器docker start 容器id #停止指定的容器(删除容器前，需要先停止容器)docker stop 容器id#停止全部容器docker stop $(docker ps -qa)#删除指定容器docker rm 容器id#删除全部容器docker rm $(docker ps -qa) docker应用docker安装tomcat12345运行Tomcat容器，为部署ssm工程做准备 docker run -d -p 8080:8080 --name tomcat daocloud.io/library/tomcat:8.5.15-jre8#或者已经下载了tomcat镜像docker run -d -p 8080:8080 --name tomcat 镜像的标识 运行MySQL容器1docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4 部署ssm工程12345678修改SSM工程环境，设置为Linux中Docker容器的信息通过Maven的package重新打成war包将Windows下的war包复制到Linux中通过docker命令将宿主机的war包复制到容器内部 docker cp 文件名称 容器id:容器内部路径 测试访问SSM工程 docker常用命令镜像命令1234567891011docker version #显示docker的版本信息docker info #显示docker的系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令docker images #查看所有镜像 -a,--all #列出所有镜像 -q,--quiet #只显示iddocker search XXX #搜索docker镜像 --filter=STARS=3000 #通过搜藏来过滤docker pull XXX[:版本号] #下载镜像(分层下载：docker的核心)docker rmi -f 镜像id #删除指定镜像docker rmi -f ${docker images -aq} #删除全部镜像 容器命令123456789101112131415161718192021222324252627#启动镜像新建容器并启动docker pull centosdocker run centos #启动镜像新建容器 --name=&quot;XXX&quot; #用来区分容器 -d #后台运行 -it #使用交互容器运行 -p #指定容器的端口 -p 主机端口:容器端口（常用） -p ip:主机端口:容器端口 -p 容器端口 容器端口 -P #随机指定端口docker run -it centos /bin/bash #启动镜像并进入容器exit #从容器停止并退出到宿主机Ctrl+P+Q #容器不停止并退出docker ps -a #列出当前正在运行的容器+历史运行过的容器 -n=? #显示最近创建的容器 -q #只显示容器的编号docker rm 容器iddocker rm -f 容器id（不需要退出直接删除）docker rm -f ${docker ps -aq} #删除所有容器 #启动和停止容器docker start 容器id #启动容器docker restart 容器id #重启容器docker stop 容器id #停止当前正在运行的容器docker kill 容器id #强制停止当前容器 常用其他命令12345678910111213# 容器要想后台运行必须要有相应的前台应用，因为docker容器仅在它的1号进程运行时会保持运行，如果1号进程推出了，容器也就退出了。#日志docker logs -f -t --tail 10 容器id#查看容器中进程信息docker top 容器id#查看容器元数据信息docker inspect 容器id#进入当前正在运行的后台容器docker exec -it 容器id /bin/bash（进入容器后开启一个新的终端，可以在里面交互）docker attach 容器id（进入的是容器正在运行的命令行，不能交互）# 从容器拷贝文件到宿主机docker cp 容器id:容器内路径 目的宿主机路径#拷贝是一个手动拷贝的过程，通过数据卷可以自动同步（类似于共享文件夹）","link":"/2020/11/19/Docker%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"title":"C++程序实现演讲比赛成绩打分程序","text":"程序总体框架1.speaker类：演讲选手类123456789class Speaker{public: string m_Name; //严格意义上这俩数据成员应该是私有的，用set和get函数来调用 double m_Sorce[2];//此处是为了简便，严格意义上这样是不规范大气的 Speaker(); ~Speaker();}; 2.speechManager类：演讲比赛类（主体）1234567891011121314151617181920212223242526class SpeechManager{public: SpeechManager(); ~SpeechManager(); void show_Menu();//打印菜单 void exitSystem();//退出系统 void initSpeech();//初始化speechManager类的各个数据成员 void createSpeaker();//创建参加比赛的12名选手 void startSpeech();//比赛的主函数，包含所有流程，所有分流程又拆分为单独函数 void speechDraw();//抽签 void speechContest();//比赛（重点） void showScore();//显示晋级选手 void saveRecord();//保存每一届冠亚季军到csv文件 void loadRecord();//加载文件中每一届数据到程序中 void showRecord();//显示文件中的数据（每一届的冠亚季军） void clearRecord();//清除文件记录 vector&lt;int&gt; v1;//保存每一届的最初12名选手 vector&lt;int&gt; v2;//保存每一届第一轮比赛晋级的6名选手 vector&lt;int&gt; vVictory;//保存每一届冠亚季军 map&lt;int,Speaker&gt;m_Speaker; map&lt;int,vector&lt;string&gt;&gt; m_Record;//存放往届记录 int m_index;//保存是每一届比赛的第几轮 bool fileIsEmpty;//判断文件是否为空}; 3.main.cpp(主函数)1234567891011121314151617181920212223242526272829303132int main(){ int choice=0; while(true) { srand((unsigned int)time(NULL)); SpeechManager sm; sm.show_Menu(); cout&lt;&lt;&quot;please give me a choice:&quot;&lt;&lt;endl; cin &gt;&gt;choice; switch(choice) { case 1://开始演讲比赛 sm.startSpeech(); break; case 2://查看往届记录 //sm.loadRecord(); sm.showRecord(); break; case 3://清空比赛记录 sm.clearRecord(); break; case 4://退出比赛程序 sm.exitSystem(); break; default: system(&quot;cls&quot;); break; } } return 0; } 比赛大致流程 每一届的比赛从12名选手中选取得到，12名选手分为6 6两组，然后分别从6中选3，第一轮比赛得到6名晋级选手。 第二轮比赛中同样是从晋级的6名选手中选3人，按照成绩评选为每一届比赛的最终冠军，亚军和季军。 SpeechManager类中的函数（实现功能的重要函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311SpeechManager::SpeechManager(){ this-&gt;initSpeech(); this-&gt;createSpeaker(); this-&gt;loadRecord();}SpeechManager::~SpeechManager(){}void SpeechManager::show_Menu(){ cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;****************Welcome!***************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************1.开始演讲比赛**************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************2.查看往届记录**************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************3.清空比赛记录**************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;************4.退出比赛程序**************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;***************************************&quot;&lt;&lt;endl; cout&lt;&lt;endl;}void SpeechManager::exitSystem(){ cout&lt;&lt;&quot;欢迎下次使用！&quot;&lt;&lt;endl; system(&quot;pause&quot;); exit(0);}void SpeechManager::initSpeech(){ this-&gt;v1.clear(); this-&gt;v2.clear(); this-&gt;vVictory.clear(); this-&gt;m_Speaker.clear(); this-&gt;m_index=1; this-&gt;m_Record.clear();}void SpeechManager::createSpeaker(){ string nameSeed = &quot;ABCDEFGHIJKL&quot;; for(int i = 0;i&lt;nameSeed.size();i++) { string name=&quot;Speaker&quot;; name+=nameSeed[i]; Speaker sp; sp.m_Name=name; for(int j=0;j&lt;2;j++) { sp.m_Sorce[j]=0; } this-&gt;v1.push_back(i+10001); this-&gt;m_Speaker.insert(make_pair(i+10001,sp)); }}void SpeechManager::startSpeech(){ //第一轮比赛 //抽签 this-&gt;speechDraw(); //比赛 this-&gt;speechContest(); //显示晋级结果 this-&gt;showScore(); //第二轮比赛 this-&gt;m_index++; //抽签 this-&gt;speechDraw(); //比赛 this-&gt;speechContest(); //显示晋级结果 this-&gt;showScore(); //保存分数 this-&gt;saveRecord(); cout&lt;&lt;&quot;本届比赛完毕！&quot;&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;);}void SpeechManager::speechDraw(){ cout&lt;&lt;&quot;第&quot;&lt;&lt;this-&gt;m_index&lt;&lt;&quot;轮比赛正在抽签。。。&quot;&lt;&lt;endl; cout&lt;&lt;&quot;___________________________________&quot;&lt;&lt;endl; cout&lt;&lt;&quot;抽签结果如下：&quot;&lt;&lt;endl; if(this-&gt;m_index==1) { random_shuffle(v1.begin(),v1.end()); for(vector&lt;int&gt;::iterator it=v1.begin();it!=v1.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } else { random_shuffle(v2.begin(),v2.end()); for(vector&lt;int&gt;::iterator it=v2.begin();it!=v2.end();it++) { cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } cout&lt;&lt;&quot;_________________________________&quot;&lt;&lt;endl; system(&quot;pause&quot;); cout&lt;&lt;endl;}void SpeechManager::speechContest(){ cout&lt;&lt;&quot;第&quot;&lt;&lt;this-&gt;m_index&lt;&lt;&quot;轮比赛正在比赛。。。&quot;&lt;&lt;endl; multimap &lt;double,int,greater&lt;double&gt;&gt; groupScore; int num=0; vector&lt;int&gt; v_Src; if(this-&gt;m_index==1) { v_Src=v1; } else { v_Src=v2; } for(vector&lt;int&gt;::iterator it=v_Src.begin();it!=v_Src.end();it++) { num++; //评委打分 deque&lt;int&gt; d; for(int i=0;i&lt;10;i++) { double score=(rand()%401+600)/10.f; cout&lt;&lt;score&lt;&lt;&quot; &quot;; d.push_back(score); } cout&lt;&lt;endl; sort(d.begin(),d.end(),greater&lt;double&gt;()); d.pop_back(); d.pop_front(); double sum=accumulate(d.begin(),d.end(),0); double avg=sum/(double)d.size(); this-&gt;m_Speaker[*it].m_Sorce[this-&gt;m_index-1]=avg; groupScore.insert(make_pair(avg,*it)); if(num%6==0) { cout&lt;&lt;&quot;第&quot;&lt;&lt;num/6&lt;&lt;&quot;组名次：&quot;&lt;&lt;endl; for(multimap&lt;double,int,greater&lt;double&gt;&gt;::iterator it=groupScore.begin();it!=groupScore.end();it++) { cout&lt;&lt;&quot;编号：&quot;&lt;&lt;it-&gt;second&lt;&lt;&quot; 成绩：&quot;&lt;&lt;this-&gt;m_Speaker[it-&gt;second].m_Sorce[this-&gt;m_index-1]&lt;&lt;endl; } int count=0; for(multimap&lt;double,int,greater&lt;double&gt;&gt;::iterator it=groupScore.begin();it!=groupScore.end()&amp;&amp;count&lt;3;it++,count++) { if(this-&gt;m_index==1) { v2.push_back((*it).second); } else { vVictory.push_back((*it).second); } } groupScore.clear(); } } cout&lt;&lt;&quot;第&quot;&lt;&lt;this-&gt;m_index&lt;&lt;&quot;轮比赛完毕。&quot;&lt;&lt;endl;}void SpeechManager::showScore(){ cout&lt;&lt;&quot;第&quot;&lt;&lt;this-&gt;m_index&lt;&lt;&quot;轮晋级选手如下：&quot;&lt;&lt;endl; vector&lt;int&gt; v; if(this-&gt;m_index==1) { v=v2; } else { v=vVictory; } for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) { cout&lt;&lt;&quot;选手编号:&quot;&lt;&lt;*it&lt;&lt;&quot; 姓名:&quot;&lt;&lt;this-&gt;m_Speaker[*it].m_Name&lt;&lt;&quot; 得分:&quot;&lt;&lt;this-&gt;m_Speaker[*it].m_Sorce[this-&gt;m_index-1]&lt;&lt;endl; } cout&lt;&lt;endl; system(&quot;pause&quot;); system(&quot;cls&quot;); show_Menu();}void SpeechManager::saveRecord(){ ofstream ofs; ofs.open(&quot;speech.csv&quot;,ios::out|ios::app); for(vector&lt;int&gt;::iterator it=vVictory.begin();it!=vVictory.end();it++) { ofs&lt;&lt;*it&lt;&lt;&quot;,&quot;&lt;&lt;this-&gt;m_Speaker[*it].m_Sorce[1]&lt;&lt;&quot;,&quot;; } ofs&lt;&lt;endl; ofs.close(); cout&lt;&lt;&quot;文件记录已经保存！&quot;&lt;&lt;endl; //更新文件不为空的状态 this-&gt;fileIsEmpty=false;}void SpeechManager::loadRecord(){ ifstream ifs(&quot;speech.csv&quot;,ios::in); //文件不存在的情况 if(!ifs.is_open()) { this-&gt;fileIsEmpty=true; cout&lt;&lt;&quot;文件不存在！&quot;&lt;&lt;endl; ifs.close(); return; } //文件空的情况 char ch; ifs&gt;&gt;ch; if(ifs.eof()) { cout&lt;&lt;&quot;文件为空！&quot;&lt;&lt;endl; this-&gt;fileIsEmpty=true; ifs.close(); return; } this-&gt;fileIsEmpty=false; ifs.putback(ch);//放回上面读取的 string data; int index=1; while(ifs&gt;&gt;data) { vector&lt;string&gt; v;//存放记录中的数据 //cout&lt;&lt;data&lt;&lt;endl; int pos=-1;//查到逗号位置 int start=0; while(true) { pos=data.find(&quot;,&quot;,start); if(pos==-1) { //没有找到 break; } else { string temp = data.substr(start,pos-start); //cout&lt;&lt;temp&lt;&lt;endl; v.push_back(temp); } start=pos+1; } this-&gt;m_Record.insert(make_pair(index++,v)); } ifs.close(); /*for(map&lt;int,vector&lt;string&gt;&gt;::iterator it=m_Record.begin();it!=m_Record.end();it++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;it-&gt;first&lt;&lt;&quot;届: &quot;&lt;&lt;&quot;冠军编号:&quot;&lt;&lt;it-&gt;second[0]&lt;&lt;&quot;分数:&quot;&lt;&lt;it-&gt;second[1]&lt;&lt;endl; }*/}void SpeechManager::showRecord(){ if(this-&gt;fileIsEmpty) { cout&lt;&lt;&quot;文件为空或文件不存在！&quot;&lt;&lt;endl; } else { for(int i=1;i&lt;=this-&gt;m_Record.size();i++) { cout&lt;&lt;&quot;第&quot;&lt;&lt;i&lt;&lt;&quot;届: &quot;&lt;&lt;endl; cout&lt;&lt;&quot;冠军编号:&quot;&lt;&lt;this-&gt;m_Record[i][0]&lt;&lt;&quot; 分数:&quot;&lt;&lt;this-&gt;m_Record[i][1]&lt;&lt;endl; cout&lt;&lt;&quot;亚军编号:&quot;&lt;&lt;this-&gt;m_Record[i][2]&lt;&lt;&quot; 分数:&quot;&lt;&lt;this-&gt;m_Record[i][3]&lt;&lt;endl; cout&lt;&lt;&quot;季军编号:&quot;&lt;&lt;this-&gt;m_Record[i][4]&lt;&lt;&quot; 分数:&quot;&lt;&lt;this-&gt;m_Record[i][5]&lt;&lt;endl; } } system(&quot;pause&quot;); system(&quot;cls&quot;);}void SpeechManager::clearRecord(){ cout&lt;&lt;&quot;是否确定清空数据文件：(y or n)&quot;&lt;&lt;endl; string select; cin&gt;&gt;select; if(select==&quot;y&quot;) { //确认清空 ofstream ofs(&quot;speech.csv&quot;,ios::trunc); ofs.close(); cout&lt;&lt;&quot;清空成功！&quot;&lt;&lt;endl; } else if(select==&quot;n&quot;) { system(&quot;pause&quot;); system(&quot;cls&quot;); } else { cout&lt;&lt;&quot;选项输入错误！&quot;&lt;&lt;endl; } }","link":"/2019/11/26/C++%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%88%90%E7%BB%A9%E6%89%93%E5%88%86%E7%A8%8B%E5%BA%8F/"},{"title":"Arch入教路","text":"我的linux入门是redhat系，跟着兄弟连用的centos。之后一直用的debian系，包括桌面日用，ubuntu，deepin，kubuntu，mint。早就听说了Arch邪教，纯命令安装系统，需要对linux系统有更深的了解，也借这个契机来试试。 第一步：虚拟机试探 官网下载安装包 启动vBox，开始进入安装界面 确保开启虚拟机的EFI支持 确保网络 1234567891011ip link#有线网络dhcpcd#无线网络iwctl[iwd] device list[iwd] station device scan[iwd] station device get-networks[iwd] station device connect SSIDping www.baidu.com 更新系统时间 123timedatectl set-ntp true#检查服务状态timedatectl status 系统分区 12fdisk -l cfdisk /dev/sdx (x替换成相应的硬盘字母，一般是a或b，默认gpt即可) 分区结果 1234mkfs.fat -F32 /dev/sda1mkfs.ext4 /dev/sda3mkswap /dev/sda2swapon /dev/sda2 挂载 123mount /dev/sda3 /mntmkdir /mnt/bootmount /dev/sda1 /mnt/boot 安装 12345vim /etc/pacman.d/mirrorlist# 找到中国镜像移到最上面或者添加Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch# pacstrap脚本安装arch基础pacstrap /mnt base base-devel linux linux-firmware dhcpcd vim 生成fstab挂载文件 12genfstab -U /mnt &gt;&gt; /mnt/etc/fstabcat /mnt/etc/fstab 切换根目录，进入安装好的系统 1arch-chroot /mnt 本地化设置 12345678910111213141516171819202122ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohcvim /etc/locale.genen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8locale-genvim /etc/locale.confLANG=en_US.UTF-8vim /etc/hostnamejack1024vim /etc/hosts127.0.0.1 localhost::1 localhost127.0.1.1 jack1024.localdomain jack1024#设置root密码passwd 设置微码引导 1234#intel CPUpacman -S intel-ucode#AMD CPUpacman -S amd-ucode 安装引导 12345678910pacman -S os-prober ntfs-3g grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB#生成并查看引导配置grub-mkconfig -o /boot/grub/grub.cfgcat /boot/grub/grub.cfg# 重启umount -R /mntreboot 出现这个说明安装一切搞定，重启后进入邪教生活。 常用软件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#重启后登录jack1024 login: rootpassword: ****#联网dhcpdping www.baidu.comsystemctl enable dhcpcd#配置国内源vim /etc/pacman.conf#文档末尾添加[multilib]Include = /etc/pacman.d/mirrorlist[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch#安装 archlinuxcn-keyring 包以导入 GPG keypacman -S archlinuxcn-keyring#更新pacman -Syyu#安装常用软件pacman -S openssh man gitsystemctl start sshdsystemctl enable ssdd.service#添加用户useradd -m -G wheel -s /bin/bash usernamepasswd username#给用户sudo权利pacman -S sudo#第一种方法su - rootchmod u+w /etc/sudoersvim /etc/sudoers#找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)chmod u-w /etc/sudoers#第二种方法ln -s /usr/bin/vim /usr/bin/vivisudo%wheel ALL=(ALL) ALL#安装zsh#不知道为什么虚拟机无法从github clone，所以采用giteewget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh#找到以下部分# Default settingsZSH=${ZSH:-~/.oh-my-zsh}REPO=${REPO:-ohmyzsh/ohmyzsh}REMOTE=${REMOTE:-https://github.com/${REPO}.git}BRANCH=${BRANCH:-master}#把REPO=${REPO:-ohmyzsh/ohmyzsh}REMOTE=${REMOTE:-https://github.com/${REPO}.git}#替换为REPO=${REPO:-mirrors/oh-my-zsh}REMOTE=${REMOTE:-https://gitee.com/${REPO}.git}chmod 777 install.shbash install.sh# 然后参考之前的linux工作环境配置那篇博客自定义zsh# 由于虚拟机暂时无法访问github，需要通过gitee安装一些插件git clone https://gitee.com/mirror-github/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightinggit clone https://gitee.com/lxgyChen/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestiongit clone https://gitee.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k 12345678# 经过多次试错终于能让虚拟机从github拉取项目了用浏览器访问 IPAddress.com 使用 IP Lookup 工具获得github.comgithub.global.ssl.fastly.netraw.githubusercontent.com三个域名的ip地址然后写入/etc/hosts中即可 安装图形界面 1234567891011121314151617181920212223242526272829303132#安装声卡驱动sudo pacman -S alsa-utils pulseaudio pulseaudio-alsa#查看显卡型号lspci | grep VSA#查看独显型号lspci | grep 3D#参考官网驱动表进行安装sudo pacman -S 驱动包名#安装输入设备驱动pacman -S xf86-input-libinput#安装笔记本触摸板驱动sudo pacman -S xf86-input-synaptics#安装中文字体sudo pacman -S ttf-dejavu wqy-bitmapfont wqy-microhei wqy-zenhei noto-fonts noto-fonts-emoji# xorg用于实现窗口系统，sddm是登陆管理器，登陆管理器还有lightdm等等，但是个人比较推荐sddm，sddm可以支持多个桌面环境的切换。pacman -S xorg xorg-server#安装kde桌面pacman -S plasma#安装kde应用pacman -S kde-applications#安装sddm图形登录界面sudo pacman -S sddm sddm-kcmsystemctl enable sddm#安装网络管理sudo pacman -S net-tools networkmanagersudo systemctl enable NetworkManager virtualbox安装增强功能（经过反复折腾，最终安装失败） 1234sudo pacmansudo pacman -S linux-headerssudo pacman -S base-devel#理论上安装以上就行了，但是还是失败了，不知道为什么 安装主步骤： 联网 更新时间 创建分区 格式化挂载点 挂载分区 国内镜像置顶 拉取安装件（包括devel） 生成挂载文件 切换根目录 调整时区 生成配置文件 本地化修改 修改root密码 网络工具安装 安装微码引导 pacman包管理 简洁高效 拥有神器：Arch User Repository 123456789101112131415161718192021222324252627282930313233343536373839404142# 查看本地软件仓库更新情况pacman -Sy# 强行更新本地软件仓库pacman -Syy# 从本地仓库更新软件pacman -Su# 优雅の一步：同步并更新所有pacman -Syu#滚动更新pacman -Syyu# 安装软件pacman -S 软件名# 通过正则表达式搜索软件pacman -Ss 正则表达式# 清除本地软件仓库pacman -Sc# 完全清空包缓存（Warning: 关于pacman -Scc，仅在你确定不需要做任何软件包降级工作时才这样做。pacman -Scc会从缓存中删除所有软件包）pacman Scc# 仅仅删除软件本身（不推荐）pacman -R 软件名# 删除软件、它的依赖（推荐）pacman -Rs 软件名# 删除软件、它的依赖、全局配置文件，本地配置文件不会删除（推荐）pacman -Rns 软件名# 列出已安装软件包pacman -Q# 列出自己安装的软件pacman -Qe# 列出安装的软件（只有名字）pacman -Qq# 通过正则查询本地安装的软件pacman -Qs 正则表达式# 列出所有孤儿包pacman -Qdt# 删除所有孤儿包pacman -R $(pacman -Qdtq)# 查新哪些包拥有指定文件pacman -Qo 文件名 AUR助手 Arch 用户软件仓库 通常称为 AUR，是给 Arch 用户的基于社区的软件存储库。 什么是 AUR（Arch 用户软件仓库）？ Arch 用户软件仓库 通常称为 AUR，是给 Arch 用户的基于社区的软件存储库。 根据软件包在 AUR 社区的流行程度，用户编译的软件包会进入到 Arch 的官方存储库。 什么是 AUR 助手？ AUR 助手是一个包装程序，允许用户从 AUR 存储库安装软件包，而无需手动干预。 很多用例实现了自动化，比如包搜索、解决依赖关系、检索和构建 AUR 包、Web 内容检索和 AUR 包提交之类。 12345678# Yay 是 Arch Linux 下基于 CLI 的最佳 AUR 助手，使用 Go 语言编写。Yay 是基于 yaourt、apacman 和 pacaur 设计的。# 这是最合适推荐给新手的 AUR 助手。类似于 Pacman，其使用方法和 pacman 中的命令和选项很相似，可以让用户在搜索过程中找到匹配的软件包提供程序，并进行选择。git clone https://aur.archlinux.org/yay.gitcd yay-gitmakepkg -si# 然后就可以直接使用yay命令了，和pacman几乎一致的命令 用debian系的小伙都惊呆了，AUR是真的牛皮","link":"/2021/03/17/Arch%E5%85%A5%E6%95%99%E8%B7%AF/"},{"title":"HTML快速回顾","text":"初识HTML Hyper Text Markup Language 超文本：文字，图片，音频，视频，动画等 HTML5： HTML5和CSS3是未来发展趋势 W3C：World Wide Web Consortium万维网联盟，Web技术领域最权威和具影响力的国际中立性技术标准机构，W3C标准包括： 结构化标准语言（HTML，XML） 表现标准语言（CSS） 行为标准（DOM，ECMAScript） HTML基本结构 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;My Frist Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; My First Page &lt;/body&gt;&lt;/html&gt; 、等成对的标签，分别叫**开放标签**和**闭合标签** 网页基本标签123456789101112131415161718192021&lt;!--DOCTYPE告诉浏览器使用什么规范--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;!--中文网站设置为zh-CN--&gt;&lt;!--网页头部--&gt;&lt;head&gt; &lt;!--描述网站一些信息，可用做seo--&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!--页面关键词，用于被搜索引擎收录--&gt; &lt;meta name=&quot;keywords&quot; content=&quot;学习，记录&quot;&gt; &lt;!--页面描述，用于搜索引擎收录--&gt; &lt;meta name=&quot;excerpt&quot; content=&quot;我的第一个网页&quot;&gt; &lt;!--用于控制页面缩放--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!--网页标题--&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;!--网页主体--&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标题标签 123456&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h4&gt;四级标题&lt;/h4&gt;&lt;h5&gt;五级标题&lt;/h5&gt;&lt;h6&gt;六级标题&lt;/h6&gt; 段落标签 1&lt;p&gt;段落内容&lt;/p&gt; 换行标签 12&lt;br/&gt;&lt;br&gt; 水平线标签 12&lt;hr/&gt;&lt;hr&gt; 字体样式标签 12&lt;strong&gt;粗体&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt; 注释和特殊符号 123456&lt;!--注释--&gt;&amp;nbsp;空格&amp;gt;大于&amp;lt;小于&amp;copy;版权符号&lt;!--更多的符号可以百度--&gt; 图像，超链接，网页布局 常见图像格式：JPG，GIF，PNG，BMP 1&lt;img src=&quot;path&quot; alt=&quot;替代文字&quot; title=&quot;鼠标悬停文字&quot; width=&quot;x&quot; height=&quot;y&quot;/&gt; 链接标签： 1234567891011121314151617181920&lt;a href=&quot;path&quot; target=&quot;目标窗口位置&quot;&gt;text/img&lt;/a&gt;&lt;!--target: blank新标签网页中打开 parent父框架集中打开 self当前网页中打开（默认） top在整个窗口中打开 framename指定的框架中打开--&gt;&lt;!--锚链接：通过name跳--&gt;&lt;a name=&quot;point&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#point&quot;&gt;&lt;/a&gt;&lt;!--不同页面也可以锚链接--&gt;&lt;a href=&quot;xxx.html#point&quot;&gt;&lt;/a&gt;&lt;!--邮件链接--&gt;&lt;a href=&quot;mailto:yangfanjack1024@qq.com&quot;&gt;点击联系我&lt;/a&gt;&lt;!--QQ链接--&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://wpa.qq.com/msgrd?v=3&amp;uin=你的qq号&amp;site=qq&amp;menu=yes&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://wpa.qq.com/pa?p=2:你的qq号:52&quot; alt=&quot;点击这里给我发消息&quot; title=&quot;点击这里给我发消息&quot;/&gt;&lt;/a&gt; 行内元素和块元素 块元素： 无论内容多少，该元素独占一行 p标签，h1-h6标签，div元素…… 行内元素： 内容撑开宽度，左右都是行内元素的可以旁在一行 a元素，strong元素，em元素，span标签…… 列表，表格，媒体元素 列表： 信息资源结构化，条理化地展示出来，方便浏览者快速获得相应信息 分类： 无序列表 有序列表 自定义列表 1234567891011121314151617181920212223242526&lt;!--有序列表--&gt;&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;!--无序列表--&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!--自定义列表--&gt;&lt;dl&gt; &lt;dt&gt;学科&lt;/dt&gt; &lt;dd&gt;Java&lt;/dd&gt; &lt;dd&gt;设计模式&lt;/dd&gt; &lt;dd&gt;数据库&lt;/dd&gt; &lt;dt&gt;城市&lt;/dt&gt; &lt;dd&gt;成都&lt;/dd&gt; &lt;dd&gt;北京&lt;/dd&gt; &lt;dd&gt;上海&lt;/dd&gt;&lt;/dl&gt; 表格 简单通用，结构稳定 基本结构： 单元格 行 列 跨行 跨列 1234567891011121314151617181920212223242526272829303132333435&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Mariah Carey&lt;/td&gt; &lt;td&gt;female&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Sam Smith&lt;/td&gt; &lt;td&gt;male&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;!--跨行 or 跨列--&gt;&lt;table border=&quot;1px&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;歌手信息&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;欧美歌手&lt;/td&gt; &lt;td&gt;Mariah Carey&lt;/td&gt; &lt;td&gt;female&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Sam Smith&lt;/td&gt; &lt;td&gt;male&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 视频 &amp; 音频 video and audio 12&lt;video src=&quot;视频资源路径&quot; controls autoplay&gt;&lt;/video&gt;&lt;audio src=&quot;音频资源路径&quot; controls autoplay&gt;&lt;/audio&gt; 页面结构分析 header：标题头部区域内容 footer：标记脚步区域内容 section：Web页面中的一块独立区域 article：独立的文章内容 aside：相关内容或应用 nav：导航类辅助内容 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;网页头部&lt;/header&gt; &lt;section&gt; 网页主体 &lt;/section&gt; &lt;footer&gt;网页脚部&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; iframe内联框架 &amp; 框架集1234567891011&lt;iframe src=&quot;path&quot; name=&quot;框架标识名&quot; frameboder=&quot;0&quot; width=&quot;1000px&quot; height=&quot;800px&quot;&gt;&lt;/iframe&gt;&lt;a href=&quot;path&quot; target=&quot;框架标识名&quot;&gt;跳转到内联框架&lt;/a&gt;&lt;!--iframe对seo不友好，一般不建议使用--&gt;&lt;!--frameset可以使用，能用来做网页布局--&gt;&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot; /&gt; &lt;frame src=&quot;frame_b.htm&quot; /&gt; &lt;frame src=&quot;frame_c.htm&quot; /&gt;&lt;/frameset&gt; 表单及表单应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!--action：表单提交的位置，可以是网站，也可以是一个请求处理地址method： get方式提交：url中可以看见我们提交的信息，高效但不安全，只能传输少量数据 post方式提交：比较安全，可以传输大量数据--&gt;&lt;form action=&quot;path&quot; method=&quot;get/post&quot;&gt; &lt;!--输入类--&gt; &lt;input type=&quot;text&quot; value=&quot;userName&quot; name=&quot;text&quot; maxlength=&quot;10&quot; /&gt; &lt;input type=&quot;password&quot; value=&quot;password&quot; name = &quot;password&quot; maxlength=&quot;10&quot; /&gt; &lt;input type=&quot;hidden&quot; value=&quot;id&quot; name=&quot;id&quot;/&gt;&lt;br/&gt; &lt;!--选择类--&gt; &lt;input type=&quot;radio&quot; name = &quot;sex&quot; value = &quot;1&quot;/&gt;&lt;/br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fav&quot; checked=&quot;false&quot; value=&quot;1&quot;/&gt; &lt;!--文件类--&gt; &lt;input type=&quot;file&quot; name = &quot;file&quot; multiple accept=&quot;image/gif, image/jpeg&quot;/&gt; &lt;!--按钮类--&gt; &lt;input type=&quot;button&quot; value=&quot;纯按钮&quot; /&gt; &lt;input type=&quot;submit&quot; value = &quot;提交&quot; /&gt; &lt;input type=&quot;reset&quot; value = &quot;重置&quot; /&gt; &lt;input type=&quot;image&quot; src=&quot;图片资源路径&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;button type=&quot;button&quot;&gt;无行为&lt;/button&gt; &lt;button&gt;默认是submit行为&lt;/button&gt; &lt;!--下拉框--&gt; &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;2&quot; selected&gt;上海&lt;/option&gt; &lt;/select&gt; &lt;!--文本域标签--&gt; &lt;textarea name = &quot;introduce&quot; maxlength=&quot;500&quot; cols=&quot;20&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;!--label：输入标签的文字描述标签--&gt; &lt;label for=&quot;sex1&quot;&gt;女&lt;/label&gt; &lt;input id = &quot;sex1&quot; type=&quot;radio&quot; name = &quot;sex&quot; value = &quot;1&quot;/&gt; &lt;!--带验证的标签--&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot;/&gt; &lt;input type=&quot;url&quot; name=&quot;url&quot;/&gt; &lt;input type=&quot;number&quot; name=&quot;number&quot; max=&quot;100&quot; min=&quot;0&quot; step=&quot;10&quot;/&gt; &lt;!--滑块--&gt; &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; name=&quot;voice&quot; step=&quot;2&quot;/&gt; &lt;!--搜索--&gt; &lt;input type=&quot;search&quot; name=&quot;searchString&quot;/&gt;&lt;/form&gt; 表单的限制（三个属性）： 隐藏域：hidden 只读：readonly 禁用：disabled 表单初级验证 为啥要进行表单验证？ 保证数据安全性 减轻服务器压力 初级验证（三个属性）： placeholder：提示信息 required：非空判断 pattern：正则表达式判断","link":"/2021/01/08/HTML%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"},{"title":"IDEA中tomcat的神奇走位","text":"tomcat服务器的三种部署方式： 直接将项目放进webapps目录下即可 /项目名就是访问路径 可以简化部署：将项目里的全部文件打一个war包，然后把war包放进webapps里面会自动解压缩。删除war包会自动删除项目。 conf/server.xml配置文件中，加上&lt;Context docBase=项目地址 path=虚拟访问路径 /&gt; 更加灵活些，范文路径是path，不一定是目录名 但是修改server.xml，不是很安全 热部署：在/conf/Catalina/localhost下面创建任意名称的xml文件，里面加上&lt;Context docBase=项目地址 /&gt;，范文路径就是xml文件的名称 IDEA中的tomcat 与eclipse或则myeclipse那样直接部署就在在tomcat的安装文件夹里生成部署文件不同，IDEA会为每一个tomcat部署的Web项目单独建立一份相关文件，里面包含配置文件，日志和临时目录（如下图），在自己的家目录下：C:\\Users\\你的用户名\\.IntelliJIdea2019.3\\system\\tomcat\\ 重点：这里的文件对应着tomcat安装根目录下的对应文件，conf目录下是配置文件，idea默认就是热部署，就是在这里面对应的位置生成xml文件。work目录里面是临时文件，包含服务器端jsp被转化为servlet的java代码文件和class字节码文件。 tomcat服务器真正访问的是out目录(tomcat部署的web项目)，而out目录下的部署的项目对应着web工作空间目录下的所有资源，idea的out目录和web目录都在自己创建的项目地址下。 WEB-INF目录下有个classes目录，里面的java字节码文件是从src目录导过来的。 WEB-INF目录是个安全目录，其下的资源不能直接被浏览器访问","link":"/2020/03/18/IDEA%E4%B8%ADtomcat%E7%9A%84%E7%A5%9E%E5%A5%87%E8%B5%B0%E4%BD%8D/"},{"title":"JDBC","text":"JDBCJDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 操作步骤 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 123456789101112131415161718//1. 导入驱动jar包//2.注册驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//3.获取数据库连接对象//如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);//4.定义sql语句String sql = &quot;update account set balance = 500 where id = 1&quot;;//5.获取执行sql的对象 Statement//prepareStatement(String sql)解决sql注入问题Statement stmt = conn.createStatement();//6.执行sqlint count = stmt.executeUpdate(sql);//7.处理结果System.out.println(count);//8.释放资源stmt.close();conn.close(); 几个重要对象 DriverManager 123456789//通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块//mysql5之后的驱动jar包可以省略注册驱动的步骤。static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can't register driver!&quot;); }} Connection 12345678910Statement createStatement();PreparedStatement prepareStatement(String sql);//事务管理//开启事务:调用该方法设置参数为false，即开启事务setAutoCommit(boolean autoCommit);//提交事务commit();//回滚事务rollback(); Statement 123456789//可以执行任意的sqlboolean execute(String sql); //执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句//返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。int executeUpdate(String sql);//执行DQL（select)语句ResultSet executeQuery(String sql); Resultment 1234567891011121314151617//getXxx(参数):获取数据//Xxx：代表数据类型 如： int getInt() , String getString()//参数：//1. int：代表列的编号,从1开始 如： getString(1)//2. String：代表列名称。 如： getDouble(&quot;balance&quot;)//使用//循环判断游标是否是最后一行末尾。while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);} PreparedStatement 123//SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题//输入用户随便，输入密码：a' or 'a' = 'aselect * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' JDBC工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } }} 数据库连接池概念：其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 实现 1. 标准接口：`DataSource javax.sql`包下的 * 获取连接：`getConnection()` * 归还连接：`Connection.close()`。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 12345678910111213141516171819//C3P0/**1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb jdbc.username=root jdbc.password=root * 路径：直接将文件放在src目录下即可。3. 创建核心对象 数据库连接池对象 ComboPooledDataSource4. 获取连接： getConnection**///1.创建数据库连接池对象DataSource ds = new ComboPooledDataSource();//2. 获取连接对象Connection conn = ds.getConnection(); 123456789101112131415161718//Druid/**1. 导入jar包 druid-1.0.9.jar2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下3. 加载配置文件。Properties4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory5. 获取连接：getConnection**///3.加载配置文件Properties pro = new Properties();InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);pro.load(is);//4.获取连接池对象DataSource ds = DruidDataSourceFactory.createDataSource(pro);//5.获取连接Connection conn = ds.getConnection(); JDBCTemplate Spring框架对JDBC的简单封装为Spring JDBC。提供了一个JDBCTemplate对象简化JDBC的开发 实现 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 **update():**执行DML语句。增、删、改语句 123456789101112131415161718192021222324252627282930/*** 1. 修改1号数据的 salary 为 10000*/@Testpublic void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count);}/*** 2. 添加一条记录*/@Testpublic void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count);}/*** 3.删除刚才添加的记录 */@Testpublic void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count);} **queryForMap():**查询结果将结果集封装为map集合，将列名作key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 123456789101112/*** 4.查询id为1001的记录，将其封装为Map集合* 注意：这个方法查询的结果集长度只能是1*/@Testpublic void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}} **queryForList():**查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 123456789101112/*** 5. 查询所有记录，将其封装为List */@Testpublic void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); }} **query():**查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) 123456789101112/*** 6. 查询所有记录，将其封装为Emp对象的List集合*/ @Testpublic void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); }} queryForObject：查询结果，将结果封装为一个对象 一般用于聚合函数的查询 12345678910/*** 7. 查询总记录数*/ @Testpublic void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total);}","link":"/2021/02/18/JDBC/"},{"title":"JavaScript类型转换","text":"强类型定义语言和弱类型定义语言1）强类型定义语言： 强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 2）弱类型定义语言： 数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！ 例如：Python是动态语言，是强类型定义语言（类型安全的语言）; VBScript是动态语言，是弱类型定义语言（类型不安全的语言）; JAVA是静态语言，是强类型定义语言（类型安全的语言）。 js中的数据类型 基本数据类型：string, number, boolean, undefined, null 引用数据类型：Object, Array, Function 转化规律显示转换 toString()方法：null和undefined没有该方法 null和undefined有String()函数，该函数适应性更加好 Number()函数： 字符串转数字：只能转纯数字字符串，如果是空串或空格串，转为0，否则NaN 布尔转数字：true-&gt;`;false-&gt;0 Null转数字：结果为0 undefined转数字：结果为NaN parseInt()函数和parseIntFloat()函数:将字符串中有效的整数部分提出来转化为整数。如果是对非字符串使用该方法，则会先将其转化为string，然后再运算。 Boolean()函数： number:只有0和NaN是false string:只有空串是false,甚至空格串也是true undefined:false null:false 对象类型：都是true JavaScript中的运算符隐式转换 “+”运算：对非number的值进行算数运算时，会先将这些值转化为number,然后再运算（string和NaN除外） 任何值和NaN做算数运算结果都是NaN 如果两个字符串相加，会拼串。 任何值和字符串做“+”运算，都需要将其转化为字符串，然后拼串 numbe类型+””(空串)：隐式将number转化为string，和String()和toString()功能相同 对于其他算数运算(“-“,”*”,”/“)，非number都会转化为number 根据第6条，可知：string类型-0；string类型*1；string类型/1都可以转化为number类型（加0不可以，0会转为string） 正号：对于非number,会先转化为number类型，”+string”也可以将string类型转化为number类型。 !取反符:对非boolean双重取反”!!”，可以将非Boolean类型转化为Boolean类型","link":"/2019/12/16/JavaScript%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"JavaWeb核心:理解servlet","text":"Servlet定义 物理上是一个运行在服务器端的一个小程序（serve applet），可以理解为就是一个接口（规则），定义了服务器端的Java类被tomcat识别的规则 我们需要自定义一个类，来实现servlet接口，复写接口的的方法，tomcat就可以识别这个类，我们就称这个类是个servlet 实际操作： 创建JavaEE项目 定义一个类，实现servlet接口 重写接口中的抽象方法 在web.xml中配置servlet Servlet的执行原理servlet中的java类和javase中的普通java类是不一样的，它的运行依赖tomcat这个web容器，自己没有main方法。实现的servlet方法不需要自己调用，服务器会自己按照需要调用 当服务器接收到客户端浏览器的请求后，会解析请求的URL路径，获取访问的servlet的资源路径 查找web.xml文件，是否有对应的标签体内容 如果有，则会找到对应的全类名 tomcat会将字节码文件内加载进内存，并且创建其对象 tomcat按照需要自己调用方法 Servlet中的生命周期sevlet中的方法 init方法：servlet被创建时执行 service方法：每一次servlet被访问时执行 destroy方法：在服务器正常关闭时执行 上面三个方法对应servlet的三个生命周期 servletConfig方法：获得servletconfig对象，就是servlet的配置对象 getServletInfo方法：获得servlet的一些信息，版本，作者… Servlet被创建 默认情况下，第一次被访问时，servlet被创建，加载资源 非默认时，可以子啊web.xml中指定servlet的创建时机，配置标签的值，正数表示在服务器启动时创建，负数表示第一次被访问时创建 一个servlet类在内存中只有一个对象，是单例模式。多用户同时访问时，可能不安全，但是加锁会严重影响性能，所有尽量不要在servlet中定义成员变量线程公共资源，定义局部变量就没有安全问题了，因为局部变量在栈中，线程私有。 Servlet提供服务 每次访问都会执行service方法 Servlet被销毁 服务器关闭时，Servlet被销毁，释放资源。但是只有服务器正常关闭，才会执行destroy方法。 Servlet3.0 选择JavaEE时，选择servlet版本3.0以上，可以不选择web.xml了 可以通过注解配置：@WebServlet，不需要web.xml配置文件中配置了 Servlet体系结构 Servlet接口，GenericServlet抽象类，HttpServlet抽象类 GenericServlet抽象类继承Servlet抽象类，已经空实现了除了service方法之外的所有抽象方法。所以，可以让自定义的servelt类继承GenricServlet类，减少工作量。 HttpServlet抽象类也是继承于Servlet接口，并且由doPost和doGet方法，我们可以让自定义的Servlet类继承HttpServlet类复写doGet和doPost方法，但是service方法不用复写了，HttpServlet抽象类已经帮你写好了。用来根据post和get的请求方式做出不同判断。 Servlet相关配置 urlpartten：Servlet的访问路径 一个Servlet可以定义多个访问路径：@webServlet({“d4”,”d44”,”d444”}) 路径定义规则： /XXX /XXX/XX：多层路径，目录结构 *.do Servlet和JSP？ 先上一张图： 要理解servlet和jsp的区别与联系，我们需要回顾javaWeb的发展历史： 最开始的web，用户使用浏览器向web服务器发送的请求都是静态的资源（html,css,javascript）。为了能够根据不同用户的不同请求来动态的处理并且返回资源，servlet就出现了。 前面提到了servlet是在服务器端的java代码，通过java这个高级语言就能动态的处理数据和资源，然后把经过动态处理后的静态资源再打回浏览器客户端。但是有一个问题，servlet类中需要写大量的冗余的out.write代码写html，这就导致后端人员都想骂娘，然后，jsp就诞生了。 jsp是sun公司借鉴微软的asp后，推出的直接在原来的静态页面html中嵌入java代码的技术。但是，这样虽然可以避免冗余，但是前端人员必须要懂后端知识，并且在html中插入大量的java代码会是jsp文件代码看起来凌乱不堪，自己写完了都看不懂，更不要说多人协作了。所以再后来，基于MVC模式的JSP+Servlet+JavaBean就应运而生了（也就是上面图中所表达的） 所以，总结就是： 一个java类必须是serevlet类才能被浏览器访问到，jsp本质上就是一个servlet，jsp简化servlet的繁琐写html代码的操作 servlet是在java代码中写html，jsp是在html中写java代码 注：关于MVC的具体以及Web发展后期框架的出现以及前后端分离的知识现在还在学习中，以后会陆续写出来。","link":"/2020/03/18/JavaWeb%E6%A0%B8%E5%BF%83-%E7%90%86%E8%A7%A3servlet/"},{"title":"Java-GC机制","text":"背景： Java的内存管理实际上就是对象的管理，其中包括对象的分配和释放。对于程序员来说，分配对象使用new关键字；释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”.GC将负责回收所有”不可达”对象的内存空间。 堆空间是用来存储new出来的对象的，当new出来的对象填充满时，会让堆爆掉，程序就挂了，这显然时不被允许的。 Garbage Collection的机制就是判断堆内存中哪些对象能被删除，判断的标准就是GCRoot GCRoot GCRoot：指向堆中的对象的引用，包含： 栈上的引用直接或者间接地被引用 方法区上全局的的Static变量&amp;常量直接或者间接被引用 本地方法栈上的的C++直接或者间接被引用 那些可以直接存在的，没有和GCRoot有相连的关系的对象可以被删除 GC机制清理堆中垃圾的思路 标记-清理：在堆中要删除对象后面打标 缺点：标记和清除两次扫描会严重浪费时间，同时会产生内存碎片 优点：不需要额外空间 标记-整理：堆中删除的对象留下的空间能聚集在一起 缺点：代价太大，除了两次扫描还要把所有整理后的对象前移 优点：减少了内存碎片 复制算法：将整个内存一分为二，将1区需要删除的标记，然后将没打标记的对象紧凑复制到2区，既避免了内存碎片问题，整个内存开销又不是很大。 缺点：需要两倍内存空间 优点：不会产生碎片问题 最佳使用场景：对象的成活率较低（新生区就是这样） 实际的GC：将堆区划分 新new的对象都会在Eden（伊甸园）出生，当Eden快满的时候会触发young区域的GC，采用复制算法，将Eden中没有标记的对象复制到Survivor0（幸存0）区域 Eden很大，Survivor更小。因为对象都有一个特点：朝生夕死，很容易就夭折了，生死率大概是1：8 需要两块Survivor区交替工作（From和To的反复交替：谁空谁是To） E+S1 复制到 S0 E+S0 复制到 S1 E+S1 复制到 S0 …（如此交替工作） 一个对象每幸存1次，其年龄就会+1，如果满了6岁，（满了6岁基本60岁都不会清理了）就不会复制到Survivor区了，就会直接到Old区了 大对象（例：1000万个元素的int数组）会直接存放到Old区。 Old区满了也会触放GC，OldGC一般也会伴随YoungGC，所以，Old区满了会触发FullGC，此时会触发stoptheworld，java程序全部暂停，报错OOM（java.lang.OutOfMemory :Java heap space），全力进行垃圾回收（采用标记清理 or 标记整理算法） 总结： 标记-清理和标记-整理 主要用在 FullGC机制 复制算法只要用在 YoungGC机制 内存效率(时间复杂度)：复制算法&gt;标记清除&gt;标记整理 内存整齐度：复制算法=标记整理&gt;标记清除 内存利用率：标记整理=标记清除&gt;复制算法 没有最好的算法，只有最合适的算法 垃圾收集器： 年轻代：ParNew：复制算法 老年代：CMS：标记-清理 最新版的JDK采用的是：G1垃圾收集器 永久区 该区域常驻内存，用来存放JDK自身携带的Class对象等。存储的是java运行时的一些环境。 该区域不存在垃圾回收，关闭虚拟机就会释放该区域的内存 jdk1.6之前：永久代，常量池在方法区 jdk1.7：永久代慢慢退化了，常量池在堆中 jdk1.8之后：无永久代，整个方法区（包含常量池）都在元空间 JDK8之后的堆内存模型： 这个元空间：逻辑上存在，物理上不存在 堆内存参数调优初识：在IDEA中，VM options中添加几个参数，可以指定最大内存，最小内存，和是否打印GC的详细信息 1-Xms8m -Xmx8m -XX:+PrintGCDetails 相关题目 JVM的内存模型和分区~详细到每个区都放什么？ 堆里面的分区有哪些？Eden，from，to，老年区，说说他们的特点？ GC的算法有哪些：标记清除法，标记整理，引用计数法 轻GC和中GC分别在什么时候发生？ 12#定义对象进入老年区的时间，默认是15-XX:MaxTenuringThreshold=15","link":"/2020/12/21/Java-GC%E6%9C%BA%E5%88%B6/"},{"title":"Java中加载配置文件的几种方法","text":"Java的常用web框架中会有很多配置文件，这些配置文件都是为了降低代码耦合性而从代码中剥离出来的。为了在程序运行时动态地加载这些文件进内存，需要加载这些配置文件，学习过程中发现有很多种方法都能将这些配置文件加载进内存，需要总结下方便记忆。 基于ClassLoader加载配置文件12345Properties properties = new Properties();InputStream in = 当前类名.class.getClassLoader().getResourceAsStream(&quot;配置文件相对路径&quot;);properties.load(in);System.out.println(properties.getProperty(&quot;username&quot;));System.out.println(properties.getProperty(&quot;password&quot;)); 基于Resources读取配置文件12345678InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User user = userMapper.findById(1);System.out.println(user);sqlSession.close(); 基于ResourceBundle读取配置文件123456ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;配置文件相对路径&quot;);System.out.println(resourceBundle.getString(&quot;username&quot;));InputStream in3 = new FileInputStream(new File(filePath));ResourceBundle resourceBundle2 = new PropertyResourceBundle(in3);System.out.println(resourceBundle2.getString(&quot;username&quot;));","link":"/2021/03/21/Java%E4%B8%AD%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"Martin Fowler关于微服务架构的论文译文","text":"中文译文地址 Martin Flower原论文地址","link":"/2020/11/21/Martin-Fowler%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BA%E6%96%87%E8%AF%91%E6%96%87/"},{"title":"Nginx","text":"Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 应用场景 http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 HTTP服务器 将静态网站文件 上传到服务器的/usr/local/nginx/html下即可访问 虚拟主机 虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器。虚拟主机技术极大的促进了网络技术的应用和普及。同时虚拟主机的租用服务也成了网络时代的一种新型经济形式。 端口绑定域名绑定反向代理负载均衡","link":"/2021/03/18/Nginx/"},{"title":"RPM打包初试","text":"1434 rpm打包需要一个独立的打包目录 BUILD：编译rpm包的临时目录 BUILDROOT：编译后生成的软件临时安装目录 RPMS：最终生成的可安装rpm包存放目录 SOURCES：所有源文件和补丁文件存放目录 SPECS：存放SPEC文件的目录 SRPMS：软件最终的rpm源码格式存放路径 打包需要从源码sources开始，将存放源码的目录打包压缩成tar.gz格式，放进SOURCES目录中 然后在SPECS目录中创建并编辑spec文件 最后根据spec文件进行打包rpm -ba rpmbuild/SPECS/xxx.spec","link":"/2021/12/01/RPM%E6%89%93%E5%8C%85%E5%88%9D%E8%AF%95/"},{"title":"Windows包管理器scoop","text":"对于熟悉linux的同学，apt和yum等等这些包管理器肯定很熟悉，Windows下也有一个类似的好用的包管理器scoop，用scoop安装一些环境配置软件就会省去手动配置环境变量的步骤，并且里面的软件还很齐全，wonderful! 安装 管理员身份打开终端，设置用户变量 1[environment]::setEnvironmentVariable('SCOOP','D:\\software\\scoop','User') 启用 1$env:SCOOP='D:\\software\\scoop' install scoop 1iex (new-object net.webclient).downloadstring('https://get.scoop.sh') 配置全局变量 1[environment]::setEnvironmentVariable('SCOOP_GLOBAL','D:\\software','Machine') 启用 1$env:SCOOP_GLOBAL='D:\\software' 使用 1234567891011scoop help：查看scoop的使用方式和命令scoop status：检查scoop是否最新scoop update：更新scoop库scoop search XXX：搜索软件scoop install XXX：安装软件scoop insrall -g XXX：全局安装软件scoop uninstall XXX：卸载软件scoop uninstall -g XXX：全局卸载软件 scoop list：列出安装的软甲scoop bucket list：列出安装的仓库scoop bucket add XXX：添加仓库 常用软件 7zip git aria2 vim gcc nodejs oraclejdk tomcat mysql57123456789#手动开启mysql --standalonemysql --console#注册mysql为服务mysqld --install MySQL --defaults-file=&quot;D:\\software\\apps\\mysql57\\current\\my.ini&quot;#停止服务sc stop MySQL#删除服务sc delete MySQL","link":"/2020/03/03/Windows%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8scoop/"},{"title":"Win10桌面美化","text":"先放上一张我的桌面： 前言：Windows操作系统经过几十年的发展，到目前已经相当成熟，在个人桌面操作系统中也是处于霸主地位，但是对于我而言，如果根据自我审美和操作习惯对Win10进行美化，无疑也是会提高舒适度和办公学习效率的。 everything+Wox 这东西能让你的桌面干干净净，再也不用在桌面码满快捷方式，还能一定程度上摆脱鼠标的束缚，查找软件，文档，甚至网页都是可以的，还有很多功能我没有探索到的。 其实关于全局搜索软件的尝试，我最开始是用的listary，很好用，就是有个缺点，能改样式的高级版收费。所以我就换了Wox，注意：要让Wox能全局搜索，需要配合everything，两个软件都设置成开机自启，美滋滋。 RocketDock win10的任务栏和Mac、Linux的Dock栏的喜爱见仁见智，不过我觉得Mac的dock栏的设计确实更加具有美感，效率性很不差。经过我的一番搜索，其实有很多：ObjectDock，BitDock等等，一些桌面第三方都支持这一功能，我为什么选择RocketDock呢？一个字，小。RocketDock对内存的占用几乎可以忽略不计，开机自启后完全不会拖慢Windows系统的运行。 官网下载，安装后可以在设置界面进行自定义设置，选项很多，这里不一一介绍了，有一点需要注意的是，我在选择了他的“将窗口最小化到Dock栏”这一项时，有部分软件并不能最小化到Dock栏，还是在任务栏最小化，经过我的分析，发现在Program Files和Program Files (x86)目录下的软件的反应不同，我感觉可能是因为该软件停更了几年，对64位的支持不好？也有可能是我的个别情况。 要把图标加到dock栏由两种方法： 直接把快捷方式或者exe文件拖入dock栏 右击dock栏，新建项目——&gt;文件，然后右击新生成的文件图标，可以选择文件位置和图标 关于图标的自定义，这里推荐一个网站：阿里巴巴矢量图标库 如果要有如下stacks docklet的效果，需要下载一个插件，但是官网关闭了，如果百度不到的可以联系我。 Win10任务栏调整 Windows的任务栏是win的精华，并不能被dock完全取代，我是把它放在顶部。右击任务栏——&gt;任务栏设置，里面有很多自定义选项，根据需要调整 我不习惯Win10的原始开始菜单，借助了**”腾讯电脑管家”的工具箱里面的“经典开始菜单”**工具，可以换成经典模式 合理利用Windows的键盘快捷键可以极大的提高效率，同时也会让你的系统更加的规范 ok，这篇博文就先介绍这几个最基本的工具，如果有什么不清楚的或者讨论的请留言，或者联系我的QQ（在菜单关于里面）","link":"/2020/03/11/Win10%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"},{"title":"hexo博客搭建","text":"注：推荐观看bilibili的up主codesheep的hexo视频教程，本博客是参考该视频 1. 部署环境 安装nodejs:官网下载,下载完包括nodejs本身和npm包管理器 管理员身份打开终端(推荐git bash) node -v和npm -v验证是否安装成功 安装cnpm 用npm安装cnpm的taobao源，防止丢包，提高安装成功率，用cnpm -v验证 1npm install cnpm -g --registry=https://registry.npm.taobao.org 同样也可以直接修改npm的仓库源 123npm config set registry https://registry.npm.taobao.org#查看npm仓库npm config get registry 这里其实推荐使用nvm这个nodejs版本管理工具来安装nodejs 1234567curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashnvm --versionnvm ls-remotenvm install v12.18.0nvm ls 用 cnpm install -g hexo-cli 全局安装hexo博客框架，用hexo -v验证 2. 初始化博客 建立一个空的文件夹，作为blog博客目录 在blog目录下，hexo init 自动克隆博客框架到本地 hexo s 在本地localhost:4000`端口可以预览本地的博客 3. 写博客 hexo n &quot;blog name&quot; 生成新博文到source文件夹下，就可以愉快的写博客了 hexo clean 清理目录之后，hexo g 更新生成 4. 部署博客到GitHub(免费，推荐) 为了远程访问，需要将博客部署到远程仓库，方式有多种，这里推荐github，因为免费 github中新建仓库，仓库名设置为 你的github用户名.github.io 在本地blog根目录安装git部署插件：cnpm install --save hexo-deployer-git 设置_config.yml文件，在文件最底部添加自己的Github仓库地址 hexo clean hexo g hexo d 按照提示输入github密码完成远程部署 通过你的github用户名.github.io 远程访问自己的博客，完美打开 5. 后续自定义美化博客 主题选择 可以访问hexo官方网站，选择自己喜欢的主题 克隆主题到本地themes目录下： git clone https://github.com/XXXX/XXX.git themes/XXX 在_config.yml 中修改主题为XXX 最后在主题文件夹里面的配置文件里面实现自定义功能和美化","link":"/2020/03/03/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"title":"hexo博客优化之图床迁移&amp;google收录","text":"前言： 搭建完hexo后，当然就是写博客，markdown的语法插入图片很简单，但是把大量图片放在博客文件里面，未免太臃肿，会大大拖慢博客的打开时间（更别说我的博客是托管在github上的了）。图床就是一个好的解决方案，顾名思义，图床就是一个存储图片个“床”，一个云端的图片库，它把博客和图片分离开来，更好管理的同时也不会拖慢博客的速度。 我写博客虽然都是给自己看的，但是搜索引擎搜不到自己的文章总感觉缺了点什么:laughing:,让谷歌收录自己的博文，再加上自己博文的质量，就能在google搜索引擎上根据关键词搜索到自己的文章了。（百度的收录我没有弄，不过大同小异） 图床迁移：我之前的图床用的是路过图床，这是个免费的图床，还不错，免费额度完全够用，但是感觉图片打开速度有点慢。所以就百度了一下，发现了一种同样免费且快捷的方式：gitee(码云)+PicGo。迁移过后，实测效果明显，下面就来总结一下 现在码云建立一个仓库，按照下面格式来。没有账号的自己注册。 在gitee的个人设置里选择 私人令牌——&gt;生成新令牌，最后会生成一串密文，保存它，后面和PicGo绑定要用。 下载PicGo软件下载链接，Windows系统选择exe安装程序下载，macos选择dmg程序安装程序下载。 进入PicGo界面，插件搜索gitee-uploader，安装，然后重启。 进入图床设置，选择gitee，然后填入以下信息 repo：gitee中你建立的仓库地址，例如yangfanjack/image branch：填master token：刚才的密文 path：一般填img customPath：不填 customUrl：不填 然后点击设为默认图床——&gt;确认，即可，enjoy it! Google收录：前提：看到这里的我相信都有办法进google吧 进入Google Search Console，既然有新的，就选择左边的网域，按照他的格式例如ordinaryman.club填入你的域名，点击继续 会DNS验证，去你的域名购买商添加一条txt record，如果之前更改过DNS服务器地址，就去DNS代理商添加record，我是cloudflare代理的，所以以此为例： 点击**+Add record，然后type选择TXT，Name填@，Content**就填Google给你的txt内容，点击save，完成。 返回Google Search Console界面，点击验证，一般会过一段时间通过，不过我是马上就通过了:neutral_face:。 然后进入你的本地博客根目录，安装站点地图插件： 1npm install hexo-generator-sitemap --save 安装完后进入根目录的配置文件_config.yml 在URL下： 1url: http://XXXXXX //写入你的域名 在最后加上： 12sitemap: path: sitemap.xml 保存后，hexo三件套：hexo clean hexo g hexo d，访问网页：你的域名/sitemap.xml，出现以下页面说明配置成功 进入Google Search Console的你的域名管理页面，点击站点地图，添加你的站点地图的网址：你的域名/sitemap.xml，等待一天时间，就可以生效啦。","link":"/2020/03/11/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8B%E5%9B%BE%E5%BA%8A%E8%BF%81%E7%A7%BB-google%E6%94%B6%E5%BD%95/"},{"title":"docker进阶指南","text":"docker可视化1234# Portainer:利用Portainer可以轻松构建，管理及维护Docker环境，它基于容器安装，高效部署docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer# Rancher:Rancher是一个开源的企业级全栈化容器部署及管理平台。Rancher为容器提供一揽子基础架构服务：CNI兼容的网络服务、存储服务、主机管理、负载均衡、防护墙……Rancher让上述服务跨越公有云、私有云、虚拟机、物理机环境运行，真正实现一键式应用部署和管理。docker run ‐di ‐‐name=rancher ‐p 9090:8080 rancher/server docker的分层机制Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile: 1234FROM ubuntu:18.04COPY . /appRUN make /appCMD python /app/app.py 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层(镜像层)。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示： 事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。 每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。 最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。 commit镜像12docker commit #提交容器成为一个新的副本docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 自定义目标镜像名:[版本号] 接下来是docker的三个精髓：容器数据卷，DockerFile，Docker网络 容器数据卷用来实现”删服务不删数据”，数据可持久化，将容器内的目录映射同步到宿主机的目录中，类似于双向绑定 123456789101112131415161718192021docker run -it -v 宿主机目录:容器内目录 #注意目录都是绝对地址docker inspect 容器id #查看容器的具体同步目录信息Mount#数据卷命令docker volume create #创建数据卷docker volume inspect #显示数据卷详细信息docker volume ls #显示所有数据卷docker volume rm #移除数据卷#具名和匿名挂载（都不指定路径）docker run -d -P name nginx02 -v juming-nginx:/etc/nginx nginxdocker run -d -P name nginx01 -v /etc/nginx ngix所有的docker容器内的卷没有指定具体路径的情况下，都在`/var/lib/docker/volumes`下-v /宿主机路径：容器内路径 #指定路径挂载-v 数据卷名：容器内路径 #具名挂载-v 容器内路径 #指定目录挂载#这里的ro和rw代表读写权限，ro表示只读，rw表示读和写，对挂载出来的内容就进行了限制，ro表示只能通过宿主机进行改变，容器内无法操作docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx 1234567891011#DockerFile:用来构建docker镜像的构建文件，相当于一个命令脚本。#镜像是层次的，脚本里的命令也是层次的#格式：指令(大写) 参数#每个命令就是镜像的一层FROM centosVOLUME [&quot;volume01&quot;,&quot;volume02&quot;] #匿名挂载CMD echo &quot;------end-------&quot;CMD /bin/bashdocker build -f dockerfile01 -t jack/centos 123#两个/多个容器之间同步数据（数据卷容器）#docker02挂载到docker01上，此时docker01就是数据卷容器docker run -d -it --name docker02 --volumes--from docker01 jack/centos DockerFile12345#构建步骤1. 编写dockerfile文件2. docker build #构建成为一个镜像3. docker run #运行镜像4. docker push #发布镜像（dockerhub，阿里云镜像仓库） 12345#基础知识1. 每个保留关键字（指令）都大写2. 执行从上到下3. &quot;#&quot;表示注释4. 每一个指令都会创建提交到一个新的镜像层 dockerfile是面向开发的，交付环境就是交付一个dockerfile文件：DockFile-&gt;DockerImages-&gt;Docker容器 123456789101112FROM #基础镜像MAINTAINER #镜像是谁写的RUN #镜像构建时需要运行的命令ADD #添加内容（tocmat，mysql等）WORKDIR #镜像的工作目录VOLUME #挂载目录EXPOSE #暴露的端口CMD #指定容器启动的时候要运行的命令，只有最后一个会生效ENTRYPOINT #指定容器启动的时候要运行的命令，可以追加命令ONBUILD #只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行ONBUILD后的指令COPY #将文件拷贝到目录中ENV #构建的时候设置环境变量（例：mysql用户名） 实战：自定义centos 1vim mydocker-centos 12345678910111213141516171819FROM centosMAINTAINER jack&lt;yangfanjack1024@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo &quot;-----end-----&quot;CMD /bin/bash#ADD #VOLUME #ENTRYPOINT #ONBUILD #COPY 12#得到自定义镜像mycentos:0.1docker build -f mydocker-centos -t mycentos:0.1 . 12345678910111213141516171819202122232425262728293031323334#编写包含tomcat的centos自定义镜像1. 准备镜像文件tomvat和jdk的压缩包2. 编写dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了#Dockerfile文件FROM centosMAINTAINER jack&lt;yangfanjack1024@qq.com&gt;COPY readme.txt /usr/local/readme.txtADD jdk-8u271-linux-x64.tar.gz /usr/localADD apache-tomcat-9.0.40.tar.gz /usr/localRUN yum -y install vimENV MYPATH /usr/localWORK $MYPATH#设置环境变量ENV JAVA_HOME=/usr/local/jdk1.8.0_271ENV CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /usr/local/apache-tomcat-9.0.40ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.40ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/binEXPOSE 8080CMD /usr/local/apache-tomcat-9.0.40/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.40/bin/logs/catalina.out#构建自定义tomcat的镜像docker build -t diytomcat .#启动tomcatdocker run -d -p 8080:8080 --name jacktomcat -v /root/test/:/usr/local/apache-tomcat-9.0.40/webapps/test/ -v /root/tomcatlogs/:/usr/local/apache-tomcat-9.0.40/logs/ diytomcat#然后直接在宿主机的test中发布网站即可 发布镜像到dockerhub和阿里云 12345678#先注册https://hub.docker.com/#在宿主机登录docker login -u XXX -p XXX#发布前先用tag命令修改为规范的镜像docker tag 镜像id jack/diytomcat:1.0docker push jack/diytomcat:1.0#提交的时候就是按照层级来发布的 12345678910#先注册https://www.aliyun.com/?spm=5176.12901015.ahjq0uaqt.1.a8fd525cv7uh0R#找到容器镜像服务#创建命名空间（一个账号只能创建三个）#创建镜像仓库#之后阿里云会有官方详细步骤docker login XXXXXXXXXXXXXXXdocker tag XXXXXXXXXXXXXdocker push jack/diytomcat:1.0 docker所有流程 Docker网络（容器编排，集群部署）docker网络模式：有如下四种： host模式(–net=host) container模式 none模式(–net=none) bridge模式(–net=bridge) host模式： 需要使用docker run是指定： –net=host 使用的网络实际上和宿主机是一样,在容器内的IP和宿主机的IP是一样,类似于vmare桥接模式； container模式：使用 –net=container:container_id/container_name，多个容器使用共同的网络,看到的IP是一样的； none模式： --net=none 这种模式下,不会配置任何网络； bridge模式：**–net=bridge**，不指定是默认也是这种模式，这种模式会为每个容器分配一个独立的network 网卡，同一个宿主机是在同一个网段下可以通信的，类似于 VMware 的 NAT模式； 桥接模式（类似于vm的nat模式） host模式（类似于vm的桥接模式） 两个docker网络如何通信呢？ 一台bai计算机是可以有多个IP地址的，如果我们给一台du服务器绑定两个以上zhiIP地址dao，其中一个IP地址在一个网段中(如192.168.1.0)，另一个IP地址在另一个网段中(如192.168.2.0)，如果给服务器提供路由功能，这两个IP地址充当网关，就可以把两个网段连接在一起了。 接下来是实战：Docker Compose，Docker Swarm，CI/CD Jenkins DevOps DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。 它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运维工作必须紧密合作。","link":"/2020/11/20/docker%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"},{"title":"java-JVM","text":"JVM重点问题 JVM位置 JVM体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 三种JVM 栈 堆 新生区，老年区 永久区 堆内存调优 GC机制（常用算法） JMM 单点登录（SSO） JVM位置 JVM体系结构（JVM内存模型）jvm内存模型主要分为5个部分，是java在运行时，jvm虚拟机拿到了自己能支配的内存之后，将内存进行了割分 栈：存储函数运行中的一些引用类型的变量&amp;基础类型变量 堆：存储对象，被栈中的引用类型变量所指向 本地方法栈：存储C++的native方法运行时的栈区 java中有两种方法：java方法和本地方法 java方法由java语言编写，编译为class文件，运行时放在jvm中 本地方法由其他语言编写，编译成和处理器相关的机器代码，本地方法保存在动态链接库中，在windows系统中就是.dll文件中，各个平台都有自己独有的 程序计数器：指向程序当前运行的位置 方法区：存储元数据信息。static，cloader等 类加载器 .class文件经过类加载器，初始化，在方法中形成一个Class类型的对象用来做实例化操作 类加载器分类：（层次从低到高） 应用程序加载器：AppClassLoader：记载自定义的类 扩展加载器：ExtClassCloader：加载java扩展库中的类 引导类(根)加载器：由C++实现，加载java核心库rt.jar，创建扩展类加载器和应用程序类加载器 虚拟机自带的加载器： 双亲委派机制 目的：为了保证安全，重点理解委派 双亲委派机制原理：类加载器收到类加载请求——》一直向上(父类)委托，直到根加载器——》引导类加载器检查是否能加载当前这个类——》能加载就是用当前加载器，否则就通知子加载器进行加载——》重复上个步骤知道将类进行加载 如果最终都没有找到的话，那么会报异常：Class Not Found 用一个classLoader一直重复getCloader，如果出现了null的情况，那么有两种情况：要么不存在，要么就是C++写的native方法(java无法获取到) APP——》EXT——》BOOT（最终执行） 沙箱安全机制 沙箱机制就是一个限制程序运行的环境，通过设置相应的权限。 组成沙箱的基本组件： 字节码校验器：确保java类文件遵循java语言规范，帮助java实现内存保护。核心类不会经过字节码校验。 类加载器： 在3个方面对java沙箱起作用 防止恶意代码干涉善意代码，例如双亲委派（自定义String类根本不会生效） 守护被信任的类库边界 将代码归入保护域，确定了代码可以进行哪些操作（例如自己的代码调不了C++的库） JVM为不同的类加载器载入的类提供不同的命名空间 包含哪些关于沙箱机制类： 存取控制器（access controller） 安全管理器（security manager） 安全软件包（security package） Native关键字 凡是带了native关键字的方法，这个方法会调用C库 带native关键字的方法在执行时会进入本地方法栈，然后调用本地方法接口JNI JNI作用：扩展java的使用，融合不同编程语言为java所用。最初融合的是java诞生时如日中天的C和C++ PC寄存器 Program Counter Register 线程私有 就是一个指针，指向方法区中的方法字节码（用来存储指向一条即将要执行的指令的地址），在执行引擎读取下一条指令。 如果执行的是一个native方法，计数器是空的 方法区 Method Area 所有线程共有：所有字段，方法字节码，构造函数，接口代码 静态变量static，常量final，类信息Class模板(构造方法，接口定义)，运行时的常量池fianl Pool也存在内存中。 实例变量存在堆内存中 栈 先进后出，后进先出 举个栗子： 栈：喝多了吐 队列：吃多了拉 栈内存：主管程序的运行，生命周期，线程同步 线程结束，栈内存也就是释放了，程序也就结束了 栈中放哪些类型： 8大基本类型 对象引用 实例的方法 栈帧：一帧一帧地存储 栈满了会报错：StackOverFLowError 堆 三种JVM： SUN公司：HotSpot(TM)，我们学习的 BEA公司：：JRockit IBM公司：J0 VM Heap 一个JVM只有一个堆内存，堆内存的大小是可以调节的 类加载器读取的类文件后，一般把什么东西放进堆中？ 类的实例，实例中的方法，变量，（jdk1.8后的常量） 保存所有引用类型的真实对象 堆中还要细分为三个区域： 新生区（有三个：Eden Space，Survivor1，Survivor2）：轻量级垃圾回收 养老区：重量级垃圾回收 永久区 GC垃圾回收主要发生在伊甸园区&amp;养老区 假设内存满了，会有OOM（java.out.OutOfMemoryError:Java heap space）错误，说明堆内存满了 JDK8后，永久存储区更名为：元空间 OOM故障排除 DEBUG太慢了，所以最好能直接定位代码出错行数，可以使用内存快照分析工具：MAT，Jprofiler MAT，Jprofiler作用： 分析Dump内存文件，快速定位内存泄漏问题 获得堆中的数据 获得大的对象 …… 使用Jprofiler工具剖析java代码运行过程 ```shell#-Xms:设置初始化内存分配大小，默认1/64#-Xmx:设置最大分配内存，默认1/4#-XX:+PrintGCDetails:打印GC垃圾回收信息#-XX:+HeapDumpOnOutOfMemoryError:打印OOM信息-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError 12345678* ```java //RunTime类（代表应用程序的运行环境）常用方法 getRuntime(); exec(String command); freeMemory();//返回java虚拟机中的空闲内存区，字节为单位 maxMemory();//返回java虚拟机试图使用的最大内存量，字节为单位 totalMemory();//返回java虚拟机内存总量，字节为单位 GC垃圾回收机制见博客Java-GC机制 JMM 什么是JMM？Java Memory Model 究竟什么是JMM，其实JMM和栈，堆这些JVM内存模型的东西完全不是一个概念的东西。当你第一次听到Java Memory Medel时候，肯定会首先想到这些吧，但是不对。 实际上JMM是一个抽象的概念， 在物理实现上，java采用volatile关键字，该关键字用于修饰变量表示该变量在不同线程中共享。导致编译器和运行时都会注意到该变量是共享的，因此不会对该变量进行重排序。 JMM实际上就时缓存一致性协议，用于定义数据读写规则 JMM的8种交互操作： lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态 unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中 use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令 assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中 store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用 write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中 JVM对这8种指令定义了如下的规则： 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存 不允许一个线程将没有assign的数据从工作内存同步回主内存 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量 对一个变量进行unlock操作之前，必须把此变量同步回主内存 说白了，JMM就是一个关于操作系统读写操作控制的机制，说到这里，过几天要回顾操作系统的知识了。。。。哎","link":"/2021/01/02/java-JVM/"},{"title":"java-注解","text":"什么是注解 可以被其他程序读取 可以附加在package,class,method,field上都可以添加注解 可通过反射实现对注解中信息的访问 注解是jdk1.5后的新特性 注解作用 编写文档：通过代码里标识的注解生成doc文档 代码分析：通过代码里标识的注解堆代码进行分析（结合反射） 编译检查：通过代码里标识的注解让编译器能实现基本的编译检查（@Override） 内置注解 @Override：必须重写父类的方法 @Deprecated：已过时的，不推荐使用，存在更好的方式 @SuppressWarning：镇压警告 元注解 负责解释其他注解的注解：Java定义了4个标准的meta-annotation类型，以供其他的annotation类型做说明 @target：描述注解使用范围 @Retention：描述什么级别保存该注释信息，用于描述注解的生命周期(SOURCE&lt;CLASS&lt;RUNTIME) @Documented：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 1234567@Target(value={ElementType.METHOD,ElementType.TYPE})@Retention(value=RetentionPolicy=RUNTIME)@Documented@Inherited@interface MyAnnotation(){ } 自定义注解 @interface用来声明一个注解 注解体中的每一个方法实际就是一个配置参数，方法名就是参数名，返回值类型就是参数的类型（返回值只能是Class,String,enum） 可以通过default来声明参数的默认值 只有一个参数，参数名是value，赋值时可省略参数名 注解元素必须要有值，我们定义注解元素时，经常使用空字符串0作为默认值 12345678910111213141516public class Test{ //注解可以显式赋值，如果没有默认值必须给注解赋值 @MyAnnotation(name = &quot;JackYang&quot;,school={&quot;西部开源&quot;,&quot;清华大学&quot;}) public void test(){}}@Target(value={ElementType.METHOD,ElementType.TYPE})@Retention(value=RetentionPolicy=RUNTIME)@interface MyAnnotation(){ //注解的参数：参数类型+参数名 String name() default &quot;&quot;; int age() default 0; int id() default -1;//默认值是-1代表不存在 String[] school();}","link":"/2020/12/19/java-%E6%B3%A8%E8%A7%A3/"},{"title":"java-反射","text":"静态语言（强类型语言）静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。例如：C++、Java、Delphi、C#等。 动态语言（弱类型语言）动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。 强类型定义语言强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 弱类型定义语言数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。 什么是反射（反射机制） Java时静态语言，通过反射，Java成为了准动态语言 反射禁止允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。 1Class c = Class.forName(&quot;java.lang.String&quot;) 这个存在内存中的Class类型的对象就是一面镜子，我们通过镜子的反射能看到类的结构。 反射机制的功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 反射的优点和缺点： 可以实现动态创建对象和编译，很灵活 对性能有影响，反射基本上是一种解释操作 理解Class类并获取Class实例 发射相关的主要API java.lang.Class：代表一个类 java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 例子： 12345678910111213141516171819class User{ private String name; private int id; private itn age; public User(){} public User(String name,int id,int age){ this.name = name; this.id = id; this.age = age; } //省略get,set方法，toString()方法}public class Test{ public static void main(String[] args){ Class c1 = Class.forName(&quot;com.jack.User&quot;); c1.get }} Class类是Java反射的源头。所谓反射实际就是：可以通过对象反射求出类的名称 类的加载与ClassCloader 对象照镜子后可以得到的信息：某个类的属性，方法和构造器，某个类实现了哪些接口。 对于一个类而言，JRE都为其保留一个不变的Class类型的对象，一个Class对象包含了特定某个结构的有关信息。 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection地根源，针对任何逆向动态加载，运行的类，唯有先获得相应的Class对象 12345678910//Class类的常用方法static Class forName(String name);Object newInstance();getName();Class getSuperClass();Class[] getinterfaces();ClassLoader getClassLoader();Constructor[] getConstructor();Method getMethod(String name,Class T);Field[] getDeclaredFields(); 123456789//获取Class类的实例//通过类的clas属性获取（多用于传参）Class c1 = Person.class;//用类的实例的getClass获取Class对象（多用于对象获取字节码）Class c2 = person.getClass();//用Class类的静态方法forName通过一个类的全类名获取Class对象（多用于读取配置文件）Class c3 = Class.forName(&quot;jack.Person&quot;);//内置基本数据类型的包装类可以直接用类名.Type//还可以利用ClassLoader 类加载内存分析 类初始化的时机 类加载器ClassLoader 12//获取系统类加载器可以加载的路径System.out.println(System.getProperty(&quot;java.class.path&quot;)); 双亲委派机制 创建运行时类的对象 通过反射获取运行时类的完整结构 Field：全部的属性 Method：全部的方法 Constructor：全部的构造器 Superclass：所继承的父类 Interface：实现的全部接口 Annotation：注解 12345678910111213141516171819public class Test01(){ public static void main(String[] args) throws ClassNotFoundException{ Class c1 = Class.forName(&quot;com.jack.User&quot;); System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); System.out.println(c1.getFields()); System.out.println(c1.getDeclaredFields()); System.out.println(c1.getFields(&quot;name&quot;)); System.out.println(c1.getDeclaredField(&quot;age&quot;)); System.out.println(c1.getMethods()); System.out.println(c1.getDeclaredMethods()); System.out.println(c1.getMethod(&quot;getName&quot;,null)); System.out.println(c1.getMethod(&quot;setName&quot;,String.class)); System.out.println(c1.getDeclaredMethod(&quot;getName&quot;,null)); System.out.println(c1.getConstructors()); System.out.println(c1.getDeclaredConstructors()); System.out.println(c1.getConstructor(String.class,int.class,int.class)); }} 动态创建对象执行方法123456789101112131415161718public class Test02(){ public static void main(String[] args) throws ClassNotFoundException{ Class c1 = Class.forName(&quot;com.jack.User&quot;); User user1 = (User)c1.newInstance();//本质上调用无参构造器 //通过构造器创建对象 Constructor constructor = c1.getDeclaredConstructor(String.class,int.class,int.class); User user2 = constructor.newInstance(&quot;Jack&quot;,001,18); //通过反射调用方法 User user3 = c1.newInstance(); Method setName = c1.getDeclaredMethod(&quot;setName&quot;,String,class); setName.invoke(user3,&quot;Sam&quot;); //通过反射操作属性 User user4 = c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); name.setAccessible(true);//暴力反射：不能直接访问私有属性，我们要关闭程序的安全检测。这里如果设置为false则指示反射的对象实施Java语言的语言访问检查 name.set(user4,&quot;Mariah&quot;); }} 反复执行类中获取名字的方法的三种方式的效率对比： 通过反射操作泛型 Java采用的泛型擦除机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题。但是，一旦编译完成，所有和泛型相关的类型会全部擦除。 为了通过反射来操作这些类型，Java新增了Parameterized，GenericArrayType，TypeVariable和WildcaredType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType：表示一种参数化类型，比如Collection&lt;String&gt; GenericArrayType：表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVaraible：是各种类型变量的公共父接口 WildcaredType：代表一种通配符类型表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo{ //定义两个带泛型的方法 public void test01(Map&lt;String,Person&gt; map,List&lt;Person&gt; list){ System.out.println(&quot;Demo.test01()&quot;); } public Map&lt;Integer,Person&gt; test02(){ System.out.println(&quot;Demo.test02()&quot;); return null; } public static void main(String[] args) { try { //获得指定方法参数泛型信息 Method m = Demo.class.getMethod(&quot;test01&quot;, Map.class,List.class); Type[] t = m.getGenericParameterTypes(); for (Type paramType : t) { System.out.println(&quot;#&quot;+paramType); if(paramType instanceof ParameterizedType){ //获取泛型中的具体信息 Type[] genericTypes = ((ParameterizedType) paramType).getActualTypeArguments(); for (Type genericType : genericTypes) { System.out.println(&quot;泛型类型：&quot;+genericType); } } } //获得指定方法返回值泛型信息 Method m2 = Demo.class.getMethod(&quot;test02&quot;, null); Type returnType = m2.getGenericReturnType(); if(returnType instanceof ParameterizedType){ Type[] genericTypes = ((ParameterizedType) returnType).getActualTypeArguments(); for (Type genericType : genericTypes) { System.out.println(&quot;返回值，泛型类型：&quot;+genericType); } } } catch (Exception e) { e.printStackTrace(); } }} 通过注解反射操作注解小例子：通过注解和反射完成类和表结构的映射关系 ORM：Object Relationship Mapping——》对象关系映射 类和表结构对应 睡醒和字段对应 对象和记录对应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class test12 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class c1 = Class.forName(&quot;dome_05_注解.Student2&quot;); //通过反射 获得注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation); } // 获得 注解 value 的值 Tablekuang annotation = (Tablekuang) c1.getAnnotation(Tablekuang.class); System.out.println(annotation.value()); // 获得类指定的注解 Field name = c1.getDeclaredField(&quot;name&quot;); Fieldkuang annotation2 = name.getAnnotation(Fieldkuang.class); System.out.println(annotation2.Columname()); System.out.println(annotation2.type()); System.out.println(annotation2.length()); }}// 类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Tablekuang { String value();}// 属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface Fieldkuang { String Columname(); String type(); int length();}class Student2 { private int id; private int age; private String name; public Student2() { } public Student2(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; }}","link":"/2020/12/19/java-%E5%8F%8D%E5%B0%84/"},{"title":"javaweb-前后端分离史","text":"前后端分离演变史model1(MVC时代)： 以前一篇博客讲了为了开发开发复杂度，后端开发从model2(MVC)逐渐演变了很多基于MVC的后端框架，例如SSH，SSM 优点：MVC是一个很好的协作模式，能后有效降低代码的耦合度，从架构上能让开发者明白代码应该写在哪里。为了让View试图层更加存粹，还可以将JSP替换为Thymeleaf，Freemarker等模板引擎，使模板里无法写入java代码，让前后端分工更加清晰 缺点： 前端开发重度依赖开发环境，开发效率低。这种架构下，前后端协作主要有两种模式： 前端写Demo，写好后，让后端去套模板。好处是Demo可以本地开发，很高效。不足时需要后端套模板，套完后还需要前端人员确定，来回沟通调整的成本很大。 另一种协作模式是前端负责浏览器端的所有开发和服务器端的View层模板开发。好处是UI相关的代码都是前端去写就好了，后端不用管前端的数据。不足就是前端开发重度绑定开发环境，环境成为影响前端开发效率的重要因素。 前后端职责纠缠不清，模板引擎功能强大，依旧可以通过拿到的上下文变量来实现各种业务逻辑。这样，只要前端弱势一点，往往就会被后端要求在模板层写入不少业务代码。还有个很大的灰色地带是Controller，页面路由等功能本应该是前端最关注的，但却是由后端来实现的。Controller和Model往往也会纠缠不清，看了让人咬牙的业务逻辑代码经常会出现在Controller层，这些问题不能全纠结于程序员的素养，否则JSP就够了。 对前端发挥的局限性：性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作，但由于后端框架限制，我们很难使用【Comet】，【BigPipe】等技术来优化性能 基于AJAX的SPA时代 使用CDN作为静态资源存储，JavaScript网站归来，Single Page Application 优点：前后端分工清晰，关键是AJAX接口。复杂度从基于服务器引擎的JSP转移到了基于浏览器引擎的JavaScript。这个时代出现了类似后端MVC模式的分层架构 缺点：前后端接口的约定。需要通过接口规则和接口平台等方式来实现前后端的搞笑并行并发。前端由于JavaScript可能出现大量JS代码的组织。 大前端MV*时代 MVC：同步通信：View，Controller，Model MVP：异步通信：View，Presenter，Model MVVM：异步通信：View，ViewModel，Model 为了降低前端开发的复杂度，涌现了大量前端框架：AngularJS，React，Vue.js，EmberJS等，这些框架按类型分为：Templates，Controllers，Models三层，然后在层能分层 优点： 前后端职责很清晰：前端工作在浏览器端，后端工作在服务器端，开发并行。前后端独立开发，独立运行，甚至独立部署上线。 前端开发的复杂度可控：前端代码很重，很合理的分层，让前端代码能各司其职。 缺点： 代码不能复用，例如后端依旧需要对数据各种校验，无法直接复用浏览器端的代码 全异步，对SEO不利，往往还需要服务器端做同步渲染的降级方式 性能并非最佳，特别是移动互联网下 SPA不能满足所有需求，依旧存在大量多页面应用。URL Design需要后端配合，前端无法完全掌握。 NodeJS带来的全栈时代前端的MVC模式解决了很多问题，但是也有很多不足。随着NodeJS的兴起，JavaScript开始有能力运行在服务端。这意味着可以有一种全新的研发模式。 在这种研发模式下，前后端职责很清晰了。 对前端来说，两个UI层各司其职： Front-end UI layer：处理浏览器层的展现逻辑，通过CSS渲染样式，通过Javascript添加交互式功能。 Back-end UI layer：处理路由，模板，数据获取，Cookie等。通过路由，前端终于可以自主把控URL Design了。这样无论是单页面应用还是多页面应用，前端都可以自由调控。后端也终于可以拜托对崭新啊的强关注，转而可以专心业务逻辑层的开发。 通过 Node，Web Server 层也是 JavaScript 代码，这意味着部分代码可前后复用，需要 SEO 的场景可以在服务端同步渲染，由于异步请求太多导致的性能问题也可以通过服务端来缓解。前一种模式的不足，通过这种模式几乎都能完美解决掉。 与 JSP 模式相比，全栈模式看起来是一种回归，也的确是一种向原始开发模式的回归，不过是一种螺旋上升式的回归。 基于 Node 的全栈模式，依旧面临很多挑战： 需要前端对服务端编程有更进一步的认识。比如 network/tcp、PE 等知识的掌握。 Node 层与 Java 层的高效通信。Node 模式下，都在服务器端，RESTful HTTP 通信未必高效， 过 SOAP 等方式通信更高效。一切需要在验证中前行。 对部署、运维层面的熟练了解，需要更多知识点和实操经验。 大量历史遗留问题如何过渡。这可能是最大最大的阻力。 总结 模式没有好坏高下之分，只有合不合适。 Ajax 给前端开发带来了一次质的飞跃，Node 很可能是第二次。 SoC（关注度分离：关注点分离是日常生活和生产中广泛使用的解决复杂问题的一种系统思维方法。大体思路是,先将复杂问题做合理的分解,再分别仔细研究问题的不同侧面(关注点)，最后综合各方面的结果，合成整体的解决方案。） 是一条伟大的原则。上面种种模式，都是让前后端的职责更清晰，分工更合理高效。 还有个原则，让合适的人做合适的事。比如 Web Server 层的 UI Layer 开发，前端是更合适的人选。","link":"/2021/01/02/javaweb-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%8F%B2/"},{"title":"javaWeb三大组件","text":"Servlet 见之前的两篇博客：《javaWeb核心-理解servlet》，《javaWeb核心-servlet细节》，讲的很详细 Filter：过滤器 拦截请求：完成通用操作（登录验证，统一编码，敏感字符过滤） 1234567891011121314151617181920@WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { }} web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行放行前的代码 执行放行后的资源 回来执行过滤器放行代码下边的代码（一般是对response对象做增强） 过滤器生命周期方法 **init:**在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 **doFilter:**每一次请求被拦截资源时，会执行。执行多次 **destroy:**在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置：设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 过滤器链（配置多个过滤器） 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 敏感词汇过滤 在Filter中对request中的请求参数进行过滤操作，但是由于只有getProperty()这个方法，没有setProperty()这个方法，所以，我们需要对request对象的getParameter方法进行增强。产生一个新的request对象。 增强对象功能，可以使用两种模式：装饰者模式和代理模式 装饰模式 代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式： 1 静态代理：有一个类文件描述代理对象 动态代理：在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法。 增强方法 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 123456789101112131415161718接口类 proxy = Proxy.newProxyInstance( // 参数1：真实对象的类加载器 myBeanpostProcessor.class.getClassLoader(), //参数2：真实对象实现的所有的接口,接口是特殊的类，使用Class[]装载多个接口 bean.getClass().getInterfaces(), //参数3： 接口，传递一个匿名内部类对象 new InvocationHandler() { //proxy 代理对象 //method:代理的方法对象 //args:方法调用时参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开启事务&quot;); Object obj=method.invoke(bean, args);//代理类，参数 System.out.println(&quot;关闭事务&quot;); return obj; } }); Listener：监听器事件监听机制 事件：一件事情 事件源：事件发生的地方 监听器：一个对象 注册监听：将事件，事件源绑定在一起。当事件源发生某个事件时，执行监听器代码 说一个用来加载配置文件的监听器类（web框架中这种监听器已经写好，我们只需要配置即可） 123ServletContextListener类 //监听ServletContext对象的创建和销毁void contextDestroyed(ServletContextEvent sce) //服务器启动后自动调用void contextInitialized(ServletContextEvent sce) //ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置web.xml 12345678&lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--指定初始化参数--&gt;&lt;context-param&gt; &lt;param-name&gt;XXX&lt;/param-name&gt; &lt;param-value&gt;XXX&lt;/param-value&gt;&lt;/context-param&gt; 注解： 1@WebListener ​","link":"/2021/03/16/javaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/"},{"title":"linux中的用户管理","text":"用户配置文件 越是安全性要求高的服务器越需要对用户权限等级制度和服务器操作规范有很高的要求，linux中主要通过用户配置文件来查看和修改用户信息 主要有四个配置文件：/etc/passwd，/etc/shadow，/etc/group，/etc/gshadow /etc/passwd：用户信息文件 格式：用户名称；密码标志；UID（0超级用户，1—499系统用户:不能登录，不能删除，500—65535普通用户）；GID（这里是初始组ID不是附加组ID）；用户说明:备注；家目录；Shell（命令解释器类型，默认是bash） /etc/shadow：影子文件 是passwd的影子 格式：用户名称；加密密码（SHA512加密，可以暴力破解，!!和*表示没有密码，不能登录）；密码最后一此修改时间（时间戳表示）；两次密码修改间隔（天）；密码时效天数（-1永不失效）；密码修改到期前的警告天数；密码到期后的宽限天数；账号失效时间（时间戳表示）；包留位 时间戳换算： 时间戳—&gt;日期：date -d &quot;1970-01-01 16066 days&quot; 日期—&gt;时间戳：echo$(($(date --date=&quot;2014/01/06&quot; +%s)/86400+1)) /etc/group&amp;/etc/gshadow：组信息文件&amp;组密码文件 /etc/group格式：组名，组密码标志，GID，组中附加用户 /etc/gshadow格式：组名，组密码(默认没有，也不推荐使用)，组管理员用户名，组中附加用户 Linux中查看用户的初始组的方法：查询etc/passwd和/etc/group，两两对照查看 用户管理相关文件 用户的家目录：（会自动生成） /home/用户名/：权限700 /root/：权限550 用户的邮箱： /var/spool/mail/用户名/ 用户模板目录：就是母板，新建用户会默认创建在用户家目录下 /etc/skel/ 用户管理命令useradd：创建用户 useradd 用户名 passwd 用户名 新建一个用户实际上就是在上述六个地方生成了默认信息，所以手工修改上述六个地方就可以手工添加用户 useradd -u UID：指定自定义UID useradd -d 家目录：指定自定义家目录 useradd -c 用户说明：指定自定义用户说明 useradd -g 组名：指定自定义初始组组名 useradd -G 组名1,组名2：指定自定义附加组组名 useradd -s shell：指定自定义shell 用户默认值配置文件：/etc/default/useradd &amp; /etc/login.defs passwd：修改用户密码超级用户可以改任意用户密码 普通用户只能给自己设密码 whoami：查看当前用户 passwd -S 用户名 ：查看密码状态，就是shadow里面的信息 passwd -l 用户名 ：锁定用户，实际是在shadow中的密码前面加了! passwd -u 用户名 ：解锁用户 passwd --stdin 用户名 ：使用字符串作为用户密码，例如：echo &quot;123&quot; | passwd --stdin 用户名 usermod：修改用户信息 usermod -u UID：修改UID usermod -c 用户说明：修改用户说明 usermod -G 组名1,组名2：修改附加组 usermod -g 组名：修改初始组（不推荐） usermod -L：锁定用户 usermod -U：解锁用户 chage：修改用户密码状态 chage -l：查询密码详细状态 chage -d 日期：修改密码最后一次更改日期 chage -m 天数：修改两次密码修改间隔 chage -M 天数：修改密码有效期 chage -W 天数：修改密码过期前警告天数 chage -I 天数：修改宽限天数 chage -E 日期：修改账号失效时间 注意：实际是对shadow文件里面的信息进行修改，chage -d 0 用户名使用最多，把用户的修改密码时间归零，强制用户第一次登陆系统必须修改密码 userdel：删除用户 userdel -r 用户名：删除用户的同时删掉家目录 不推荐手工创建用户，但是可以手工删除用户： etc/passwd etc/shadow etc/group etc/gshadow var/spool/mail/用户名 /home/用户名/ 手工把上面6个位置和要删除的用户的信息删除就可以了 id：查询用户uid，gid和附加组su：用户切换 su - 用户名 ：连带用户的环境变量一起切换，中间减号绝对不能省去，省去就不会切换环境变量 su -root -c 命令名：不切换root，只是执行root权限才能执行的命令 用户组管理命令groupadd groupadd 组名 groupmod groupmod -g 新组id 旧组id groupmod -n 新组名 旧组名 groupdel groupdel 组名：要想删除一个组，这个组中不允许有初始用户存在 gpasswd：把用户添入组或者从组中删除 gpasswd -a 用户名：把用户加入组 gpasswd -d 用户名：把用户从组中删除 注：也可以直接在/etc/group文件里添加附加组(不推荐改初始组) 总结：Linux中用户和用户组的关系是：","link":"/2020/03/05/linux%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"title":"linux启动管理","text":"CentOS 6的启动管理 运行级别：7个级别 runlevel：查看运行级别 init 运行级别：改变当前运行级别 vim /etc/inittab：永久修改系统默认运行级别，写上id:3:initdefault 不要把0和6设为默认级别 CentOS6系统启动过程：（针对MBR模式） 配合视频食用 启动引导程序grub Grub配置文件：/boot/grub/grub.conf 格式： default=0 默认启动第一个系统 timeout=5 等待时间，默认是5秒 splashimage=(hd0,0)/grub/splash.xpm.gz 指定grub启动时的背景图像文件的保存位置 hiddenmenu 隐藏菜单 title CentOS(2.6.32-279.el6.i686) 标题 root (hd0,0) 指启动程序的保存分区 kernel /vmlinuz-2.6.32-279.el6.i686 ro 定义了内核加载时的选项 initrd /initramfs-2.6.32-279.el6.i686.img initramfs内存文件系统镜像文件的所在位置","link":"/2020/03/11/linux%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86/"},{"title":"linux备份与恢复","text":"备份概述 Linux中需要备份的数据：/root/目录，/home/目录，/var/spool/mail/目录，/etc/目录，其他目录 安装的服务的数据也需要备份： apache需要备份的数据：配置文件，网页主目录，日志文件 mysql需要备份的数据：源码包安装的：/usr/local/mysql/data/或者RPM包安装的：/var/lib/mysql 备份策略： 完全备份：效果最高，但需要更大的硬盘空间 增量备份：每次备份只备份新的数据，占用空间少，但是恢复起来麻烦 差异备份：每次备份都只备份完全备份中不存在的，折中方法 备份命令 完全备份完全可以用tar打包压缩来做，但是如果是差异备份就会非常麻烦，这时就需要用到Linux为数据备份量是打造的备份和恢复命令dump命令和restore命令 dump [选项] 备份之后的文件名 原文件名 -级别：0到9个备份级别 -f：指定备份之后的文件名 -u：把备份时间记录在/etc/dumpdates文件中 -v：显示备份过程 -j：把备份文件压缩为.bz2格式 -W：查看详情 注意：dump命令只有在备份分区的时候才能增量备份，备份普通目录只能完全备份 restore [模式选项] [选项] 四个模式： -C：比较备份数据和实际数据的变化 -i：交互模式 -t：查看模式 -r：还原模式 一个选项： -f：指定备份文件的文件名","link":"/2020/03/11/linux%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"},{"title":"linux服务器搭建ssm项目环境","text":"购买服务器阿里云云翼计划：9.5块钱/月 配置环境jdk环境12yum -y install java-1.8.0-openjdk.x86_64java -version mysql环境 安装mysql 1234cd /tmpwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql mysql-server mysql-devel -y 启动mysql 123systemctl start mysql.servicemysqladmin -u root password rootmysql -uroot -proot tomcat环境 windwos环境中下载tomcat9的tar.gz后缀的压缩包 https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/ 用FileZilla上传到linux服务器/usr/local目录下 解压缩后启动tomcat 12345cd /usr/localtar xzf apache-tomcat-9.0.17.tar.gz#更名文件夹为tomcat9cd /usr/local/tomcat9/bin./startup.sh 打包上传war包 打包上传前需要在阿里云的服务器防火墙中打开8080端口权限 也可以把tomcat的默认款口号设置为80（在tomcat的conf目录下修改server.xml文件的默认端口号）（推荐） 在IDEA中用maven工具先clean后package，在target目录下生成war包，用filezilla上传到tomcat的webapps目录下。 重启tomcat 然后就可以访问你自己的网站了。","link":"/2020/11/19/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/"},{"title":"linux常用命令","text":"Linux作为一个网络操作系统，命令行才是王道，而不是图形。 Linux系统管理的命令是它正常运行的核心，与之前的DOS命令类似。 linux命令在系统中有两种类型：内置Shell命令和Linux命令 linux各目录的作用 /bin/：存放系统命令 /sbin/：存放系统目录，只有超级用户能用 /usr/bin/：存放系统命令，单用户模式不能执行 /usr/sbin/ ：存放系统命令，只有超级用户能用，单用户模式不能执行 /boot/ ：系统启动目录，内核和启动引导程序 /dev/ ：硬件设备文件目录 /etc/ ：linux默认的配置文件保存目录 /home/：普通用户家目录 /root/：超级用户家目录 /lib/：系统调用的函数库 /lost+found/：当系统意外崩溃时，每个分区都含有的存放的文件碎片用来修复 /media/：挂载目录，挂载媒体设备 /mnt/：挂载目录，挂载U盘，移动硬盘，和其他操作系统的分区 /misc/：挂载目录，挂载NFS服务的共享目录 /opt/：第三方安装的软件的保存目录，也可以放到/usr/local/下 /proc/：存放在内存里面，存放系统的内核，进程，外部设备 /sys/：存放在内存里面，存放系统的内核相关的东西 /srv/：服务数据目录 /tmp/ ：临时目录，可以清空 /usr/：系统资源目录 /var/：动态资源保存目录，日志，邮件，数据库 服务器注意事项 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 远程配置防火墙时不要把自己踢出服务器 指定合理的密码规范和定期更新 合理分配权限 定期备份重要数据和日志 Linux常用命令文件处理命令ls ls -l：查看文件所有属性 ls -d：查看目录本身 ls -i：查看文件的inode号 ls -h：人性化显示 ls -s：显示文件占用的块的数量 ls -a：查看隐藏文件 mkdir mkdir -p：递归创建目录 cd&amp;pwdrmdircp cp -r：复制目录 cp -p：原文件和新文件属性完全一致 注：复制的同时可以改名 mv​ 注：移动的同时可以改名 rm rm -r：文件夹递归删除 rm -f：强制删除，不询问 touchcat&amp;tac cat -n：显示行号，tac没有-n选项 more​ 空格翻页，回车换行，q退出 less​ 空格翻页，回车换行，q退出，还可以pageup回翻页，上箭头网上翻一行，还可以搜索：/关 键词，再按n搜索下一个匹配的 head head -n：指定看前几行，默认前10行 tail tail -n：指定看后几行，默认后10行 tail -f：动态看文件动态变化 ln ln -s：生成软链接 ln：生成硬链接，和cp -p的区别是硬链接文件和原文件可以同步更新，硬链接通过inode号来区分。和软连接的区别：1.硬链接不能跨分区 2.硬链接不能针对目录 权限管理命令chmod chmod [u/g/o/a] [+/-/=] [r/w/x] chmod 三位数XXX：r—4，w—2，x—1：举例：rwxr-xr-x：755 chmod -R：递归修改目录及目录下的权限 注释：深入理解文件的wrx和目录的wrx的意义 chown chown [用户名]：只有管理员root能执行 chgrp chgrp [组名]：只有管理员root能执行 注：每个文件都只有一个user和一个group，某些others拥有拥有共同的权限，这些others在一个组里，也就是group所属组。所属者user可以不在所属组group里面，并且一个用户可以在不同的组里。 相关的命令是： 123groupadd YYY //创建组useradd -g YYY XXX //创建用户并将YYY设置为其主要组usermod -g ZZZ XXX //修改用户XXX的主要组为ZZZ umask umask -S：人性化显示默认权限 umask：显示掩码（非人性化） 注：Linux中，默认创建的文件是没有可执行权限的，所以文件是666，目录是777 umask 三位数：修改掩码，使默认权限变化 文件搜索命令find：精准搜索 find -name：根据文件名搜索 find -iname：根据文件名搜索，不区分大小写 注：通配符：*，？，[]， find -size [+/-]：+：大于，-：小于，只有数据块（0.5KB）个数：等于 find -user：根据所有者查找 find -group：根据所属组查找 find -amin [-/+]分钟数：查找指定时间内或者超过该时间被修改过访问时间的文件 find -cmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件属性的文件 find -mmin [-/+]分钟数：查找指定时间内或者超过该时间被修改过文件内容的文件 还可以在两个查找条件之间加上-a 或者-o ，一个是同时满足，一个是满足任意一个即可。或者-exec/-ok 命令 {}\\; 对搜索结果执行操作 find -type：根据文件类型查找 find -inum：根据inode号查找 locate：模糊查找 系统里所有的文件都会定期收录到/var/lib/mlocate.db这个文件库里，locate就是在这个里去找，但是新的文件没别收录进去，所以就找不到，需要手动更新文件资料库updatedb （但是tmp目录下不收录进去） locate -i：不区分大小写 which which 命令名：查找命令的地址和别名alias whereis whereis 命令名：查找命令地址和其帮助文档的位置 grep：在文件里面查找 grep -i：不区分大小写，查找指定字串所在的行 grep -v：排除指定字串所在的行 帮助命令man和info man 命令名/配置文件名：查看命令和配置文件的帮助信息，浏览和more操作一样 帮助类型里1是命令的帮助，5是配置文件的帮助 For Example：man 1 passwd，man 5 passwd whatis 更加简单的命令查询 apropos 更加简单的配置文件查询 –help 命令 –help：得到信息更加简单 help shell的内置命令的帮助 用户管理命令useradd和passwd 新建用户和修改密码 who和w 查看当前登录用户名：tty是本地登录，pts表示远程登录 压缩解压命令​ 几种压缩格式 .gz .zip .bz2 gzip和gunzip/gzip -d 只能压缩文件，不能压缩目录，并且不保留原文件 tar tar -c：打包 tar -x：解包 tar -v：显示详细信息 tar -f：指定文件名 tar -z：打包的同时压缩，或者解包的时候解压缩,适用于压缩解压gz tar -j：同-z，适用于压缩解压bz2 For Example：tar -cvf XXX.tar YYY gzip XXX.tar ，最后生成XXX.tar.gz 。或者直接tar -zcvf打包压缩一部合成，反向是tar -zxvf zip和unzip：压缩比不高 压缩后能保留原文件 zip -r：压缩目录 bzip2和bunzip2：gzip的升级版本，压缩比较好 bzip2 -k：压缩的同时保留原文件 bunzip -k：解压的同时保留原文件 网络命令write write 用户名：给在线用户发信息，以ctrl+D保存结束 wall wall 信息内容：给当前在线的所有用户发送信息 ping 网络踩点，Linux会一直ping下去 ping -c 次数：定义ping的次数 ifconfig 查看当前系统网卡信息和设置网卡信息（临时的） mail 查看和发送邮件：不一定要在线 mail 用户名：发动 mail：查看的子命令：help(帮助)，数字(查看指定邮件)，h(列表)，d 数字(删) last 日志查询命令，统计系统的所有登录信息 lastlog 查看用户最后登录的信息 lastlog -u uid：查看指定用户上次登录的信息 traceroute traceroute ip地址：跟踪节点的路径 netstat：显示网络相关信息 netstat -t：TCP协议 netstat -u：UDP协议 netstat -l：监听 netstat -r：路由 netstat -n：显示ip地址和端口号 最常用的三种组合命令： netstat -tlun：查看本机监听的端口 netstat -an：查看本机所有的网络连接 netstat -rn：查看本机路由表 setup：redhat系linux独有 配置网络的工具：永久生效 配置完需要重启网络服务：service network restart 挂载命令mount mount [-t 文件系统] 设别文件名 挂载点 For Example：mount -t iso9660 /dev/sr0 /mnt/cdrom umount umount 设备文件名：卸载 关机重启命令shutdown shutdown -h 时间（now）：关机 shutdown -r 时间：重启 shutdown -c：取消前一个关机命令 其他关机命令：halt,poweroff,init 0其他重启命令：reboot,init 6init 系统运行级别：0：关机，1：单用户，2：不含NFS服务的多用户，3：完全多用户，4：未分配，5：图形界面，6：重启 /etc/inittab配置文件里面有运行级别的信息，方便查询，也可以改运行级别 init 数字：设置系统运行级别，临时更改 runlevel：查看当前运行级别 runlevel:查询系统运行级别logout和exit 都是退出登录：logout退出是把因为你注销了登陆机而把你踢出的退出，exit是你直接退出连接的机器。","link":"/2020/03/04/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"linux权限管理","text":"ACL权限ACL权限的简介和开启方式 任何一个文件在一个时刻只能有一个所有者和所属组 ACL权限用来解决文件的权限身份不够用的情况 ACL权限需要分区支持：dumpe2fs -h /dev/sda5/查看是否支持acl选项，如果不支持。可以临时开启：mount -o remount,acl/ 或者永久开启：vim /etc/fstab然后重启系统 ACL权限类似于windows的权限设置方法，就是不考虑user，group和others的权限设置，单独添加一个用户或者一个用户组对一个文件或者目录的权限 查看与设定ACL权限 getfacl 文件名：查看ACL的权限 setfacl 选项 文件名 setfacl -m u/g/m:用户名/组名/不写:权限 文件名：设定文件的ACL权限 最大有效权限与删除ACL权限 最大有效权限mask：可以通过getfacl 文件名来查看ACL的权限，里面有mask，可以通过控制mask的值来修改默认最大有效权限。 需要注意的是mask权限不会影响当前文件所有者，只会影响ACL权限和所属组的权限 setfacl -x u/g:用户名/组名 文件名：删除文件指定的ACL权限 setfacl -b 文件名：删除文件所有ACL权限 默认ACL和递归ACL权限（只能针对目录） setfacl -m d:u/g:用户名/组名:权限 文件名：设定父目录的默认ACL权限，父目录里所有的新建文件都会继承父目录的ACL权限 setfacl -k：删除父目录的默认ACL权限 setfacl -m -R ...：递归设定文件夹的ACL权限 文件特殊权限SetUID：在所有者的x位置上变成了s 四个条件缺一不可： 只有二进制文件（例如命令和脚本文件）才能设定SUID权限 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的属主身份 SUID权限只在该程序执行过程中生效，也就是身份改变旨在程序执行过程中有效 passwd命令拥有SetUID权限，所以普通用户能修改自己密码 我们通常会看到4777，2777，1777的权限标识，依次是加了SUID，SGID，SBIT权限 可以用chmod来赋予和删除SUID SetUID是非常危险的，一个命令只要有了s权限，例如passwd命令，普通用户就可以通过执行这个命令获得passwd的属主身份，也就是进入root权限。 SetGID：在所属组的x位置上变成了s 针对二进制文件，三个条件缺一不可： 命令执行者必须对该程序有x权限 命令执行者会在执行的时候获得该程序文件的所属组身份 SUID权限只在该程序执行过程中生效，也就是所属组身份改变旨在程序执行过程中有效 注：例如/usr/bin/locate命令 针对目录，三个条件缺一不可： 普通用户必须对此目录拥有r和x权限，才能进入该目录 普通用户在此目录中的有效组会变成此目录的所著组 若普通用户对此目录拥有w权限时，新建的文件的默认组不是文件自己的初始组，而是这个目录自己的所属组 可以用chmod来赋予和删除SGID Sticky BIT(黏着位)：在其他人的x位置上变成了t 四个条件缺一不可： 只有目录才能设定SBIT权限 普通用户必须对该目录有x和w权限 有了SBIT，普通用户即使有目录的w权限，也不能删除其他用户建立的文件 需要注意的安全性： 需要定期对系统中含有SUID或者SGID权限的文件进行检查，如果有异常多出来的含有该权限的文件，如果多出来了，是一个极大的安全隐患，需要手工清除。 文件系统属性chattr权限 chattr：change file attributes on a linux file system chattr [+-=] [选项] 文件或目录名：增加，减去，等于chattr权限 i选项： ​ 1.对文件：不允许任何用户（包括root用户）对文件进行任何修改，只能读 ​ 2.对目录：任何用户（包括root用户）只能在目录下修改文件内容，但是不能删除和创建文件 a选项： ​ 1.对文件：任何用户（包括root用户）只能对文件增加数据，但是不能删除和修改现有数据 ​ 2.对目录：任何用户（包括root用户）只能在目录中建立和修改文件里的内容，但是不能删除文件 查看文件系统属性：lsattr lsattr 选项 文件名 ​ -a选项：显示所有文件和目录 ​ -d选项：若文件时目录，仅列出目录自己的属性 系统命令sudo权限 之前学的是对文件的操作权限，sudo是对系统命令的权限。sudo权限是root把本来只能超级用户执行的命令赋予普通用户的执行 root权限先执行命令visudo命令修改/etc/sudoers文件 在这一行root ALL=(ALL) ALL下面添加例如： ​ jack ALL=/sbin/shutdown -r now：授权jack能重启服务器的权限 然后相应用户或者用户组用sudo -l查看自己能用那些sudo命令，然后sudo 命令执行","link":"/2020/03/06/linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"title":"linux的文件系统管理","text":"分区和系统文件 对于硬盘分区形式是MBR的，主分区+扩展分区&lt;=4个。如果是IDE硬盘，Linux最多支持59个逻辑分区；如果是SCSI硬盘，Linux最多支持11个逻辑分区 对于GPT分区形式而言，没有上述限制 Windows文件系统为FAT16、FAT32、FAT64和NTFS。而Linux的文件系统可分为ext2、ext3、ext4、swap和vfat。 格式化的目的就是写入文件系统 文件系统常用命令df命令，du命令，fsck命令，dumpe2fs命令 df -a -h：显示所有分区&amp;人性化显示。(一般用来统计系统空间大小) du -a -h -s：弥补ls命令的不足，可以统计文件夹包括里面的内容的大小而不是单单文件夹的大小。(一般用来统计文件大小) df和du的区别：du只是面向文件的，只会计算文件或目录占用的空间；df是从文件系统角度考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经删除但是程序并没有释放空间） fsck -a -y 分区设备文件名：文件系统修复命令，不需要自己手动执行 dumpe2fs 分区设备文件名：显示ext2、ext3、ext4文件系统的超级块和块组信息 挂载命令 将设备文件名和绑定到盘符(挂载点)上，Windows是自动，Linux默认是手动分配 mount -l：查询异已挂载的设备，加-l会显示卷标名 mount -a：依据配置文件/etc/fstab中的内容，自动挂载 mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点 挂载光盘和U盘 Linux中的分区时开机自动挂载，但是光盘和U盘时手动挂载，系统准备了/mnt/和/media/来挂载 挂载光盘步骤：（sr0和cdrom都可以作为设备文件名） mkdir /mnt/cdrom/：建立挂载点 mount -t iso9660 /dev/cdrom /mnt/cdrom/或者mount /dev/sr0 /mnt/cdrom：挂载 cd /mnt/cdrom/：去挂载点访问 umount 设备文件名或挂载点：在拿走光盘之前需要先卸载光盘 挂载U盘步骤：（U盘的设备文件名是自动识别的，用fdisk -l查看） mkdir /mnt/usb/：建立挂载点 mount -t vfat /dev/sdb1 /mnt/usb/：挂载 cd /mnt/usb/：去挂载点访问 umount 设备文件名或挂载点：在拔U盘之前需要先卸载光盘 注意：挂载U盘只能用本机或者虚拟机，不能用远程工具 ​ Linux默认是不支持NTFS文件系统的外设的，U盘只能FAT格式的 Linux如何支持NTFS文件系统 Linux系统的内核中已经把市面上常见的驱动包括了，所以安装系统后一般不需要安装驱动，Linux会自动匹配识别，如果Linux默认没有把一个文件系统的驱动加载进来，我们就需要手动去安装驱动。 几种让Linux支持NTFS文件系统的方法： 内核重新编译 第三方的插件：ntfd-3g 内核编译太麻烦，太高端，一般选择“ntfd-3g插件”来实现 安装步骤： tar -zxvf ntfs-3g_ntfsprogs-2013.1.13.tgz：解压 cd ntfs-3g_ntfsprogs-2013.1.13：进入解压目录` ./configure：编译前准备 make：编译 make install：编译安装 mount -t ntfs-3g 设备文件名 挂载点：挂载NTFS分区的硬盘 fdisk分区fdisk命令分区过程 虚拟机添加新硬盘，并用fdisk -l查询新硬盘是否被识别 若已识别新硬盘/dev/sdb/，就开始为新硬盘分区，fdisk /dev/sdb/进入fdisk交互模式 partprobe：分完区后必须执行这个命令，重新读取分区表信息 然后格式化分区：mkfs -t ext4 /dev/sdb1 mkfs -t ext4 /dev/sdb5 最后创建挂载点并挂载：mkdir /disk1 mount /dev/sdb1 /disk1/ mkdir /disk5 mount /dev/sdb1 /disk5/ fdisk -l：查看，两个分区挂载完毕 分区自动挂载和/etc/fstab文件修复 上面的mount命令挂载只能临时生效，每次重启都要手动挂载硬盘，要想永久生效，就要修改/etc/fstab配置文件的内容。 添加了挂载信息后，执行mount -a，依据配置文件/etc/fstab中的内容，自动挂载 万一/etc/fstab文件写错了，会导致系统崩溃 /etc/fstab文件修复：出错后按提示进入root操作界面，发现/etc/fstab文件是只读，执行mount -o remount,rw /，就可以修改/etc/fstab文件了，就可以修复了。","link":"/2020/03/06/linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"title":"linux系统管理","text":"进程管理的作用：（下面优先级由高到低） 判断服务器的健康状态 查看系统中的所有进程 杀死进程 进程查看 ps aux：查看系统中所有进程，查看BSD操作系统格式 ps -le：查看系统中所有进程，Linux格式 输出格式的作用： top（每3秒更新一次） -d 秒数：默认每3秒更新一次，可指定 ？或h：显示交互模式的帮助 P：以CPU使用率排序 M：以内存使用率排序 N：以PID排序 q：退出top top命令的显示： pstree：查看进程树 进程终止 kill -l：查看kill支持的信号 -1 PID：重启进程 -9 PID：终止进程 killall 进程名：按照进程名杀死，选项和kill通用 -i：有询问 -I：忽略进程名的大小写 pkill 进程名：按照进程名杀死，选项和kill通用 也可以加t选项跟终端号：pkill -t 终端号：按照终端号踢出用户，用 w 命令查询系统中登录的用户，然后用终端号来踢 工作管理 把进程放入后台 命令后面加&amp;：后台继续运行 在命令执行过程中，按下ctrl+z快捷键：放入后台即暂停 查看后台的工作：jobs -l：加l会显示工作号 bg %工作号：恢复后台暂停的工作恢复到后台运行，但是不能恢复和前台有交互的命令比如top命令和vim命令 fg %工作号：恢复后台暂停的工作恢复到前台运行 注意：工作号≠PID 系统资源查看 vmstat 刷新延时(s) 刷新次数：监视系统资源使用情况，和top内容差不多，但更简洁 dmesg：开机时内核检测，一般结合grep使用 free：查看内存使用情况 -b：以字节为单位显示 -k：以KB为单位显示（默认就是） -m：以MB为单位显示 -g：以GB为单位显示 查看CPU信息： cat /proc/cupinfo:每次开机都会更新 dmesg | grep CPU uptime：实际就是top命令第一行 uname：查看系统与内核相关信息 -a：查看系统所有相关信息 -r：查看内核版本 -s：查看内核名称 判断当前系统的位数：file /bin/ls（通过系统外部命令的位数来推测） lsb_release -a：查询Linux系统的发行版本 lsof -p PID：列出进程调用的文件 系统定时任务前提：必须启动crond服务：service crond restart并且chkconfig crond on，Linux系统都是默认启动和自启动的 crontab：设置系统定时任务 -e：编辑crontab定时任务 -l：查询crontab任务 -r：删除当前用户所有的crontab任务 打开文件编辑的格式是：* * * * * command 第一个*：分钟（0-59） 第二个*：小时（0-23） 第三个*：天（1-31） 第四个*：月（1-12） 第五个*：星期（0-7，0和7都代表星期日） 特殊符号：","link":"/2020/03/10/linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"},{"title":"linux系统简介和安装","text":"UNIX和Linux发展史​ 1965年，贝尔实验室：MULTICS计划 ​ 69年，贝尔实验室的肯汤普森：为了游戏开发UNICS/UNIX系统 ​ 62年，美国军方：ARPA：阿帕网，NCP协议——》TCP/IP协议 ​ 71年，可汤普森和丹尼斯里奇发明C语言，重写UNIX ​ UNIX主要发行版本：AIX(IBM)、HP-UX(HP)、Solaris(Sun)、Linux(Intel,AMD……)、BSD ​ 1991年，芬兰大学生Linus Torvalds开发linux内核。大学教授开发minix，但是不接受外来代码，所以李纳斯独自开发，由社区共同维护。 ​ Linux内核版本号：主版本.次版本.末版本 linux内核官网 ​ Linux发行版本：两大派系redhat和debian 开源软件简介​ 商业软件和开源软件（开源≠免费） ​ 开源软件：apache、NGINX、MySQL、php、mongoDB、python、Ruby、Perl、Go、Rust、Swift、Java ​ 开源软件的特点：使用自由（绝大多数免费）、研究自由（源代码）、散步和改良的自由 ​ 支撑互联网的开源技术（LAMP）：Linux，Apache，MySQL，PHP Linux应用领域 基于Linux的企业服务器 踩点网站：发数据包根据相应嗅探服务器 世界前500服务器 嵌入式应用 手机，平板：Android底层是Linux 智能家电，航空系统，银行系统…… 在电影娱乐业 特效，图形处理渲染 Linux学习方法​ Linux只考虑应用性和稳定性 ​ 善于观察提示信息，查找文档，自己解决问题 ​ 学习英文：Command not found和No Such file or directory ​ 忘掉Windows的操作习惯 ​ 计划，专注，坚持，练习 Linux系统安装VMware虚拟机安装​ VMware官网下载，不推荐安装双系统 ​ 特点： 不需要分区就能在物理机上使用两种以上的操作系统 物理机和虚拟机能实现网络通信 可以设定并随时修改虚拟机操作系统的硬件环境 要求： CPU：主频1GHz以上 内存：1GB以上 硬盘：8GB以上 镜像下载： 官网下载:几个版本：DVD版本，Everything版本，minimal版本，LiveGnome版本，KdeLive版本，livecd版本，NetInstall版本 系统分区​ 主分区：最多只能有4个 ​ 扩展分区：最多只能有一个；主分区加扩展分区最多有4个；不能写入数据，只能包含逻辑分区 ​ 逻辑分区：可以和主分区一样正确的写入数据和格式化 ​ 注意：这套视频录制时间较为久远，当时的硬盘分区形式是MBR的，所以上述的分区限制也只 是针对MBR分区形式，对于GPT分区形式而言，则没有上述限制了。 ​ 电脑根据主板的不同（BOIS或者UEFI），会决定硬盘选择MBR分区方案还是GPT分区方案： BIOS + MBR UEFI + GPT 两者区别： 也就是说，电脑使用传统BIOS主板，建议使用MBR分区方案；电脑使用UEFI主板，建议使用GPT分区方案 MBR分区表最多只能识别2TB左右的空间，大于2TB的容量将无法识别从而导致硬盘空间浪费；GPT分区表则能够识别2TB以上的硬盘空间。 MBR分区表最多只能支持4个主分区或三个主分区+1个扩展分区(逻辑分区不限制)；GPT分区表在Windows系统下可以支持128个主分区。 在MBR中，分区表的大小是固定的；在GPT分区表头中可自定义分区数量的最大值，也就是说GPT分区表的大小不是固定的。 硬盘分区的作用： 把一块大硬盘分成几块 格式化的作用： 写入文件系统（1.把硬盘分成一个个等大小的数据块 同时2.建立一个inode列表） Linux中的所有硬件都是文件： 硬盘文件名： IDE硬盘：/dev/hd[a-d] SCSI/SATA/USB硬盘：/dev/sd[a-p] 光驱：/dev/cdrom或/dev/sr0 鼠标：/dev/mouse 分区文件名： /dev/hda[数字]: /dev/sda[数字] 挂载： 给分区分配挂载点 /根分区 swap交换分区（内存两倍，最大不超多2GB） /boot启动分区（200MB足够） 总结： 分区：把大硬盘分为小的分区 格式化：写入文件系统，同时会清空数据 分区设备文件名：给每个分区定义设备文件名 挂在：给每个分区分配挂载点，这个挂在点必须是空目录 Linux系统安装​ 把镜像加进去，点击启动，然后用图形界面配置分区和其他的自定义选项，确定定义root用户的密码和普通用户的账号和密码。然后等待安装完成即可。 远程登陆管理工具​ 三种网络连接方式： 桥接模式：虚拟机使用物理网卡 NAT模式：虚拟机使用vmnet8虚拟网卡 Host-only模式：虚拟机使用vmnet1虚拟网卡，并且只能和本机通信 临时配置ip：ifconfig ens33 192.168.XXX.XXX 永久配置ip：vim /etc/sysconfig/network-scripts/ifcfg-ens33 修改，见教程","link":"/2020/03/04/linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85/"},{"title":"linux的服务管理","text":"服务简介与分类 Linux服务分类 RPM包默认安装的服务 独立的服务 基于xinetd（超级守护进程）服务 源码包安装的服务（第三方源码包） 服务的启动与自启动 查询已安装的服务 RPM包安装的服务：chkconfig --list：查看RPM包安装的服务按照运行级别的自启动状态。如果查询当前启动的服务，用ps aux或者netstat或者service --status-all 源码包安装的服务：没有命令，只能去服务安装位置查看，一般在/usr/local/下 其实源码包和RPM包安装的服务在Linux中的区别就是安装位置不同 RPM包安装服务的管理​ RPM包安装的服务默认保存位置：(特殊文件有自己的默认保存位置) 独立服务的管理 启动方式：/etc/init.d/独立服务名和service 独立服务名 自启动方式： chkconfig --level 运行级别 独立服务名：打开自启动 chkconfig 独立服务名 off：关闭自启动 修改/etc/rc.d/rc.local文件,加入需要自启动的服务名 使用ntsysv命令管理自启动，图形界面很直观 基于xinetd(超级守护进程)服务的管理 默认情况下Linux是没有xinted的，需要手动安装yum -y install xinetd 然后用chkconfig --list查看，基于xinetd的服务不占用内存，但是需要的响应时间更长 基于xinetd的服务的启动，修改/etc/xinetd.d/下对应的服务的配置文件,然后service xinetd restart 基于xinetd的服务的自启动： chkconfig 服务名 on和chkconfig 服务名 off 图形界面工具：ntsysv 基于xinetd的启动和自启动是通用的，两者区分不是很严格，这种设置不利于管理，所以现在基于xinetd的服务越来越少了 源码包安装服务的管理​ RPM包安装的服务默认保存位置：/usr/local/ 源码包安装服务的启动和关闭(用绝对路径的启动脚本启动)：/usr/local/apache2/bin/apachectl start|stop 一般每一个源码包都有安装说明INSTALL，应该查看里面的启动方法 源码包安装服务的自启动： vim /etc/rc.d/rc.local加入/usr/local/apache2/bin/apachectl start 把源码包服务的启动脚本软连接到/etc/init.d/目录下和chkconfig --add 服务名，就可以实现service，chkconfig和ntsysv命令管理源码包安装服务，但是并不推荐，容易混乱。","link":"/2020/03/10/linux%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"title":"linux日志管理","text":"日志管理简介 百度百科简介：系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。 服务器出现问题先查看日志，才能找准原因 CentOS7中原来的日志服务syslogd被rsyslogd取代，两者兼容 确认服务是否启动和自启动： ps aux | grep rsyslogd chkconfig --list | grep rsylog 常见的日志的作用： RPM包安装的服务日志也会在/var/log/目录下 源码包安装的服务日志在源码包指定目录（一般是/usr/local）中，这些日志不是有rsyslogd服务来管理的，而是由各个服务使用自己的日志管理文档来记录自身日志 rsyslogd日志服务日志文件格式 事件产生的时间 产生事件的服务器的主机名 产生事件的服务名或程序名 事件的具体信息 /etc/rsyslog.conf配置文件​ 格式： authpriv.* /var/log/secure 服务名称[连接符号]日志等级 日志记录位置 服务名称，连接符，日志等级，日志记录位置都有多个，内容很多，自行百度。 日志轮替如果日志都记录在一个文件中，那么可能会占据大量存储空间，纯文本文档打开会非常慢，所以日志需要处理：切割（把大日志按天切割成小的）+轮换（删除旧的，保存新的） 如果配置文件中由“dateext”参数，那么日志会用日期作为后缀，只需要保存指定的日志个数，删除多余的日志文件即可 如果没有“dateext”参数，那么日志文件就需要改名了，当第一次使用日志轮替时，当前的“secure”日志会自动改名为“secure.1”，然后新建“secure”日志。第二次时，1变2，0变1，又新建0，以此类推 配置文件：/etc/logrotate.conf 包含参数：daily，weekly，monthly，rotate，compress，create mode owner group等 分别表示：轮替周期时每天，每周，每月，保存日志文件的个数，旧日志是否压缩，建立新日志同时指定权限 只要是RPM包安装的服务，它默认已经支持轮替，但是源码包安装的服务需要vim /etc/logrotate.conf，然后手动加入轮替 FOR EXAMPLE: 12345/usr/local/apache2/logs/access_log{ daily //每天备份 create //备份的时候创建新的日志 rotate 30 //保留30天} logrotate -v /etc/logrotate.conf：显示日志轮替过程 logrotate -f /etc/logrotate.conf：强制轮替，不管日志轮替的条件是否已经满足","link":"/2020/03/10/linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"},{"title":"linux网络配置","text":"网络命令12345678910#配置eth0的IP地址， 同时激活该设备sudo ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up#添加默认网关 sudo route add default gw 192.168.1.1#配置DNSsudo vi /etc/resolv.conf#激活设备ifconfig eth0 up#禁用设备ifconfig eth0 down 网络配置1234567#查看相应设备名称对应的设备信息ethtool eth0#查看相应设备名称对应的设备位置(回车后与eth0 相对应的网卡接口旁边的指示灯就会闪烁，这样你就能很快确定eth0 网口的位置啦)ethtool -p eth0#Linux里面有两套管理网络连接的方案,两套方案是冲突的，不能同时共存。 /etc/network/interfaces（/etc/init.d/networking） Network-Manager 都是基于单网卡单ip的配置 静态配置Redhat类1sudo vim /etc/sysconfig/network-scripts/ifcfg-eth[x]文件([x]为使用的网卡) 12345678910111213# xxxxxxx(网卡名称，不用改)DEVICE=eth0BOOTPROTO=staticTYPE=etherHWADDR=xx:xx:xx:xx:xx:xx (网卡mac地址，不用改)IPADDR=x.x.x.x(ip地址)NETMASK=x.x.x.x(子网掩码)BROADCAST=x.x.x.x.(广播地址)NETWORK=x.x.x.x(网络地址)GATEWAY=x.x.x.x(网关地址)ONBOOT=yes(开机自启动)DNS1=x.x.x.x(域名服务器地址)DNS2=x.x.x.x Ubuntu类1sudo vim /etc/network/interfaces 12345678# The primary network interface (配置主网络接口) auto eth0 #开机自动激活eth0接口 iface eth0 inet static #配置eth0接口为静态地址 address 192.168.1.10 gateway 192.168.1.254 Netmask 255.255.255.0 network 192.168.1.0 broadcast 192.168.1.255 动态配置Redhat类123456# xxxxxxx(网卡名称，不用改)DEVICE=eth0BOOTPROTO=dhcpTYPE=etherHWADDR=xx:xx:xx:xx:xx:xx (网卡mac地址，不用改)ONBOOT=yes(开机自启动) Ubuntu类123456# The loopback network interface (配置环回口) auto lo # 开机自动激lo接口 iface lo inet loopback # 配置lo接口为环回口 # The primary network interface #配置主网络接口 auto eth0 #开机自动激活eth0接口 iface eth0 inet dhcp #配置eth0接口为DHCP自动获取 VM的三种网络模式 打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的VMnet0表示的是用于桥接模式下的虚拟交换机；VMnet1表示的是用于仅主机模式下的虚拟交换机；VMnet8表示的是用于NAT模式下的虚拟交换机。 同时，在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。","link":"/2020/11/20/linux%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"title":"makefile基础语法","text":"C/C++文件到可执行文件的过程1234gcc -E xx.c -o xx.i 预处理gcc -s xx.i -o xx.s 编译gcc -c xx.s -o xx.o 汇编gcc xx.o -o xx 链接 ​ 对于单个文件的编译，可以浓缩为一条命令 1gcc xx.c -o xx ​ 但是在实际开发中，我们的一个项目有多个文件，并且有多层文件夹的嵌套。makefile文件就是为了解决这个问题而出现的 makefile文件的基础语法1. 第一层次：easiest​ 基本格式： 12目标文件： 依赖文件(一个tab)gcc/g++指令 ​ 伪目标： 1234.PHONY:clear（名字自定义）: rm -rf xx.o xx.s xx.i xx.exe(运行的时候：make clear) ​ For Example: 12345678910111213141516171819#circle.c circle.h cube.c cube.h main.c main.htest: circle.o cube.o main.o gcc circle.o cube.o main.o -o testcircle.o :circle.c gcc circle.c -o circle.ocube.o :cube.c gcc cube.c -o cube.omain.o :main.c gcc main.c -o main.o.PHONYclearall: rm -rf circle.o cube.o main.o testclear: rm -rf circle.o cube.o main.o 2. 第二层次：（变量）（用美元符$(TAR)表示） Makefile中变量有四种赋值方式: 简单赋值**( := )** 编程语言中常规理解的赋值方式，只对当前语句的变量有效 递归赋值**( = )**赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响 条件赋值**( ?= )**如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。 追加赋值**( += ）**原变量用空格隔开的方式追加一个新值 12345TAR=testOBJ=circle.o bube.o main.oCC:=gcc使用的时候：$(TAR) $(OBJ) $(CC) 3. 第三层次：（通配符）123456%：应用在这个Makefile文件中的*：应用在系统中的$@：表示目标文件$^：表示所有的依赖文件 $&lt;：表示第一个依赖文件$?：表示比目标还要新的依赖文件列表 ​ %和*的区别:引用一篇博文 4. 第四层次：（函数）​ 暂时没有涉及，之后会补齐","link":"/2020/03/03/makefile%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"linux软件包管理","text":"软件包管理简介​ 软件包分类： 源码包：包括脚本安装包 二进制包：RPM包，系统默认包（ubuntu中是deb包） 源码包的优点 开源 可以自由选择所需的功能 软件是便宜安装，所以更加是个自己的系统，更加稳定也效率更高 卸载方便（直接把目录删除） 源码包的缺点 安装步骤多 编译并安装时间过长 因为是编译安装，安装过程中一旦报错新手很难解决 RPM包优点 包管理系统简单，只需要几个命令就可以实现软件包的安装，升级，查询和卸载 安装速度比源码包快很多 RPM包缺点 不能看见原代码 功能选择不如源码包灵活 依赖性 RPM包管理—rpm命令管理 RPM包名和包全名 RPM包的依赖性：树形依赖，环形依赖，模块依赖(以.iso.数组结束的就是模块依赖，也叫库文件依赖模块依赖查询网站) 安装和升级使用包全名，卸载和查询使用包名（在/var/lib/rpm/中的数据库总搜索） RPM安装：rpm -ivh 包全名 RPM升级：rpm -Uvh 包全名 RPM卸载：rpm -e 包名,也要考虑依赖性，当有包被依赖时，此时这个包不能删掉 RPM查询包：rpm -q 包名 rpm -qa：所有安装的包 RPM查询包详细信息：rpm -qi 包名 RPM查询未安装包的详细信息：rpm -qip 包全名 RPM查询文件安装位置：rpm -ql 包名 RPM查询未安装包的文件安装的默认位置：rpm -qlp 包名 RPM查询系统文件属于哪个rpm包：rpm -qf 系统文件名 RPM查询软件包的依赖性：rpm -qR 包名 RPM查询未安装软件包的依赖性：rpm -qRp 包全名 RPM包校验：rpm -V 包名 RPM包中文件提取（用来修复系统）： 第一步：rpm2cpio 包全名 第二布：cpio -idv . 包中的文件绝对路径 RPM包管理—yum在线管理 既可以用在线yum源文件服务器，也可以用本地光盘作为yum源文件服务器。 会自动解决依赖性问题 更换yum源：保存在/etc/yum.repos.d/目录下 yum list： yum search 包名：搜索 yum -y install 包名：安装 yum -y update包名：yum -y update直接升级全部，慎用 yum -y remove包名：卸载，会卸载所有依赖的包 注：linux服务器应该采用最小化安装的原则，用什么装什么，装完了最好不要用yum卸载，也不要随便升级。 yum的软件组管理： yum grouplist： yum groupinstall 软件包组名： yum groupremove软件包组名： 用光盘做yum源：修改/etc/yum.repos.d/下的media配置文件，该源为关盘挂载点，注意：配置文件的格式要求很严格，注释应该顶头写。 源码包管理 区别： 安装前的区别：概念上的区别，见上述 安装后的区别：安装位置的区别 RPM包（一个软件）的默认安装位置： /etc/：配置文件 /usr/bin/：可执行的命令 /usr/lib/：程序所使用的函数库 /usr/share/doc/：基本的软件使用手册 /usr/share/man/：版主文档 /var/www/html/：服务器类软件的默认网页位置 源码包的安装位置： 需要手动指定安装目录：一般推荐/usr/local/软件名/ RPM包和源码包安装软件带来的影响：启动服务的方式不同 RPM包在/etc/rc.d/init.d/下有执行文件，采用两种方式启动：For Example: /etc/rc.d/init.d/httpd start service httpd start 但是源码包的服务启动方式不能用系统服务管理命令例如service来管理。只能在/usr/local/软件名/bin/执行软件吗 start 目录下启动服务 Apache源码包的具体安装步骤： 安装C语言编译器：gcc 下载apache的源码包：path 确认源码保存位置/usr/local/src/ 确认软件安装位置：/usr/local/ 确认安装过程报错 安装过程停止并出现error，warning，no等提示语言 解压缩下载的源码包：tar -zxvf 源码包名 进入解压缩目录：INSTALL和README时安装说明和使用说明 执行./configure --prefix=默认安装目录：编译前准备 定义需要的功能选项 检测系统环境是否符合安装要求 把定义好的的功能选项和检测系统环境的信息都写入makefile文件，用于后续的编译 执行make：编译 如果前两步报错，执行make clean，清空过程中生成的临时文件。 执行make install：安装 删除源码包安装的软件：直接rm -rf /usr/local/软件名/ 脚本安装包与软件包管理 脚本安装包不是独立的软件包类型，常见安装的是源码包 人为包安装过程写成额自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装 非常类似于windows下软件的安装方式 Webmin是一个基于Web的Linux系统管理界面，可以通过图形化的方式设置用户账号、Apache、DNS、文件共享等服务。下载软件，下载后解压缩，并进入解压缩目录，执行.sh安装脚本,最后登录ip地址的自己配置的端口号进入该网站即可","link":"/2020/03/05/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"},{"title":"redis缓存技术","text":"Redis简介：概念：redis是一款高性能的NOSQL（Not Only SQL）系列的菲关系型数据库 Redis特点： Redis 是一个开源的使用 ANSI、C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。 Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。 关系型数据库和非关系数据库是互补的关系，通常情况下使用关系型数据库，在适合的情况下使用NOSQL数据库能够堆关系型数据库的不足进行弥补从而提高网站的性能。 一般会将数据存储在关系型数据库中，在nosql数据库中备份关系型数据库的数据 目前Redis支持的键值数据类型如下： 字符串类型：string 哈希类型：hash 列表类型：list 集合类型：set 有序集合类型：sortedset Redis的应用场景： 缓存（数据查询，短连接，新闻内容，商品内容） 聊天室的在线好友列表 任务队列（秒杀，抢购，12306抢票） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒级别） 分布式集群架构中的session分离 安装debian：sudo apt install redis 启动服务：执行sudo systemctl start redis 关闭服务：执行sudo systemctl stop redis 进入客户端：redis-cli 命令操作 字符串类型：string 123set key valueget keydel key 哈希类型：hash 1234hset key field valuehget key fieldhgetall keyhdel key field 列表类型：list 12345lpush key valuerpush key valuelrange key start endlpop keyrpop key 集合类型：set 123sadd key valuesmembers keysrem key value 有序集合类型：sortedset 123zadd key score valuezrange key start end [withscores]zrem key value 通用命令： keys *：查询所有的键 type key：获取键对应的value的类型 del key：删除指定的key value 持久化： redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 Redis的持久化机制 RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1234567编辑/etc/redis/redis.conf文件# after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定redis.conf：redis-server /etc/redis/redis.conf 注意：在linux上通过apt安装的redis，关闭服务器后重启默认会重现之前数据，也就是默认使用了RDB的方式。配置文件在/etc/redis/redis.conf，rdb存储文件在/var/lib/redis目录下。 AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件 12345appendonly no（关闭aof） --&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 Redis的java客户端：Jedis 使用步骤： 导入Jedis相关jar包 使用 123456//1. 获取连接Jedis jedis = new Jedis(&quot;localhost&quot;,6379);//2. 操作jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);//3. 关闭连接jedis.close(); Jedis对于String，hash，list，set，linkedset的操作 1234567891011121314//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作//存储jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);//获取String username = jedis.get(&quot;username&quot;);System.out.println(username);//可以使用setex()方法存储可以指定过期时间的 key valuejedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对//3. 关闭连接jedis.close(); 1234567891011121314151617181920212223//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作// 存储hashjedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);// 获取hashString name = jedis.hget(&quot;user&quot;, &quot;name&quot;);System.out.println(name);// 获取hash的所有map中的数据Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;);// keysetSet&lt;String&gt; keySet = user.keySet();for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value);}//3. 关闭连接jedis.close(); 123456789101112131415161718192021222324//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作// list 存储jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存// list 范围获取List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist);// list 弹出String element1 = jedis.lpop(&quot;mylist&quot;);//cSystem.out.println(element1);String element2 = jedis.rpop(&quot;mylist&quot;);//cSystem.out.println(element2);// list 范围获取List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1);System.out.println(mylist2);//3. 关闭连接jedis.close(); 123456789101112//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作// set 存储jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);// set 获取Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);System.out.println(myset);//3. 关闭连接jedis.close(); 1234567891011121314//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作// sortedset 存储jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);// sortedset 获取Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1);System.out.println(mysortedset);//3. 关闭连接jedis.close(); Jedis连接池 1234567891011121314//0.创建一个配置对象JedisPoolConfig config = new JedisPoolConfig();config.setMaxTotal(50);config.setMaxIdle(10);//1.创建Jedis连接池对象JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379);//2.获取连接Jedis jedis = jedisPool.getResource();//3. 使用jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);//4. 关闭 归还到连接池中jedis.close(); 连接池工具类： 123456789101112131415161718192021222324252627public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); }}","link":"/2021/03/16/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"},{"title":"markdown基础语法","text":"markdown基础——博客必备推荐编辑器 typora vscode 语法1. 标题markdown的标题一共分为六个级别，从大到小依次是： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 2. 字体 加粗 1**这是加粗** 斜体 1*这是斜体* 斜体并加粗 1***这是斜体并加粗*** 删除线 1~~这是删除线~~ 3. 引用 可嵌套 123&gt; 引用1&gt;&gt; 引用2&gt;&gt;&gt; 引用3 4. 分割线需要三个或者三个以上的*或- 1********** 5. 图片1![图片下面的文字解释](图片地址) 6. 超链接1[名字](链接地址) 7. 列表 无序列表 123* 无序列表1+ 无序列表2- 无序列表3 有序列表 1231. 有序列表12. 有序列表23. 有序列表3 嵌套列表 上级列表和下级列表之间敲三个空格 1234561. 一级列表 * 二级列表1 * 二级列表22. 一级列表2 * 二级列表3 * 二级列表4 8. 表格12345a|a|a--|:--:|--:a|b|cd|e|fg|h|i a a a a b c d e f g h i 9. 代码 单行代码 1~ 单行代码 ~ 多行代码 1​~~~c++ 10. 流程图太复杂，推荐下载typora这个第三方工具，能更加方便 12345678st=&gt;start: Startop=&gt;operation: ifa&lt;1cond=&gt;condition: Yes or No?op1=&gt;operation: 重新e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op1-&gt;e","link":"/2020/03/03/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"shell基础","text":"shell就是Linux中的命令解释器，说白了，就是一个命令行的交互界面。与Linux不同Windows中就是图形的交互界面。shell还是一个强大的编程语言，因为它可以直接调用Linux的系统命令。 Shell的种类： Bourne Shell语法类：sh，ksh，Bash，psh，zsh C Shell语法类（只要同于BSD的Linux版本中）：csh，tcsh 目前的主流shell时Bash Shell 在文件/etc/shells中，可以查看Linux中默认支持的Shell类型，在命令行下输入shell的名字就可以切换shell类型 Shell脚本的执行方式 echo命令：输出指定内容 echo -e：支持反斜线的字符转换 First Script： 12#!/bin/Bashecho -e &quot;Mr Yang is the most handsome man in the world.&quot; 执行方法： 第一种：先chmod 755 hello.sh 然后./hello.sh 第二种：bash hello.sh 注意：如果一个shell脚本在Windows中编辑完成，在Linux中发现运行出错，这是因为Windows和Linux格式不同，你可以用cat -A来验证，换行符不用。解决方法就是用命令dos2unix将Windows格式转化为Linux格式 Bash的基本功能history history n：显示最近的n条命令 history -d n：删除第n条命令 history -c：清空历史命令 history -w：把缓存中的历史命令写入每个用户的缓存文件~/.bash_history 可以使用上，下箭头的方式调用历史命令，也可以使用!n，!!，!字串直接执行指定的命令 TAB键 在Linux的bash中，Tab键可以用来不全命令和文件名 命令别名&amp;常用快捷键 命令别名就是给命令定义一个别名，For Example：alias vi='vim' 直接用alias可以查看当前的所有别名，实际就是查看~/.bashrc文件的内容 命令执行的顺序： 绝对路径或相对路径的命令 别名 Bash的内部命令（内部命令就时用whereis找不到的Linux自带命令） 按找$PATH环境变量定义的目录查找顺序找到的第一的命令（外部命令） 让别名永久生效：写入~/.bashrc配置文件 unalias：删除别名 常用快捷键：Ctrl+下列的字母 c强制终止当前命令 l清屏 u剪切光标之前的内容 k剪切光标后的内容 y粘贴 r搜索历史 d退出当前终端，相当于logout] z暂停进程，放入后台 s暂停屏幕输出 q恢复屏幕输出 输入&amp;输出重定向 标准输入输出设备 键盘：/dev/stdin：标准输入：0文件描述符 显示器：/dev/sdtout：标准输出：1文件描述符 显示器：/dev/sdterr：标准错误输出：2文件描述符 输出重定向： 改变输出方向，把命令的正确或者输出结果输出到指定的文件中 正确输出和错误输出同时保存进一个文件中： 以覆盖的方式：命令 &gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;文件 以追加的方式：命令 &gt;&gt; 文件 2&gt;&amp;1 或者 命令 &amp;&gt;&gt;文件 把正确的输出保存进文件1，错误的输出保存进文件2：命令 &gt;&gt;文件1 2&gt;&gt;文件2 输入重定向：wc，后面既可以直接加文件名，也可以将输入重定向作为输入，不过后者在结果中不会显示文件名，因为它指挥识别输入的文件内容流 wc -c：统计字节数 wc -w：统计单词数 wc -l：统计行数 多命令顺序执行&amp;管道符 多命令顺序执行 分号：两个命令都会执行 &amp;&amp;：命令1正确执行，命令2才会执行 ||：命令1错误执行，命令2才会执行 dd命令：磁盘复制命令，和cp命令不同，dd可以复制特殊文件，分区甚至整个硬盘。主要的作用就是磁盘复制 dd if=输入文件 of=输出文件 bs=多少字节数作为一个块 count=块的个数 date;dd if=/dev/zero of=/root/testfile bs=1k count=100000;date用来显示磁盘复制的时间 命令 &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;：用来判断命令是否正确执行 管道符：命令1的正确输出作为命令2的操作对象 grep命令：在文件中搜索符合条件的字符串 grep -i：忽略大小写 grep -n：输出行号 grep -v：反向查找 grep –color=auto：搜索出的关键字用颜色显示 netstat -an | grep ESTABLISHED 通配符&amp;其他特殊符号 ?：匹配一个任意字符 *：匹配任何内容（0个或任意多个字符） []：匹配中括号中的任意一个 [-]：匹配中括号中范围内任意一个 [^]：逻辑非，表示匹配任意一个不是中括号内的一个字符[^0-9]表示任意一个不是数字的字符 通配符是用来匹配文件名的，通配符通常会用来删除指定范围的文件 单引号中的所有符号都是符号，双引号中的符号可能会有特殊意义 echo &quot;$SHELL&quot;和echo '$SHELL' 反引号和$()中的内容时系统命令 echo &quot;$(ls)&quot;和echo '$(ls)' #开头时注释 $用来调用变量 \\用来将特殊符号变成普通符号 Bash的变量用户自定义变量 变量名不能用数字开头 bash中，变量的默认类型都是字符串型，如果要进行数值运算，需要指定变量类型为数值型 变量用单号连接，两侧不能空格，变量名若有空格，需要引号 变量值中可以用转义符\\让特殊字符失去特殊含义 变量值可以进行叠加 环境变量名建议大写 变量分类： 用户自定义变量 环境变量 位置参数变量 预定义变量 用户自定义变量（本地变量） name=”jack” 可以叠加：newname=&quot;$name&quot;yang 或者 newname=${name}yang set：查看系统中所有的变量 unset 变量名：删除变量 环境变量 本地变量只在当前的shell中生效 环境变量会在当前和这个shell的所有子shell中生效，如果把环境变量写入相关的文件，那么这个环境变量会在所有的shell中生效 用pstree可以查看shell的父子关系 export 变量名：申明普通变量为环境变量 env：专门查看环境变量 系统环境变量： PATH：查找系统命令的变量，tab键补全和外部命令的查找都是根据$PATH来的，可以用变量叠加的方式把自己的命令加到$PATH中，PATH=&quot;$PATH&quot;:/root/test.sh PS1：定义系统提示符的变量，echo $PS1 然后用，PS1=’格式‘来自定义命令提示符 位置参数变量位置参数变量 $n：$0表示命令本身，之后就是命令行参数 $*：所有参数，把所有参数当作一个整体 $@：所有参数，把参数区别对待 $#：所有参数的个数 预定义变量 $?：返回上一次执行结果正确与否 $$：当前进程的PID $!：后台运行的最后一个进程的PID 接受键盘输入：read [选项] [变量名] -p “提示信息”： -t 秒数：限定时间 -n 字符数：限定字符数 -s：隐藏输入的信息，适用于输入密码时 Bash的运算数值运算与运算符 Linux中变量默认类型时字符串 declare [+/-][选项] 变量名 -：给变量设定类型属性，例子：-i：将变量声明为整数类型；-x：将变量声明为环境变量 +：取消变量的类型属性 -p：显示指定变量的被声明的类型 For Example:（四种计算格式，最常用的是第三种） declare -i cc=$aa+$bb cc=$(expr $aa + $bb) cc=$(($aa+$bb)) cc=$[$aa+$bb] 变量测试与内容替换 环境变量配置文件环境变量配置文件简介 source 配置文件或者. 配置文件：让修改后的配置文件直接生效 环境变量配置文件中主要就是定义对系统的操作环境生效的系统默认环境变量，比如PATH，HISTSIZE，PS1，HOSTNAME等 主要的5个配置文件 /etc/profile：针对所有用户 /etc/profile.d/*.sh：针对所有用户 ~/.bash_profile：针对单个用户 ~/.bashrc：针对单个用户 /etc/bashrc：针对所有用户 环境变量配置文件作用 环境变量配置文件调用的顺序： /etc/profile：针对所有用户 USER变量LOGNAME变量MAIL变量PATH变量HOSTNAME变量HISTNAME变量HISTSIZE变量umask调用/etc/profile.d/*.sh文件 /etc/profile.d/*.sh：针对所有用户 执行profile.d目录下所有sh文件 ~/.bash_profile：针对单个用户 追加PATH：在PATH变量后面加上了:$HOME/bin这个目录 调用~/.bashrc ~/.bashrc：针对单个用户 定义别名 /etc/bashrc：针对所有用户 定义别名和PS1 会重复调用PATH，umask啥的，但是只针对no login shell的情况，就是直接敲sh进入一个shell的情况 其他配置文件和登录信息 注销时的配置文件：~/.bash_logout 历史命令的保存文件：~/.bash_history 登录信息： 本地终端欢迎信息：/etc/issue 远程终端欢迎信息：/etc/issue.net 转义符在该文件中不能使用，只能纯文本登录 是否生效由ssh的配置文件/etc/ssh/sshd/config决定，要加入Banner /etc/issue.net，重启ssh服务生效：service sshd restart 登陆后的欢迎信息：/etc/motd（本地和远程都适用） 推荐特效字符定制网站ASCII Generator","link":"/2020/03/06/shell%E5%9F%BA%E7%A1%80/"},{"title":"shiro权限管理","text":"shiro权限管理Shiro的核心就是用来完成权限管理的。权限管理包括用户身份认证和授权两部分，简称认证授权。 只要有人参与的系统都需要进行权限管理。 什么是Shiro？Shiro是apache旗下的一个开源框架，它将软件系统的安全认认证相关的功能抽取出来，实现用户身份认证、权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。 Security Manager：包含Authenticator认证器，Authorizer授权器，Session Manager会话管理器，Cache Manager缓存管理器，Session DAO会话数据访问对象，Pluggable Realms可插拔域 cryptography：密码器（sha256，md5） subject：主体（Shiro集成的东西，宿主） Shiro中用户的身份认证 subject：主体 访问系统的用户，主体可以是用户、程序等，进行认证都称为主体。主体在进行身份认证时需要身份信息Principal和凭证信息credential Principal：身份信息 身份认证的标识，如用户名、手机号、邮箱地址等。一个主体可以有多个身份信息，但是只能有一个主身份信息。 credential：凭证信息 只有主体自己知道的安全信息，如密码、证书等 认证流程： 代码 123456789101112131415161718192021222324252627282930313233343536[users]zhangsan=123lisi=1234wangwu=12345zhaoliu=123456public class TestAuhenticator{ public static void main( String[] args ) { //创建安全管理器对象 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //给安全管理器设置realm securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;)); //SecurityUtils安全工具类 SecurityUtils.setSecurityManager(securityManager); //拿到主体subject Subject subject = SecurityUtils.getSubject(); //模拟登录，创建令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123&quot;); //用户登录 try { System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); subject.login(token); System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); } catch (UnknownAccountException e){ e.printStackTrace(); System.out.println(&quot;认证失败，用户名不存在！&quot;); } catch (IncorrectCredentialsException e){ e.printStackTrace(); System.out.println(&quot;认证失败，密码错误！&quot;); } }} 源码剖析 最终执行用户名校验，在 SimpleAccountRealm类（继承于AuthorizingRealm） doGetAuthenticationInfo() 这个方法中完成用户名校验：查看是否有这个用户 最终密码的校验，在 AuthenticatingRealm类 assertCredentialsMath() 这个方法中完成密码校验的 通过剖析源码可知，如果要把Realm放在数据库中，只需要继承AuthorizingRealm类，然后重写 doGetAuthenticationInfo() 方法即可 几个重要Realm类的继承关系图： 总结： AuthenticatingRealm中有认证方法：doGetAuthenticationInfo() AuthorizingRealm中有授权方法：doGetAuthorizationInfo() 所以，当实际上操作数据库时，我们自定义的Realm类实际上是继承AuthorizingRealm类，然后重写 doGetAuthenticationInfo() 和 doGetAuthorizationInfo() 两个方法。 自定义Realm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CustomRealm extends AuthorizingRealm { /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } /** * 认证 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String principal = (String) authenticationToken.getPrincipal(); String credentials = new String((char[]) authenticationToken.getCredentials()); System.out.println(&quot;************************************&quot;); System.out.println(principal); System.out.println(credentials); if(&quot;zhangsan&quot;.equals(principal)){ return new SimpleAuthenticationInfo(&quot;zhangsan&quot;,&quot;123&quot;,this.getName()); } return null; }}public class TestAuhenticator{ public static void main( String[] args ) { //创建安全管理器对象 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //给安全管理器设置realm// securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;)); securityManager.setRealm(new CustomRealm()); //SecurityUtils安全工具类 SecurityUtils.setSecurityManager(securityManager); //拿到主体subject Subject subject = SecurityUtils.getSubject(); //模拟登录，创建令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123&quot;); //用户登录 try { System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); subject.login(token); System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); } catch (UnknownAccountException e){ e.printStackTrace(); System.out.println(&quot;认证失败，用户名不存在！&quot;); } catch (IncorrectCredentialsException e){ e.printStackTrace(); System.out.println(&quot;认证失败，密码错误！&quot;); } }} 密码加密MD5算法 一般用来加密 &amp; 签名 MD5加密不可逆 MD5算法生成结果始终是一个16进、32位长度的字符串 一般在后端代码的业务层完成加密操作如果要进行用户名 使用MD5算法，输入只会有唯一输出。所以为了防止有人恶意穷举试探密码，我们需要给密码加盐后再MD5机密 Shiro中的MD5加密 直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class CustomRealm extends AuthorizingRealm { /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } /** * 认证 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String principal = (String) authenticationToken.getPrincipal(); String credentials = new String((char[]) authenticationToken.getCredentials()); System.out.println(&quot;************************************&quot;); System.out.println(principal); System.out.println(credentials); if(&quot;zhangsan&quot;.equals(principal)){ return new SimpleAuthenticationInfo(&quot;zhangsan&quot;,&quot;123&quot;, ByteSource.Util.bytes(&quot;abc*&quot;),this.getName()); } return null; }}public class TestAuhenticator{ public static void main( String[] args ) { //创建安全管理器对象 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //新建自定义realm对象 CustomRealm realm = new CustomRealm(); //设置realm使用hash凭证检测器 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;); credentialsMatcher.setHashIterations(1024);//设置加盐散列次数 realm.setCredentialsMatcher(credentialsMatcher); //给安全管理器设置realm// securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;)); securityManager.setRealm(realm); //SecurityUtils安全工具类 SecurityUtils.setSecurityManager(securityManager); //拿到主体subject Subject subject = SecurityUtils.getSubject(); //模拟登录，创建令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123&quot;); //用户登录 try { System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); subject.login(token); System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); } catch (UnknownAccountException e){ e.printStackTrace(); System.out.println(&quot;认证失败，用户名不存在！&quot;); } catch (IncorrectCredentialsException e){ e.printStackTrace(); System.out.println(&quot;认证失败，密码错误！&quot;); } }} Shiro中的授权操作关键对象 Who对What进行How操作 Who是访问资源的主体，What是系统的资源，How是针对资源的操作 授权流程： 授权方式： 基于角色的访问控制：Role-Based Access Control 123if(subject.hasRole(&quot;admin&quot;)){ //操作资源} 基于资源的访问控制：Resource-Based Access Control 123456789if(subject.isPermission(&quot;user:create:*&quot;)){ //操作资源}/**权限字符串：资源标识符:操作:资源实例标识符 * 用户创建权限：user:create:* * 用户实例001修改的权限：user:create:001 * 用户实例001的所有权限：user:*:001**/ Shiro中的授权实现 编程式 1234567Subject subject = SecurityUtils.getSubject();if(subject.hasRole(&quot;admin&quot;)){ //有权限}else{ //无权限} 注解式 1234@RequireRoles(&quot;admin&quot;)public void hello(){ //有权限} JSP标签式 1234&lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!--有权限--&gt;&lt;/shiro:hasRole&gt;&lt;!--注意：Thymeleaf中使用shiro需要额外集成--&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class CustomRealm extends AuthorizingRealm { /** * 授权 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(&quot;==================Authorization===================&quot;); String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal(); System.out.println(primaryPrincipal); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.addRole(&quot;admin&quot;); simpleAuthorizationInfo.addRole(&quot;user&quot;); simpleAuthorizationInfo.addStringPermission(&quot;admin:create:*&quot;); simpleAuthorizationInfo.addStringPermission(&quot;user:update:01&quot;); return simpleAuthorizationInfo; } /** * 认证 * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { System.out.println(&quot;==================Authentication===================&quot;); String principal = (String) authenticationToken.getPrincipal(); String credentials = new String((char[]) authenticationToken.getCredentials()); System.out.println(&quot;************************************&quot;); System.out.println(principal); System.out.println(credentials); if(&quot;zhangsan&quot;.equals(principal)){ return new SimpleAuthenticationInfo(principal,&quot;44610a20602341c591e0c9b5ecf19ff3&quot;, ByteSource.Util.bytes(&quot;abc*&quot;),this.getName()); } return null; }}public class TestAuthenticator{ public static void main( String[] args ) { //创建安全管理器对象 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //新建自定义realm对象 CustomRealm realm = new CustomRealm(); //设置realm使用hash凭证检测器 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;); credentialsMatcher.setHashIterations(1024);//设置加盐散列次数 realm.setCredentialsMatcher(credentialsMatcher); //给安全管理器设置realm// securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;)); securityManager.setRealm(realm); //SecurityUtils安全工具类 SecurityUtils.setSecurityManager(securityManager); //拿到主体subject Subject subject = SecurityUtils.getSubject(); //模拟登录，创建令牌 UsernamePasswordToken token = new UsernamePasswordToken(&quot;zhangsan&quot;, &quot;123&quot;); //用户登录 try { System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); subject.login(token); System.out.println(&quot;Authentication Status:&quot;+subject.isAuthenticated()); } catch (UnknownAccountException e){ e.printStackTrace(); System.out.println(&quot;认证失败，用户名不存在！&quot;); } catch (IncorrectCredentialsException e){ e.printStackTrace(); System.out.println(&quot;认证失败，密码错误！&quot;); } //进行授权操作 if(subject.isAuthenticated()){ System.out.println(subject.hasRole(&quot;user&quot;)); System.out.println(subject.hasAllRoles(Arrays.asList(&quot;admin&quot;,&quot;user&quot;))); System.out.println(subject.isPermitted(&quot;admin:create:*&quot;)); System.out.println(subject.isPermitted(&quot;user:update:02&quot;)); } }} 权限模型 Shiro和SSM的整合整合思路","link":"/2021/08/12/shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"},{"title":"shell编程","text":"基础正则表达式 正则表达式和通配符区别： 通配符：在系统中搜索匹配文件名，是完全匹配。支持命令ls，find，cp，他们不认识正则表达式 正则表达式：用来在文件中匹配符合条件的字符串，是包含匹配。支持命令：grep，awk，sed *：前一个字符匹配0次或者任意多次 .：匹配任意一个字符（换行符除外） ^：匹配以后面字符作为行首的行 $：匹配以后面字符作为行尾的行 ^$：匹配空白行 []：匹配中括号中的指定的任意一个字符 [^]：匹配除中括号中的字符外的任意一个字符 \\：转义符 \\{n\\}：表示其前面的字符恰好出现n次 \\{n,\\}：表示其前面的字符出现不少于n次 \\{n,m\\}：表示其前面的字符至少出现n次，最多出现m次 字符截取命令 grep命令：提取符合条件的行-c：只输出匹配行的计数 -i：不区分大小写 -v：显示不包含匹配文本的所有行 cut命令：提取符合条件的列-f 列号：提取第几列 -d 分隔符：按照指定分隔符分割列，默认是制表符tab cut /etc/passwd | grep /bin/bash | grep -v root | cut -d &quot;:&quot; -f 1：用来提取出普通用户名 df -h | grep &quot;sda5&quot; | cut -f 5：用来提取硬盘的使用率 printf命令：按找类型输出格式输出内容%ns：输出字符串 %ni：输出整数 %m.nf：输出浮点数 \\n，\\r，\\t：换行，回车，tab键 printf '%s %s %s' 1 2 3 4 5 6：最后输出结果按照%s %s %s格式分为两组 printf命令不能用管道符，只能printf %s $(cat XXX.txt) print命令：和printf语法一样，只是会默认换行，print不是系统命令，只能在awk中执行 awk命令：截取列很强大的命令，可以说是一门编程语言 格式：awk ’条件1{动作1} 条件2{动作2} 条件3{动作3}‘ 文件名 awk ‘{printf $2 “\\t” $6 “\\n”}’ XXX.txt df -h | awk '{printf $1 &quot;\\t&quot; $5 &quot;\\t&quot; $6}'：可以处理空格，弥补了cut的不足，但是awk很多命令很复杂 df -h | grep sda5 | awk ’{print $5}‘ | cut -d &quot;% -f 1&quot; BEGIN：在所有命令执行之前先执行BEGIN后面的语句块,awk默认是先读入一行再执行后面的语句 END：在所有语句处理完后执行 FS：指定分隔符，awk ’{FS=&quot;:&quot;}‘ awk还支持条件判断：awk ’$6&gt;=87 {printf $2 &quot;\\n&quot;}‘： sed命令：数据的流编辑器vim只能修改文件，sed还可以直接修改管道符传过来的流 格式：sed [选项] ‘[动作]’ 文件名 选项： -n：sed默认把所有数据都输出到屏幕，加上-n表示只把经过sed修改过后的行输出到屏幕 -e：允许对输入数据用多条sed命令编辑 -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出 动作： a：行后追加（多行时，行尾要加\\）sed ‘2a hello’ XXX.txt c：替换（多行时，行尾要加\\）sed ‘4c no the line’ XXX.txt i：行前插入（多行时，行尾要加\\）sed ‘2i hello \\ world’ XXX.txt d：删除：sed ‘2,4d’ XXX.txt p：打印：sed ‘2p’ XXX.txt s：字串替换：sed ‘4s old/new/g’ XXX.txt 字符处理命令 sort：排序 -r：反向排序 -t -k：指定排序标准：-t “:” -k 3,4：以:为分隔符，按找第3到第4列来排序 -n：按照数值大小来排 wc：统计字符 -l：行数 -c：单词数 -w：字符数 条件判断 按照文件类型判断： -e：判断文件是否存在 -b：判断文件是否存在，并且是否是块设备文件 -c：判断文件是否存在，并且是否是字符设备文件 -d：判断文件是否存在，并且是否是目录文件 -f：判断文件是否存在，并且是否是普通文件 -L：判断文件是否存在，并且是否是链接文件 -p：判断文件是否存在，并且是否是管道文件 -S：判断文件是否存在，并且是否是套接字文件 -s：判断文件是否存在，并且是否是非空 两种判断格式： test -e XXX.txt [ -e XXX.txt ]：注意首尾各有一个空格 FOR EXAMPLE：[-d /root] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;：如果是目录yes，否则no 按照文件权限进行判断 -r：判断文件是否存在，并且是否该文件有读权限，u，g，o中任意一个有都为真 -w：判断文件是否存在，并且是否该文件有写权限，u，g，o中任意一个有都为真 -x：判断文件是否存在，并且是否该文件有执行权限，u，g，o中任意一个有都为真 -u：判断文件是否存在，并且是否该文件有SUID权限，u，g，o中任意一个有都为真 -g：判断文件是否存在，并且是否该文件有SGID权限，u，g，o中任意一个有都为真 -k：判断文件是否存在，并且是否该文件有SBIT权限，u，g，o中任意一个有都为真 两个文件之间进行比较 文件1 -nt 文件2：判断文件1的修改时间是否比文件2新 文件1 -ot 文件2：判断文件1的修改时间是否比文件2旧 文件1 -ef 文件2：判断文件1的inode号是否和文件2一致，可以用来判断两个文件是不是互为硬链接 两个整数之间比较 整数1 -eq 整数2：相等 整数1 -ne 整数2：不等 整数1 -gt 整数2：大于 整数1 -lt 整数2：小于 整数1 -ge 整数2：大于等于 整数1 -le 整数2：小于等于 字符串的判断 -z：判断是否为空 -n：判断是否为非空 字串1 == 字串2：判断是否相等 字串1 !=字串2：判断是否不等 多重条件判断 判断1 -a 判断2：逻辑与 判断1 -o 判断2：逻辑或 !判断：逻辑非 流程判断 if语句： 和[-d /root] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;作用一样，但更直观 单分支if FOR EXAMPLE: 123456#!/bin/bashrate=$(df -h | grep /dev/sda5 | awk '{print $5}' | cut -d &quot;%&quot; -f 1)if [ $rate -ge 80 ] then echo &quot;Warning /dev/sda5 is coming full !!!&quot;fi 多分支判断： case语句： for循环： 第一种语法： FOR EXAMPLE： 1234for i in 1 2 3 4 5 6 do echo $i done 第二种语法： FOR EXAMPLE： 1234567!/bin/bashs=0for ((i=1;i&lt;=100;i=i+1)) do s=$(($s+$i)) doneecho &quot;The sum of 1+2+...+100 is $s&quot; while循环和until编程： while循环： FOR EXAMPLE： 123456789!/bin/bashi=1s=0while [ $i -le 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho &quot;The sum is: $s&quot; until循环： FOR EXAMPLE： 123456789!/bin/bashi=1s=0until [ $i -gt 100 ] do s=$(( $s+$i )) i=$(( $i+1 )) doneecho &quot;The sum is: $s&quot;","link":"/2020/03/06/shell%E7%BC%96%E7%A8%8B/"},{"title":"web前端-elementUI","text":"利用vue-cli搭建vue的webpack项目1234567891011121314151617181920# 初始化webpack项目vue init webpack vue01cd vue01# 安装依赖cnpm install vue-router --save-devcnpm install element-ui --savecnpm install axios vue-axios --savecnpm install# main.js中引入import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import axios from 'axios'import VueAxios from 'vue-axios'import VueRouter from 'vue-router'Vue.use(ElementUI);Vue.use(VueAxios,axios);Vue.use(VueRouter);","link":"/2021/01/14/web%E5%89%8D%E7%AB%AF-elementUI/"},{"title":"一点想法-2021-01-01","text":"这学期期末，连续做了三个小项目，最后一个实习最后，叫写个3000字的总结，没啥写的。就扯了了点自己学java这么久以来的感悟。想想也放在博客上吧，随便谈谈。 我之前做过的所有项目的前台静态页面都是用纯css，html，javascript或者jquery自己写的，这样可以锻炼自己对前端三件套的掌握程度。但是这次我们采用了一个后台管理的前端模板adminlte，类似的模板有很多，选择它的原因是有很详细的中文说明。对于大多数的后台管理系统的前台来说，它提供的已足够充足，只需要根据需要选择相应的控件就行了，如果整个项目都是后端程序员开发，大大简化了后端程序员的负担。 对于SSM框架来说，我还是很有感触，我的javaweb之路是一步一步学来的，对javaweb的发展史还是有一定的了解。从最初的servelet，不管页面要显示什么内容，都需要servlet中打印语句到浏览器页面显示，对于servlet中冗长的out语句，简直是噩梦。到后来，借鉴asp的形式，诞生了jsp，这种技术可以在html语句中直接写java代码，如果说servlet是在java代码中写标签，jsp就是在标签中写java代码，这个时候，要完成一个简单的页面，只需要一个几个jsp页面就可以实现了，看似简单，但是随着互联网的迅速发展，当web项目越做越大时，对于庞大代码的首要任务是如何去维护它，如何去践行高内聚低耦合等程序设计原则。然后就是出现了javabean类，将jsp中的部分java代码剥离出来放到专门的java类中达到解耦的目的，此时可以看作MVC的雏形，jsp是表示层，控制层，javabean是模型层，这就是model1开发模式。之后，又将jsp中的控制层单独剥离出来，让servlet来充当，这样，就是大名鼎鼎的model2开发模式即MVC模式的诞生。再然后，就是各种后端java框架的出现了，从Struts2+Spring+Hibernate的SSH，到SpringMVC+Spring+Mybatis的SSM，实际上还是MVC模式，只不过更加人性化，简化了原始的JSP+Servlet+JavaBean的开发模式。需要注意的是，这里的对应关系是JSP是表示层，Servlet是控制层，JavaBean是模型层。但是对于SSH和SSM框架来说，每一个框架对应的是三层模型，分别是Controller层，Service层，Dao层。控制层还是那个控制层，Service层和Dao层都属于模型层。所以，完整的技术栈应该是：JSP+SpringMVC+Spring+Mybatis。这里的逻辑关系很容易混淆，特别是对于新手，很容易把MVC和三层架构搞混。这里理解清晰对与整个后端知识的学习可以说是很重要的。理解一项技术的历史发展我认为对于一个技术学习者来说是很重要的，一个增加专业素养，二是增加学习兴趣，三是能知道自己究竟在学什么，能更加清晰地认识到这项技术在历史中地位，对自己对于新技术的判定页会有很大帮助。 当然，我目前只学到了SSM框架这个地方，SpringBoot和实现分布式部署的SpringCloud作为javaweb系统技术的最前沿，也是目前各大互联网公司的必备技术。这些我都没写开始学习。我认为java发展至今，每个时间都会产生各种新的技术，如果我们一味地追求新技术是没有任何意义的。这里我并不是说新技术不好，我的意思是无论多么高深的技术，都是基于最基础的java语法，java基本特性，例如：发射，注解，多线程机制。现在我发现很多程序员对于这些基础知识并没有弄清楚，但是对新技术趋之若鹜。例如就拿SpringBoot来说，它的很多技术点都是基于SSM的，对于SSM来说，他就是原始MVC模型的进一步简化，原理几乎一致。对于MVC，又可以追述到JSP和Servlet的最原始时代，这又回到了我上面讲的了解一项技术的历史的重要性问题上。当你了解了他的历史，你就会看透这项技术的实质是什么，只要理解技术的核心原理，不管这项技术怎么变你都会认识它。所以我的建议就是对于我们这种初出茅庐的新手来说，最重要的事应该是把个更多的时间花在夯实基础上，而不是追逐新技术上。 记得刚进大一时，那时对于编程来说，认识就是C语言的控制台小黑窗。大二大三也是诸如数据结构，操作系统，计算机组成原理，计算机网络，面向对象设计，设计模式等理论课，我很不明白为什么学校教的都是这些枯燥乏味的理论课呢，稍微讲一些实践课还都是些老掉牙的东西呢，为什么不直接教最新的东西呢，当时的我确实很是困惑。在大三开始，我逐渐开始对javaweb有了兴趣，从java基础开始到javaEE，到SSH，经过这么长时间学习体会，一直到现在的SSM，我终于才有了认识：一个牢固的地基太重要了。所以，从大三开始，我开始补自己欠下的基础债，学的过程中也很是感叹。其实反过来想想：学习一个东西可以先掌握其实践方法，认识到基础知识的重要，再回来学习理论其实也是不错的方法。有交流的学弟学妹，我也会给他们提醒到这一点，不要忽视大学中看似乏味的理论课，这些东西才是日后决定你技术高度的标尺。 接下来一段时间主要复习javase基础，重新学习设计模式，数据结构，操作系统，计算机组成原理，SSM框架深层次理解包括源码理解。这些东西每一个都不是善茬，任重而道远。但话说回来，程序员的一生就是不断学习的一生，对知识的渴望就是一种软实力。对于未来职业方向，暂定方向是java后端开发，我个人对Linux和计算机网络也挺感兴趣，未来也可以有多改变，当然这一切都不是空口说说就行。其实写博客也是一个很好的习惯，一来可以起到类似于日记记录生活的作用，二来可以提交自己学习的欲望，同时加深自己对于知识的理解和记忆程度。一定要在之后的工作中养成写博客的习惯。本次实习我认为很成功，虽然遇到了疫情，但是丝毫不影响，继续努力吧！","link":"/2021/01/01/%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95-2021-01-01/"},{"title":"内网穿透浅析","text":"首先需要明确的是：内网穿透只是目的，不是特指哪一种技术，可以有多种方式来实现通过公网对局域网中的主机的访问。 内网穿透的技术：目前了解的大致分为以下两种 基于client和server，利用公网的一个中间服务器实现流量转发 利用UDP打洞来实现P2P 当然，自己能申请公网ip更好。直接做一个端口映射（常见的端口转发有以下三种模式：手动设计端口转发规则，DMZ，UPNP）利用DDNS动态绑定域名即可。 Tips:其实，我觉得如果从实现目的这个层次去说，VPN的正向代理同样也实现了访问企业/学校内部局域网的目的，所以我觉得这也叫实现了内网穿透（不知道准不准确） 基于C/S架构流量转发实现（传统穿透） 在谈这种方式之前，需要先了解以下计算机网络中的Proxy，既代理。分为正向代理和反向代理 正向代理： 隐藏了真实的请求客户端。服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，最典型的例子就是科学上网工具（访问谷歌被墙，于是在国外搭建一台代理服务器，让代理帮我去请求，代理把请求放回的数据再返回给我。此时，Proxy和Client同属一个LAN，对server透明） 反向代理： 反向代理隐藏里真实的服务端，反向代理服务器会帮我们把请求转发到真实的服务器那里去。最典型的就是Nginx这个性能强大的反向代理服务器（当我们访问百度时，百度在全国分布了上万台服务器，你的每次请求具体是哪台服务器处理你的请求你不用知道，只需要Nginx这个反向代理服务器知道就行了，这实际就是负载均衡的实现原理。此时，Proxy和Server同属于一个LAN，对Client透明） 正向代理： 典型例子就是VPN和shadowsocks等代理上网工具，通过安装工具来让本地机器和代理服务器处于同一局域网反向代理： 典型例子就是nginx和内网穿透，通过在服务端机器安装工具来让服务端机器和代理服务器处于同一局域网，nginx和内网穿透中的反向代理服务器的区别就是nginx可以根据算法策略自动选择服务终端，而内网穿透反向代理服务器直接通过工具和服务终端机做了ip:端口映射绑定 目前最常用的两个通过公网服务器转发数据实现内网穿透的工具是：frp，ngrok，nat123。远程桌面控制软件TeamViewer也是这样的原理。 具体流程如下：我们需要一个有公网ip的反向代理服务器C，由C代理本地的A主机（但在这个过程中，代理服务器C和本地A没有在一个网段，因此当公网B向代理服务器发送请求时，代理服务器无法连接到处于内网中的主机A。所以就需要上面提到的工具了，需要安装相应的服务或者客户端软件向Proxy主动发出请求并建立连接）。然后从本地A向C握手，建立稳定连接，同时在Proxy上将A的端口映射到公网IP上。之后，一个公网设备B向C发送请求，C通过刚才建立的稳定信道将请求转发给A。A收到请求后将响应发给C，C再将响应返给B。至此，穿透达成。 缺陷就是Proxy最为数据转发的唯一跳板，需要消耗服务器带宽和流量，内网穿透过程中的带宽上行取决于中间反向代理服务器。 利用UDP打洞实现P2P的访问（点对点穿透） 简单说就是：用一个公网服务器当介绍人，直接连接两个不同局域网中的主机，来实现通讯，建立连接后把公网服务器关了，两个不同局域网中的机器依旧可以通信。 要弄清楚UDP打洞（NAT打洞）原理，必须先搞清楚NAT的4种类型 先来看个例子：公网上有两个server，ip和端口分别如图。内网中的NAT网关的ip是3.3.3.3，NAT内部需要穿透的电脑的ip如图。此时，192.168.0.2电脑A，已经和NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了连接 以下四种方式从上至下的要求愈发严格： 完全锥形NAT如上，当A和server1的一条通信连接建立时，其他的所有server，例如server2也可以通过路由上的3.3.3.3:200来访问电脑A ip限制型锥形NAT当A和server1的一条通信连接建立时，其他的server，例如server2不能通过路由上的3.3.3.3:200来访问电脑A，只能是此时正在正在连接当中的server1的ip才能访问电脑A，但是堆server1中的不同端口号并不限制 端口限制型锥形NAT当A和server1的一条通信连接建立时，其他的server，例如server2不能通过路由上的3.3.3.3:200来访问电脑A，只能是此时正在正在连接当中的server1的ip+端口才能访问电脑A 对称NAT当A和server1的一条通信连接建立时，在完全满足端口映射锥形NAT的基础上，如果此时电脑A还需要建立和其他server建立连接，比如server2，那么此时不能重复利用3.3.3.3:200，只能重新在路由器上开通一个端口号。 UDP打洞中不同NAT的组合方式上述介绍四种NAT的类型对其进行两两组合，总共有10中不同的组合方式，不同的组合方式在进行穿透时的方法也不同，有两种情况的组合无法穿透（也有一些骚操作可以让这两种的组合实现内网穿透，但是由于NAT设计之初就没有考虑到这两种的组合情况，所以理论上他们也是不能穿透的） 两种内网穿透方式的比较 打洞：Zerotier，Frp（初级），smargate 转发：花生壳，ngrok，Frp","link":"/2020/12/28/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%B5%85%E6%9E%90/"},{"title":"win10壁纸bingtoday","text":"注册表指定壁纸路径 WIN+R打开运行对话框：输入regedit打开注册表 到达路径：计算机\\HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System下，一个叫Wallpaper的名称就是壁纸的指定路径，更换成你希望的壁纸路径：例如：C:\\wallpaper\\wallpaper.jpg 每日bing壁纸下载 通过java代码实现下载每日bing壁纸到刚才注册表指定的壁纸路径 12345678910111213141516171819202122232425public class DownloadMain { public static void main(String[] args) throws IOException { final String imgResource = getImgResource(); final URL url = new URL(imgResource); final URLConnection urlConnection = url.openConnection(); final BufferedInputStream bis = new BufferedInputStream(urlConnection.getInputStream()); final BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;C:\\\\wallpaper\\\\wallpaper.jpg&quot;)); final byte[] bytes = new byte[1024]; int len = 0; while ((len=bis.read(bytes)) != -1){ bos.write(bytes,0,len); } bis.close(); bos.close(); } public static String getImgResource() throws IOException{ String url = &quot;http://cn.bing.com/?mkt=zh-CN&quot;; final Document document = Jsoup.parse(new URL(url), 30000); final Element vs_cont = document.getElementById(&quot;vs_cont&quot;); final Elements downloadLink = vs_cont.getElementsByClass(&quot;downloadLink&quot;); final String[] split = downloadLink.toString().split(&quot;\\&quot;&quot;); return &quot;http://cn.bing.com/&quot; + split[1]; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;bingDownload&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;transformers&gt; &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt; &lt;!-- 在这里指定入口类 --&gt; &lt;mainClass&gt;DownloadMain&lt;/mainClass&gt; &lt;/transformer&gt; &lt;/transformers&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 打包java为jar包，只要电脑安装的jre环境，双击就能下载壁纸到指定路径","link":"/2022/03/30/win10%E5%A3%81%E7%BA%B8bingtoday/"},{"title":"到底啥是VPN","text":"什么是VPN？ 对于出差的员工，公司的IT部门会在他们的电脑上装上VPN软件。这个VPN软件可以连接到一台由公司内部控制的电脑服务器上，叫“VPN服务器”（VPN Server）。出差员工连上VPN以后，他上网时就不再直接访问公共互联网，而是通过VPN服务器间接访问。本质上是正向代理。 VPN还有一个重要特点：VPN用户和VPN服务器之间的通讯是加密的，这样就不会被黑客盗取内容。这就好比两个人打电话，是有可能被第三方监听的，但是如果打电话的两个人使用的是别人都听不懂的特殊语言（这就是加密），那么即使有人监听，打电话的内容也不会被泄露。 VPN有什么用： VPN可以提高上网的安全性 因为使用VPN时所用的网络访问都是加密进行的，所以使用VPN上网，安全性就更高，黑客很难截取用户的重要信息。如果你使用公共WIFI上网（例如在咖啡馆上网）时，需要做安全性强的操作（比如使用网上银行或网上投资账户），那么建议你连上VPN，因为这样会大大提高安全性。 VPN可以隐藏上网者的身份 因为VPN用户访问任何网站都是通过VPN服务器间接访问的，所以被访问的网站看到的访问者是VPN服务器，而不是VPN用户本人的电脑，这样VPN用户就能对要访问的网站隐藏自己的真正身份。 VPN可以突破网站的地域限制 很多网站都有地域限制，比如视频网站Netflix在不同国家提供不同的内容，美国用户访问Netflix时看到的是美国版的内容，香港用户看到的是香港版的内容。网站的这种功能是通过查看访问者的IP地址属于哪个国家来实现的。而VPN可以用来突破这种IP限制。比如：香港的用户想要看到美国版Netflix的内容，可以先连接到一台位于美国的VPN服务器。这样Netflix网站就会以为访问着来自美国，而提供美国版的内容。同理，使用日本VPN可以以日本用户的身份访问日本网站和服务，使用香港VPN可以以香港用户的身份上网。基于同样的道理，海外华人可以通过VPN翻墙回国，观看仅限国内用户观看的视频内容。另外，VPN还可以用来在网上购物时省钱，因为一些酒店和机票网站对不同国家有不同的价格，通过VPN换成不同国家的IP往往可以省钱。 突破网络封锁（翻墙） 为什么VPN可以用来翻墙呢？先让我们看看网站是如何被墙的。当用户在中国大陆直接访问被封网站（比如Google）时，网络监控发现你要连接到被墙网站，直接就把你拦截了。而如果你通过VPN访问这个网站，我们前面提到，VPN用户访问任何网站都是通过VPN服务器代为访问的，用户连接的其实是VPN服务器，而不是Google（只是告诉VPN服务器你要访问Google），然后VPN服务器去连接Google，把Google的内容回传给你。这样的话，网络监控看到的是你在连接VPN服务器，而不是在连接Google，同时因为VPN传输是加密的，网络监控也无法破解你和VPN服务器之间在传输什么信息，所以，（除非VPN服务器也在被墙网址之内）网络监控就不会切断你的连接，于是你就成功翻墙了。 一点感悟：离开学校会发现没法访问校园网了，我原来认为是校园局域网，然后在家里用VPN通过内网穿透来访问，但是在家里能通过学校的VPN服务器连接校园网进行访问。所以我现在觉得校园网只是出于安全考虑根据你的网络ip地址设置的防火墙。只能通过校园网或者学校的VPN专用服务器进行VPN正向代理访问。不过从目的来看好像确实穿透了内网 关于校园网VPN，我的最新理解：在用户端使用VPN功能的软件，配置为隧道开通器，通过ISP接入Internet并访问校园网内的VPN服务器。到这一步和一般的正向代理都没有差别，让外部机器和VPN正向代理服务器处于了同一局域网。不同的地方在于，这个VPN服务器本身就位于服务终端的内部局域网中，所以此时所有主机（外部访问终端，内部服务终端，VPN服务器）都在一个虚拟的大局域网中了。","link":"/2020/12/29/%E5%88%B0%E5%BA%95%E5%95%A5%E6%98%AFVPN/"},{"title":"初试刷机","text":"解BL锁 首先需要确保MIUI处于开发版最新版 连续点击全部参数里的MIUI版本将设备处于开发者模式 退出系统中所有登录的账号（小米账号，谷歌账号……） 关机后打开fastboot模式（同时按电源键&amp;音量下键） 向小米官方申请解锁并在电脑上下载miflash解锁工具 电脑usb连接手机，点击解锁，会显示成功。 备份数据 在刷新的rec和新系统之前如果需要备份原系统的数据，可以用小米助手（MiAssistant）来备份数据，官方可下载。 刷入第三方REC 可选的第三方REC很多（TWRP，橙狐，奇兔） 根据选择的REC不同，刷入REC的方式也不同，这里以TWRP为例： 在各种论坛自己找到自己设备（小米平板4）的TWRP刷入工具包，按照规则傻瓜式操作即可操作成功，成功后系统自动启动进入REC 刷入系统&amp;面具&amp;谷歌套件 可以选择各种适配自己设备的系统，以魔趣为例： 登录魔趣官网https://download.mokeedev.com/，根据设备型号选择下载系统包（稳定版&amp;每夜版） 在论坛寻找下载magisk面具zip包 在https://opengapps.org/下载谷歌套件zip包 之前的三个包可以在电脑下载 设备关机并进入REC（同时按电源键&amp;音量上键） 清理data分区和四清，重启进入REC 从电脑拷入三个zip包进入设备根目录 点击安装，选择系统zip包刷入 继续刷入magisk包，成功后重启进入系统 此时基本就可以了，系统基本配置好后就可以关机再次进入REC，刷入谷歌套件zip包，重启即可 注意： 谷歌套件如果只需要谷歌服务的话，推荐用nano版本的，其他版本会有其他不必要的东西 经常出现这种情况：再次进入REC时会让输入data密码确认，否则访问不了data目录，此时可能有两种情况： 系统设置了开机密码，此密码就是开机密码 设备没开机密码，但是还是要输入data密码，此时就没辙了，除了清理data毫无他法。这里的问题就是TWRP包本身的问题，这里最好就多换几个TWRP包试一试，有些包自带data解密的，或者寻找一个data解密文件来解密 推荐魔趣稳定版本，每夜版每天都会更新，非常不稳定，可能会出现各种各样的问题。","link":"/2020/12/05/%E5%88%9D%E8%AF%95%E5%88%B7%E6%9C%BA/"},{"title":"实体机安装Arch","text":"准备： 机器：华硕飞行堡垒fx-60vm 第一系统：win10 Arch镜像 https://archlinux.org/download/ 镜像考录工具：Rufus U盘 安装系统联网123456789101112131415161718192021222324#安装过程中调整字体setfont ter-132nsetfont ter-122b#查看网卡ip link#有线连接dhcpcd#无线连接#查看wifi是否关闭，开启wifirfkill listrfkill unblock wifi#wifi联网iwctl[iwd] device list[iwd] station wlan0 scan[iwd] station wlan0 get-networks[iwd] station wlan0 connect SSID#分配ipdhcpcd#测试网络连接ping archlinux.org 更新系统时间1234#更新系统时间timedatectl set-ntp true#检查服务状态timedatectl status 系统分区123456789101112131415161718192021222324#查看当前分区lsblkfdisk -l#新建分区cfdisk /dev/sdX (X替换成相应的硬盘字母，一般是a或b，默认gpt即可)#分区建议# /boot/efi:和win10共用 512M# swap:固态硬盘1G# /:固态硬盘剩下所有#格式化分区mkfs.fat -F32 /dev/sdaX #/boot/efimkfs.ext4 /dev/sda6 #/和/homemkfs.ext4 /dev/sdb2mkswap /dev/sda5 #交换分区swapon /dev/sda5#挂载mount /dev/sda6 /mntmkdir /mnt/boot/efimount /dev/sda2 /mnt/boot/efimkdir /mnt/homemount /dev/sdb2 /mnt/home 安装arch核心123456789101112# 可以直接使用reflector命令检索排序镜像并保存到mirrorlist里reflector --country China --age 24 --sort rate --protocol https --save /etc/pacman.d/mirrorlist# 或者手动更改vim /etc/pacman.d/mirrorlist#找到中国镜像移到最上面或者添加Server = http://mirrors.ustc.edu.cn/archlinux/$repo/os/$archServer = http://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch#更新pacman -Syy#pacstrap脚本安装arch基础pacstrap /mnt base base-devel linux linux-firmware linux-headers dhcpcd vim networkmanager intel-ucode git openssh bash-completion 生成fstab挂载文件12genfstab -U /mnt &gt;&gt; /mnt/etc/fstabcat /mnt/etc/fstab 进入ch-root12345678910111213141516171819202122232425262728293031323334353637arch-chroot /mntpacman -Syy#设置时间ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc#设置语言vim /etc/locale.genen_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_TW.UTF-8 UTF-8locale-gen#设置默认语言vim /etc/locale.confLANG=en_US.UTF-8#本地化设置vim /etc/hostnamemyArchvim /etc/hosts127.0.0.1 localhost::1 localhost127.0.1.1 myArch.localdomain myArch#自启动设置systemctl enable NetworkManager sshd#设置root密码passwd#新增普通用户useradd -m -G wheel -s /bin/bash jack1024passwd jack1024#给用户sudo权利pacman -S sudoln -s /usr/bin/vim /usr/bin/vivisudo%wheel ALL=(ALL) ALL 安装引导12345678910111213pacman -S os-prober ntfs-3g grub efibootmgr efivargrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB#生成并查看引导配置grub-mkconfig -o /boot/grub/grub.cfgcat /boot/grub/grub.cfg#退出chrootexit#重启umount -R /mnt/boot/efiumount -R /mntreboot 新系统完善和配置网络配置12345678910111213141516171819202122232425#调节字体(在该目录下选择一个字体)setfont /usr/share/kbd/consolefonts/sun12x22.psfu.gz#联网nmcli device wifi listnmcli device wifi connect yang password XXXXX#查看网络配置cat/etc/pacman.d/mirrorlist#网络配置vim /etc/pacman.conf#打开Color和TotalDownload注释#文档末尾添加[multilib]Include = /etc/pacman.d/mirrorlist[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch#更新所有软件sudo pacman -Syyu#安装 archlinuxcn-keyring 包以导入 GPG keysudo pacman -S archlinuxcn-keyring#安装aur管理工具yaysudo pacman -S yay 12345#如果安装keyring出错sudo rm -rf /etc/pacman.d/gnupgsudo pacman-key --initsudo pacman-key --populate archlinuxsudo pacman -S archlinuxcn-keyring 图形化界面1234567891011121314151617181920#窗口系统服务xorgsudo pacman -S xorg xorg-server#kdesudo pacman -S plasma#不建议kde-applications，太多，选几个就行了sudo pacman -S ark dolphin dolphin-plugins juk kdeconnect kdenlive konsole #登录界面sddmsudo pacman -S sddm sddm-kcmsystemctl enable sddm#sddm中文界面sudo SYSTEMD_EDITOR=vim systemctl edit sddm[Service]Environment=LANG=zh_CN.UTF-8#xfcesudo pacman -S xfce4 xfce4-goodies#lightdmsudo pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settingssudo systemctl enable lightdm 字体1234sudo pacman -S ttf-dejavu wqy-bitmapfont wqy-microhei wqy-zenhei noto-fonts noto-fonts-emoji#默认语言vim .xprofileexport LC_ALL=zh_CN.UTF-8 声音&amp;显卡&amp;蓝牙12345sudo pacman -S alsa-utils pulseaudio pulseaudio-alsa//sudo pacman -S nvidia nvidia-utils lib32-nvidia-utils nvidia-settingssudo pacman -S xf86-video-intelsudo pacmna -S bluez bluez-utils bluedevil pulseaudio-bluetoothsystemctl enable bluetooth 电源管理12345678910# tlp提供优秀的linux高级电源管理功能，配置文件位于/etc/default/tlpsudo pacman -S tlp tlp-rdw# 在您使用(tlp-rdw)之前需要使用NetworkManager并且需要启用 NetworkManager-dispatcher.servicesudo systemctl enable NetworkManager-dispatcher.servicesudo systemctl enable tlp.service tlp-sleep.service# 屏蔽systemd服务systemd-rfkill.service和systemd-rfkill.socket来防止冲突sudo systemctl mask systemd-rfkill.service systemd-rfkill.socketsudo tlp start# 只对thinkpad有用的功能,充电阈值控制以及电池校准sudo pacman -S tp_smapi acpi_call 输入法123456789101112131415yay -S fcitx5-im fcitx5-rime fcitx5-chinese-addons fcitx5-pinyin-zhwiki fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki-rime fcitx5-pinyin-moegirl-rime#开机自启cd ~/.configmkdir autostartcd autostartsudo mv /usr/share/applications/fcitx5.desktop ./#右下脚输入法右键配置，删掉拼音加入中州韵#环境变量vim ~/.pam_environmentGTK_IM_MODULE DEFAULT=fcitxQT_IM_MODULE DEFAULT=fcitxXMODIFIERS DEFAULT=\\@im=fcitxSDL_IM_MODULE DEFAULT=fcitx 需要注意的点1234#新版本的arch在grub中默认没有windows的探测，需要在/etc/default/grub中加上GRUB_DISABLE_OS_PROBER=false#然后重新grub-mkconfiggrub-mkconfig -o /boot/grub/grub.cfg 12345678910111213141516#安装mysqlpacman -S mysql57#初始化数据库sudo mysqld --initialize --user=mysql#启动mysqlsudo systemctl start mysqld#登录mysqlmysql -uroot -p#修改密码mysql&gt; use mysqlmysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'your-password';#查看mysql默认配置mysqld --verbose --help#默认配置文件:/etc/mysql/my.cnf#默认数据库文件夹:/var/lib/mysql/ 123#安装v2rayayay -S v2raya v2raysystemctl enable --now v2raya 12#安装libreofficesudo pacman -S libreoffice-fresh libreoffice-fresh-zh-cn 1234567891011121314151617181920212223242526272829303132333435# 安装nvmyay -S nvmnvm --versionnvm ls-remotenvm install v12.18.0nvm lsnpm install cnpm -g --registry=https://registry.npm.taobao.org# 安装zshyay -S zshchsh -s /bin/zshyay -S oh-my-zsh-gitcp /usr/share/oh-my-zsh/zshrc ~/.zshrcecho 'source /usr/share/nvm/init-nvm.sh' &gt;&gt; ~/.bashrcecho 'source /usr/share/nvm/init-nvm.sh' &gt;&gt; ~/.zshrc# 添加nvm环境变量到.zshrcexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion# zsh速度优化export NVM_DIR=&quot;$HOME/.nvm&quot;[[ -s &quot;$NVM_DIR/nvm.sh&quot; ]] &amp;&amp; source &quot;$NVM_DIR/nvm.sh&quot; --no-usegit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlightinggit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsgit clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10kplugins=(其他的插件 zsh-autosuggestions zsh-syntax-highlighting)HIST_STAMPS=&quot;yyyy-mm-dd&quot;ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;# 自定义主题p10k configure","link":"/2021/06/14/%E5%AE%9E%E4%BD%93%E6%9C%BA%E5%AE%89%E8%A3%85Arch/"},{"title":"工作流Activiti","text":"工作流的作用是：对系统的业务流程进行自动化管理。一个软件的系统核心是系统的业务流程，工作流只是协助进行业务流程管理。工作流能更好的管理业务流程，提高系统的可扩展性。 工作流的具体应用： 关键业务流程 行政管理类 财务相关类 客户服务类 特殊服务类 在没有专门的工作流引擎前，要实现流程控制，通常的做法是采用状态字段的值类跟踪流程的变化情况。这样不用角色的用户，通过状态字段的取值来决定记录是否显示。但是这样做和业务代码的耦合性特别高。 Activiti7概述Activiti是一个工作流引擎，activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行。实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时减少了系统开发维护成本。 BPM：Business Process Management业务流程管理 BPM软件：对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升。 BPMN：Business Process Model And Notation业务流程模型和符号，是由BPMI开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 BPMN图形其实是通过xml表示的业务逻辑，上面的.bpmn文件使用文本编辑器打开后是一个xml文件 Activiti的使用Activiti的使用步骤部署activiti Activiti是一个工作流引擎，业务系统访问activit的api接口，就能方便的操作流程相关数据，这样就可以把工作流环境与业务系统的环境集成在一起。 流程定义 使用activiti流程建模工具（activiti-designer）或者通过手写xml文件来定义业务流程（.bpmn文件） 流程定义部署 使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容 Activiti执行把流程定义存储在数据库中 启动一个流程实例 启动一个流程实例表示开始一次业务流程的运行 For Example：在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互不干扰 用户查询待办任务Task 因为系统的业务流程已经交给了activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些东西activiti都帮我管理了 用户办理任务 用户查询待办任务后，就可以办理某个任务了，如果这个任务办理完成后还需要其他用户办理，比如：采购单创建后由部门经理审核，这些过程也是由activiti帮我们完成了。 流程结束 当任务办理完成后没有下一个任务节点了，这个流程实例就完成了 Activiti环境123456&lt;!-- https://mvnrepository.com/artifact/org.activiti/activiti-engine --&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;7.1.0.M6&lt;/version&gt;&lt;/dependency&gt; Activiti运行需要有数据库的支持，支持的数据库有：h2，mysql，oracle，postgres等。 在IDEA中创建一个Activiti的Maven项目框架 导入Maven依赖包： Activiti相关的包：activiti-engine包，activiti依赖的jar包，activiti依赖的spring包 mysql的驱动包：mysql的数据库驱动包 mybatis的包： log4j的包 数据库连接池的包：第三方数据库连接池包dbcp 单元测试包junit","link":"/2021/09/23/%E5%B7%A5%E4%BD%9C%E6%B5%81Activiti/"},{"title":"国庆北京独游","text":"在保定工作的这3个月里，从学校到工作过渡很平稳，学校里做的事和工作中差异不大，总体来说还是很快适应了工作环境。另外，和学校相比，假期确实太少啦，但是没办法，毕竟要挣钱的嘛。自己要想办法在一天8小时的工作中做更多有意义的事，否则就真的是浪费时间了。 好不容易等到国庆长假，早就计划趁着这次假期去北京走走看看，上一次去北京还是大二寒假返校利用转机空挡期在北京玩了一天，那次北京行印象深刻。但一天的行程，我即使用一天50000步的极限速度来搞，也不可能走完北京几个著名景点，况且还是走马观花式地在地铁线上往来于景点之间。 这次的北京行，我希望能尽量放慢时间，从底向上体会北京这座城的样貌。 总体计划先说一下旅行前的大致安排： 第一天：天安门、故宫、北海公园、三里屯太古里、北京CBD核心区域、王府井 第二天：奥林匹克公园、圆明园、颐和园 第三天：八达岭长城 Day19月30号下班后，备置些干粮，带上洗漱用品、充电宝、雨伞、充电器、钱包…。 由于是国庆节假日，可以预料到北京的拥挤程度。我提前预定了故宫和长城的门票。根据自己的行程安排预定好住宿旅馆：第一天的写在了王府井附近的一个胡同里；第二天的定在了鸟巢附近。 10月1号的高铁是6点40的班次——当天最早的一趟。保险起见，前一天晚上在滴滴就预约了凌晨4点的出租车，结果到了高铁站才知道高铁站6点开门，于是，我在高铁站外的一个尚未装修完的地下商场里等了1个小时…好在这地方还挺暖和。 坐上高铁，40分钟就到了北京。北京西站没有直达天安门广场附近的地铁。坐地铁最近能到天安门广场南几公里远，然后我骑着共享单车跟着导航穿越了传说中的北京胡同。 所谓胡同，其实就是北京老式住房间的过道，算是北京最具本地特色的文化之一。骑一段路就要看看导航，最后总算是断断续续地走出来了，走出胡同最先入目的就是箭楼和正阳门，两个建筑非常端庄地前后有序地坐落在北京城的中轴线上。 意料之中，人真的很多，毕竟时值国庆日，人再多都是能理解的。 排队安检后来到天安门广场，时隔3年再次来到天安门广场，和上次相比，10月1日的天安门广场自然有所不同。沿着中轴线摆放着巨型花篮和孙中山先生的画像。毛主席纪念堂、国家博物馆、人民大会堂、天安门从东南西北四四方方地围着广场，广场上竖立着国旗和人民英雄纪念碑。建筑整体看来非常大气壮观，倍显大国气象。 从地下通道穿过长安大街来到天安门下，顺着故宫西墙往北走，就能看见后海。北京似乎有很多海，这些“海”有很重的人文色彩，大概就是明清时期的皇家湖泊吧。 后海里的面积挺大，风景也很不错，值得一来。 逛完公园后后乘公交原路返回，从天安门进入，穿过端门，就能看见雄伟的故宫大门——午门了。故宫每天的游览人数是有限制的，所以需要提前在微信公众号预定门票，现场是不出售门票的。 故宫虽然没有完全开放，但如果你想走完左右地方是不现实的，我选了一条公众号上推荐的路线：从午门进入，沿着中轴线经过太和门，太和殿、中和殿、保和殿，然后进入后宫，沿着乾清宫、交泰殿、坤宁宫、东六宫（钟粹宫、景阳宫、承乾宫、永和宫、延禧宫、景仁宫），最后，经过斋宫武备馆、宁寿宫，从神武门出去就算是出了宫😄。 从故宫出来，已经是下午4点过了，在神武门外搭乘双层大巴去南锣鼓巷换乘地铁前往三里屯。 北京三里屯太古里和成都那个太古里差球不多，满眼的外国牌子，一个都不认识，留下一张外景就拍屁股走人。 之后来到北京CBD核心区域，也是北京城最大的商业圈，“大裤衩”、国贸大楼…高楼林立，极具钢铁美感，作为共和国首都，经济自然不能太拉。 到王府井已经是晚上了，逛了会儿街。最后的晚饭在王府井街道末尾的APM吃的。 回到旅馆就睡了，太累了！哈哈，上一次50000步也是上一次的北京，不过有一说一，也是靠着北京世界级的城市交通网络我才能在十几个小时内在这么多地方往返。 Day2第二天早上8点过才醒，收拾好后就去了奥林匹克公园。遗憾的是，北京这3天的天气真是一天比一天差。 来看鸟巢水立方的人明显较之其他地方的少，阴雨绵绵下的鸟巢少了运动的活力，添了几分忧郁的气质。玲珑塔上北京2022冬奥会的倒计时预示着3个月后这里又将迎来世界体育的目光。 圆明园上次就来过一次，这次去就随着人群走马观花了。 这次来北京的初衷就打算把颐和园和长城看了，结果到了颐和园才发现要提前预定门票，哎，没办法，以后有机会再来吧。圆明园旁边就是清华北大——中国两所巨无霸高校，一路上遇到的可能全是学霸… 计划里没了颐和园，之后去逛了逛牛街，这是条清真小吃街，几家名小吃门前排队的人也很多。 最后回到鸟巢，在附近电影院里看了《长津湖》，这部主旋律电影优点很多，但是3个小时的电影剧情不连贯，也少有起伏。但总体来说还是推荐的。希望之后能多拍这种共和国历史重要节点的历史战争片。 电影看完就11点了，第二天行程结束。 Day3由于前两天的高负荷奔走，第三天9点才从旅馆动身出发，一路上公交车、地铁、火车，到八达岭总共花了3个小时，本来时间都不太够了。到了八达岭脚下看见只见蛇头不见蛇尾的队伍心就凉了一半了，等坐缆车上了长城彻底绝望了。 好家伙，百闻不如一见，果真是人海，一点不夸张。 我的感受是：长城应该像故宫、颐和园那样采取提前预约制，再加上长城本身只有极为狭窄的通道，这种摩肩擦踵的游览确实十分糟心。 然而我还是低估了，刚走一会儿又开始下雨，然后大部分游客又顺着原路返回，emmmmm，回去也堵上了，我真的服了。 此时应该安慰自己，至少还是“到此一游”了😭 回看旅行前的计划，没有完全实现，也没有很多从底向上细看北京城的机会。主要原因还是行程安排的太满，有得必有失，下次旅行总结经验。国庆北京行总体来说还是很不错的，很多地方都是第一次去，惊叹于故宫的红墙金瓦，震撼于长城的庄严磅礴，向往于CBD的高楼大厦；不知道下次到北京又是什么时候，希望能把这次的遗憾补足。","link":"/2021/10/13/%E5%9B%BD%E5%BA%86%E5%8C%97%E4%BA%AC%E7%8B%AC%E6%B8%B8/"},{"title":"摄影入门","text":"曝光 摄影就是用光线绘图，摄影是光与影的艺术！ 曝光：胶片、底片、数码时代的CMOS通过光线产生影像的过程 曝光不足 &amp; 曝光过度(过曝) 曝光正常：亮有细节不过曝，暗有层次不漆黑 摄影的第一步是控制曝光 光圈（f） 光圈用来控制进光量 f3.5、f5.6、f8、f11、f16、f22：数值和光圈大小成反比 大光圈：景深浅，主体清晰背景模糊 小光圈：景深长、主体和背景都很清晰 快门（以秒为单位） 用来控制光线进来的时间，时间越长曝光越多 高速快门凝固瞬间 低速快门记录轨迹（必须用三脚架） 感光度ISO 底片/胶片/CMOS感光元件 等硬件的感官能力 ISO越高，感光能力越强，画质越粗糙，噪点越多；反之亦然 但是：一张有噪点的照片比一张拍虚了的照片有价值 当光圈和快门没有办法时，适当提高ISO增加亮度 重点：光圈、快门、ISO调节优先级：光圈 &gt; 快门 &gt; ISO 暗处：首先增大光圈，如果不够再适当延长快门时间，如果此时光线还是不足，那么再调节ISO，增大感光能力 亮处：首先缩小ISO，降低感光能力，如果还是太亮，就缩短快门时间，如果还是不行，再缩小光圈。 拍摄模式 拍摄模式种类： M：手动曝光模式 A（AV）：光圈优先模式 S（TV）：快门优先模式 P：程序自动模式（傻瓜模式） 光圈、快门、ISO的组合关系 光圈、快门、ISO共同决定了一张影像的曝光 相机镜头 定焦 &amp; 变焦 定焦镜头：成像质量好，方便性差 变焦镜头：成像质量比定焦镜头略差，方便性好 焦距：决定了镜头能看到的范围大小 镜头越短看的范围广，镜头长看的范围窄 广角：&lt;24mm，景深大 标准：≈55mm 中长焦：70-135mm 长焦：&gt;135mm，景深浅 焦距越长，景深越浅；焦距越短，景深越深。 对焦模式 手动对焦模式（MF）： 变焦环：伸缩镜头，达到变焦目的 对焦环：手动对焦时用 自动对焦模式（AF）： 尼康：AF-S、AF-C、AF-A 佳能：ONE SHOT、AI SERVO、AI FOCUS 对焦点的作用 单点对焦：一般用于拍摄静止物体（拍一个花瓶） 区域对焦：一般用于拍摄不规则运动的物体（拍一群鸟，一群人） 白平衡 白平衡能对光线颜色进行补偿 AWB：自动白平衡，类似人的眼睛，在不同光线下相机自动识别定义一个比较合适的白平衡保证拍摄物体尽可能地呈现自身的颜色 AWB只在一定的色温范围内是准确的 预设的几种白平衡可以选择集中预设的白平衡选项 用户自定义可以更加的自由（重点！重点！重点！） 色温K值越大越冷，反之亦然；白平衡和色温恰好相反。但是很多人是把色温和白平衡弄反了 其实我们利用白平衡欺骗相机，你可以设置一个高的色温值，然后相机就会认为此时的画面色温很高，就会往画面中加入暖色调来中和 光 光质： 直射光（硬光）：晴天，明暗反差大 散射光（柔光）：阴天，明暗反差小 光位： 光位就是光源相对于相机和被拍摄物体的位置 顺光：光线来自被摄物的正面；立体感差、缺乏明暗变化 侧光：光线来自被摄物侧面45-90°；立体感强、富有戏剧性 逆光：光线来自被摄物后面；用来塑造轮廓 顶光：光线来自被摄物正上方；阴影浓重，用来突出局部 底光：光线来自被摄物下方；使用较少，因为很恐怖，多和其他几种混合使用 光比： 光比是被摄物体主要亮部&amp;暗部受光量的差别 可以通过人造灯光进行补光来改变环境光造成的光比 景别 远取其势，近取其神 视角 视角：景物水平线和相机所处的水平线不尽相同 高视角：适合宏大、宽广、遥远的大场面 低视角：适合表现主体（人物、建筑）的高大 平视角：最接近人眼，很稳，适合平淡的感觉 空间构图 &amp; 平面构图一定要主次分明 透视： 用线条 或 影调在平面上表现立体空间的方法 近暗远亮、近大远小、立体图阴影、道路的走向引导视觉、近深远浅 前景： 作用：加强气氛、增强画面空间层次感、均衡画面 背景： 作用：突出主体、丰富主体的内涵、 平面布局： 平面构图就是如何把人、景、物安排在画面单中以获得最佳布局的方法，重点无非就是：点、线、面 黄金分割点：九宫格的中间四个交点就是黄金分割点（长宽各3等分） 平行线、X交叉线、不规则线条：线条形式美、空间视觉衍生 构图方法： 构图从观察和模仿开始 把经典的构图长记于胸 让构图方法自己跳出来 打破陈规寻求突破 摄影开心就好，不要纠结本末倒置 常见题材的摄影技巧 日出/日落：（日出：更蓝一些；日落：更暖一些） 拍摄地点：开阔地、地势高处 拍摄时间：不同季节、不同地点不同；春秋两季更好 如何测光：测中等亮度的位置 注意构图：将太阳放在画面的趣味点上，并注意前景的选择和处理；前景选择小树、小草、树枝、礁石等能增强纵深效果。 瀑布：（高速快门凝结飞溅水花；慢速快门拍摄雾状水流） 合适天气：更长时间按下快门 滤镜（减光镜）：使得快门可延长 低ISO：减少噪点，提高清晰度，适应快门时间延长 构图动静结合：静石头 和 雾化动感水流 烟花 使用小光圈，景深大 手动对焦 注意按下快门的时机 使用三脚架保证稳定记录完美轨迹 选择顺风位置：烟花的烟吹走保证画面干净 使用湖面倒影 &amp; 城市夜景做衬托，避免画面单调 夜景人像拍摄 闪光灯（内置/外置闪光灯） 逆光补光 夜景补光 方法： 控制好环境的光线（调整光圈和ISO，快门较快按下） 闪光灯打亮主体 夜景风光拍摄 时间：晴朗 附件：三脚架、快门线、手电筒、遮光板 夜景一般要深景深，用小光圈。ISO调小。快门曝光时间较长。 光斑怎么拍？浅景深，大光圈，虚焦 滤镜 保护镜：防污、防刮、防潮 UV镜：紫外线滤光镜，提供真实、艳丽画面 偏振镜：消除镜面反光，压暗天空表现蓝天白云，同时一定程度减光 ND中灰密度镜：减光，防止过曝，适合在光照强烈的白天长曝光作品 硬边GND中灰渐变镜：压低天空亮度，平衡天空和地面海洋的曝光 硬边GND中灰渐变镜：明暗渐变不明显 RGND反向中灰渐变镜：越靠中间越黑，有效阻挡画面中央的高光物体 彩色滤镜：用于改变画面颜色，已被数码时代的强大后期取代 冷暖滤镜：矫正白平衡 近摄镜：缩短镜头对焦距离，方法被拍摄物体 黑白滤镜：黄、绿、橙、红 人像摄影常用方法： 顺光和测光使用方法 顺光：整个景物均匀受光，没有光影效果，缺乏立体感。例：证件照 测光：景物显得层次丰富，立体感强，但拍摄时要控制光比的变化 逆光和漫射光使用方法 逆光：景物有一道明亮的轮廓线，产生强烈的立体感，一定要注意补光（反光板、外置闪光灯、 内置闪光灯）的问题 漫射光：景物周围都有光线照射到，光线比较柔和，景物没有明显的亮度和暗部，反差柔和，适合拍摄集体照。注意和顺光的区别：漫射光一般是在阴天/多云天气形成的，顺光是将更多的光照射正面。 人像摄影构图 主要是要注意两个方面：主体的位置，主体在画面中的比例 三种主要构图法： 黄金分割点构图法：九宫格 中心构图法：拍大头照，人像 吊角构图法：将景物放在画面中的某个角落 几种表现形式： 虚实对比 大小对比 远近对比 色彩对比 剪影表示形式：逆光注重轮廓 外景拍摄中不同拍摄角度的运用 平拍：自然，客观，平等，亲切 俯拍：低矮，身体压缩，额头夸大下巴窄小。自拍的时候一般都是俯拍 仰拍：高大身体修长，腿长身短，高大挺拔 摄影的影调什么是影调？ 线条是一张作品的骨架，而影调是一张作品的血与肉 定义：在不同强弱的光线照射下，被摄物体产生不同的明暗反差 分类： 高调：浅色背景，正光/顺光，光比不大于1：1.5，浅灰色背景将人和背景分离，一般以半身特写居多，背景亮度高于主体1.5倍数 低调：背景服装以深色为主，侧光/逆光，光比大于1：3.5，用轮廓灯让主体与背景分离 中间调：间于上面两个之间","link":"/2021/10/10/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/"},{"title":"强大的文本编辑器:Vim","text":"Vim是linux中的一款使用最广的文本编辑器，全屏幕编辑器。 可以建立，编辑，显示文本文件。 它没有菜单只有命令. 三种模式 命令模式 插入模式：后：a/A，前：i/I，行：o/O进入 退出模式 常用操作12345678910111213141516171819202122232425262728293031323334:set ic————搜索时不区分大小写:set nu————显示行号:set nonu————关闭行号:gg————快速定位到第一行:G————快速定位到最后一行:nG————快速定位到第n行:n————快速定位到第n行$————快速定位到行尾0————快速定位到行首x————删除光标后字符X————删除光标前字符4x————删除光标后n个字符dd————删除一行4dd————删除当前行和下面的n-1行dG————删除当前行到文件末尾D————删除光标到行尾:1,8d————删除第1行到第8行yy————复制当前行nyy————复制当前行和下面的n-1行p————粘贴到光标下一行P————粘贴到光标上一行r————替换当前字符R————从当前位置一直往后替换（进入替换模式，esc退出模式）u————恢复ctrl+r————撤销恢复:/string————搜索命令，按n找下一个:%s/old/new/g————全文替换old为new:n1,n2s/old/new/g————n1到n2行替换old为new:w————保存（相当于Windows的ctrl+r）:w filename————另存为:wq————保存并退出ZZ————保存并退出:q!————不保存退出:wq!————强制保存退出，针对只读文件可以强行保存(只有文件所有者和root才可以) 查看命令的执行结果： :!命令 导入内容到文件中： :r 导入文件地址：导入文件内容 :r !命令：导入命令执行结果 查看命令的地址： :!which 命令名 定义快捷键： :map 快捷键 触发命令 关键词自动替换 :ab mymail XXXXXXX@gmail.com：输入mymail是自动替换为你的邮箱地址 所有配置都是临时的，要永久需要写入配置文件里，存放在用户的家目录下，.vimrc，如果没有的话就自己新建一个也ok","link":"/2020/03/05/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-Vim/"},{"title":"旧手机搭建linux服务器","text":"硬件&amp;软件准备：硬件： 一台已root的安卓手机 软件： Linux Deploy：https://github.com/meefik/linuxdeploy/releases busyBox：https://github.com/meefik/busybox/releases 开干 点开busyBox直接安装，记住安装地址 点开linux deploy，点击左上角三条杠，修改系统名字，然后进入设置，自己根据需要开关选项 在PATH环境变量里写上busyBox的安装路径 点击右下角的属性按钮，根据需要安装linux发行版 我选的是ubuntu，考虑到国内网络环境，将源地址改为http://mirrors.ustc.edu.cn/ubuntu-ports/ 在镜像大小里最好分多点空间，默认只有2G，如果有外置sd卡最好把镜像地址改为sd卡的地址，这样能自行分区更合理。 修改初始用户的username和password，本地化选择语言，推荐英文 初始化，挂载，SSH，声音服务 推荐都弄上 返回主界面，点击右上角三个点开始安装，等待一会儿，直到出现deploy字样，说明安装成功 此时先点击停止，在点击启动，就可以根据局域网ip通过ssh来远程连接安卓上linux容器了。 配置做一些配置 12345678910apt updateapt upgradeapt install gcc g++ vim git openjdk-8-jdk net-tools bash-completion htop# LinuxDeploy下ping命令无法运行，提示socket：权限不足，原来android里将一些硬件使用（包括网络）的权限归到不同的用户组. 而3003就是关于网络权限的组，称为inet. 上述命令是在debian的用户权限系统中给root 添加inte权限．usermod -G 3003 root# 修改root的密码su - rootpasswd 安装samba服务12345678910111213141516171819202122232425262728#安装sambaapt install samba samba-common#选定需要共享的文件夹mkdir XXX#设置文件夹权限chmod 777 XXX#设置samba用户密码useradd smbUsersmbpasswd -a smbUsersmbpasswd -xx smbUser#配置samba的配置文件vim /etc/samba/smb.conf[share]comment = share folderbrowseable = yespath = XXXcreate mask = 0700directory mask = 0700valid users = smbUserforce user = smbUserforce group = smbUserpublic = yesavailable = yeswritable = yes#启动服务service smbd restart 尝试了这种通过smb协议实现局域网共享文件的方式，能实现。但是不知道为什么不能共享挂载到安卓的目录，所以有了下面的方案。 File Brower 可以采用网盘实现方式，有很多相似的产品：OwnCloud，NextCloud，Seafile都可以，但是这些都有需要依赖的环境，部署相对麻烦，我选择了一个只需简单配置就能使用的私人网盘：File Brower File Browser 是一个基于 Web 的文件管理器。它可以使你随时随地的对设备的文件进行基本的管理操作，如：创建、删除、移动、复制等。它除了可以让你进行文件管理之外，还有一些其他的功能。它支持多个用户的管理，而且每个用户可以拥有自己可以访问的文件和权限。它还支持文件分享，就行网盘那样，你可以通过它来向你的朋友分享文件。你还可以用它来执行一些 Linux 命令，比如你想要在当前目录下克隆一个代码库，就可以用它来执行git等命令。 1234567891011121314151617181920212223#安装(之前可能需要配置hosts)curl -fsSL https://filebrowser.xyz/get.sh | bash#创建配置数据库filebrowser -d /etc/filebrowser.db config init#设置监听地址filebrowser -d /etc/filebrowser.db config set --address 0.0.0.0#设置监听端口filebrowser -d /etc/filebrowser.db config set --port 8888#设置语言环境filebrowser -d /etc/filebrowser.db config set --locale zh-cn#设置日志位置filebrowser -d /etc/filebrowser.db config set --log /var/log/filebrowser.log#添加一个用户（已有一个默认的admin:admin用户）filebrowser -d /etc/filebrowser.db users add username password --perm.admin#启动服务 &amp; 设置别名简化启动filebrowser -d /etc/filebrowser.dbvim ~/./bashrcalias runnas=&quot;filebrowser -d /etc/filebrowser.db&quot;#支持Https(其中example.com.crt和example.com.key分别是 SSL 证书和**路径，根据自身情况进行更改。配置完 SSL 后，只可以使用 HTTPS 访问，不可以使用 HTTP)filebrowser -d /etc/filebrowser.db config set --cert example.com.crt --key example.com.key#取消 SSLfilebrowser -d /etc/filebrowser.db config set --cert &quot;&quot; --key &quot;&quot; 开机自启 &amp; 后台运行问题两种方法：nohup和systemd 第一种 运行：nohup filebrowser -d /etc/filebrowser.db &gt;/dev/null 2&gt;&amp;1 &amp; 停止运行：kill -9 $(pidof filebrowser) 开机启动：sed -i '/exit 0/i\\nohup filebrowser -d \\/etc\\/filebrowser.db &gt;\\/dev\\/null 2&gt;&amp;1 &amp;' /etc/rc.local 取消开机启动：sed -i '/nohup filebrowser -d \\/etc\\/filebrowser.db &gt;\\/dev\\/null 2&gt;&amp;1 &amp;/d' /etc/rc.local 第二种 操作百度 运行：systemctl start filebrowser.service 停止运行：systemctl stop filebrowser.service 开机启动：systemctl enable filebrowser.service 取消开机启动：systemctl disable filebrowser.service 查看运行状态：systemctl status filebrowser.service","link":"/2021/02/19/%E6%97%A7%E6%89%8B%E6%9C%BA%E6%90%AD%E5%BB%BAlinux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"毕业九寨三人游","text":"6月9号本科毕设答辩后就赶回家了，休息一个月就要开始工作啦。和高中同学联系打算出去玩玩儿。综合考虑后打算到九寨-黄龙-若尔盖一线玩玩儿，我的博客不仅仅是技术博客，旅行游记是一个不错的题材。 总体计划本次前往九寨沟的行程有几个计划：报个旅游团、坐班车去然后租车自驾、全程包车、坐班车去然后包车等等计划都有想过，虽然三个同学都有拿到驾照，但是平时都在学校学习，开车的机会并不多，再加上当前绵九高速正在施工，从江油前往九寨沟的路并不好走甚至有点儿危险；在论如果跟团游的话不是很舒服，旅行安排的灵活性就不足。最后选择自行做班车到九寨沟，然后在九寨沟当地联系一个司机包车游览九寨沟、黄龙、若尔盖草原一线。九寨沟是没有铁路的，当然，你可以选择做飞机前往，但是因为旅游专线，机票价格十分高昂。 这个司机也是在网上浏览一个2017年的游客写的游记，其中推荐了这个九寨沟当地刘师傅。先说一下旅行的总体安排。整个旅行大概有6天时间： 第一天：从江油做班车到九寨沟，晚上就住进沟内 第二天：游览九寨沟，看九寨千古情演出，住在九寨沟附近 第三天：从九寨沟经雪宝顶、川主寺一线前往黄龙，游览黄龙，住在松潘 第四天：从松潘出发前往若尔盖大草原，体验骑马，黄河九曲第一湾看日落，住在唐克 第五天：从唐克出发，经瓦切、红原一线返回松潘，住在松潘 第六天：从松潘搭班车返回江油 Day 1旅行前几天，最好准备些零食干粮、防晒工具（喷雾、冰袖等）、防寒衣物、晕车药。 当天一大早，从家出发前往汽车站和一个同学会合同乘班车从江油出发，另一个同学从广元出发。六块钱一颗的晕车药属实厉害，抖了7个小时的山路都没晕车。下午5点，三人会合于九寨沟。有意思的是，在从江油出发的班车上，遇到了一个九寨沟内的大叔，交谈一番后，他表示内把我们带进去，连同一晚的住宿只需要220块钱，比门票259便宜很多。三个刚毕业的大学生为了节省预算还是忍不住……当然，这种做法不合规也不推荐， 出了事儿也只能自己负责，所以还是推荐正常购买门票。 当天晚上就住在九寨沟内的荷叶寨，民宿老板很友好，房屋非常具有藏式特色。晚餐后小试了会儿无人机拍摄。一天颠簸的车程很是疲劳，一切收拾妥当后就睡了。 Day 2第二天早上吃完晚饭后就直接轻装出发，行李留在民宿，下午游览完后来取。 九寨沟属于古冰川地貌，冰川融化，积水沿着山谷留下聚集就形成了被当地人成为“海子”的湖泊。 九寨后的游览有两种方式：步行和坐车，一般来说都是坐车到某个地点，然后下车游览。总体的游览流程是：从盆景海做车到老虎海，游览老虎海、树正瀑布、犀牛海后，从犀牛海坐车到则扎洼沟的长海，游览长海、五彩池后坐车回到诺日朗游客中心。（上季节海、下季节海都在车上观览）。 到诺日朗就差不多中午了，可以选择在诺日朗中心食堂用餐，推荐自带干粮解决。然后从游客中心坐车去五花海。（因为2017年的地震，日则沟再往上的旅游景点还没有重新开放，最远只能走到五花海）从五花海往回步行，五花海、孔雀河道、金铃海、珍珠滩瀑布、诺日朗瀑布，是九寨沟景点最丰富的地方。步行到诺日朗后坐车到老虎海，然后下车步行至出口，结束。 当然，实际的情况还是没能复制计划。当下午游览到珍珠滩时，天降暴雨，只得坐车直接到出口。虽有遗憾，但幸运的是把九寨沟的主要景点都游览到了。九寨的风景是世界闻名的，青山绿水间隔坐落在山谷间，仿佛置若仙境，甚是惊艳。 出了九寨沟景区就联系了包车司机，晚上计划是观看九寨沟千古情演出，旅馆就定在了千古情旁边。晚上的千古情果真精彩以至于忘记了拍照…… Day3从九寨沟景区往南走，路过雪宝顶、川主寺到达黄龙景区，和九寨沟一样，黄龙也是世界自然遗产。其独特的喀斯特地貌让黄龙景色堪称一绝。 购买门票（学生证可半价）后，做缆车直接到达黄龙最高点，然后步行往下走，黄龙这个地方海拔确实有点儿高，运动量稍微增大就气喘吁吁，不过一路上逗提供了氧气补充站。黄龙的景色和九寨沟不同，九寨沟是看山谷间的山水，黄龙是体验置身大山中的渺小。 从山顶往下走，路很长，不过路上的风景也是应接不暇。刚开始，山路两旁甚至路中间都是高大的树木，山路虽平缓，但四千多米的海拔导致氧气稀薄，还是建议慢慢走，不要走太快。每走一段路都有补氧站，仨人进去体验了一把，也就是找个地方坐会儿歇口气，工作人员两根管子插鼻孔，氧气袋放你背后，不一定有啥大用，新奇的体验还是不错的，哈哈。 往下走一段路，就会有被称为很多被称为“五彩池”的大型喀斯特地貌景观，实际上就是长期钙化沉积形成的小湖，配合川北的高山地貌，有一说一，还是非常漂亮的。在黄龙景区中有一个相对宽广的位置，应该是个山谷，几座寺庙座落下雪山之下，旁边就是一片片的五彩池错落堆叠。我想若是孤身来此，定会被群山和碧水的酷冷所吞噬。 继续下山，之后的景观基本就大同小异了，都是碳酸盐沉积后形成了一片片水池，有种广西贵州那边梯田的感觉。遗憾的是不久就下雨了，虽说雨不大，但是没有了阳光的照射，水池显得死气沉沉的，遂快步下山，司机载着我们前往松潘，找了间旅馆住下了。 有趣的是，途中遇到了好几只松鼠，这些松鼠似乎并不怎么怕人，看来生活地还是比较安逸。 晚上住在松潘的一条街上，都是卖特产的小店，锟哥似乎对这些东西尤为喜欢，在与店主套完近乎后，又多次博弈，最后心满意足地买了5多雪莲花，之后在另一家店也偶然看见了雪莲花，一问结果便宜一半，😄。 Day4第四天的计划是从松潘出发前往若尔盖草原，说实话，这趟草原之旅是我最期待的，草原的辽阔空旷只在影视作品里体会过，在此之前还没有正紧地去过真正的草原。幻想这样一个场景：蓝天白云，绿草无边，牛羊成群，一条弯曲的公路铺在平缓的绿色地毯上，汽车沿着这条公路平稳地行驶着，向着无垠地远方。。。我去，太巴适了。 初入草原，就迫不及待地下车，说实话，第一次现场感受草原，很有冲击力。 之后到了一家藏家乐，来草原不能不骑马，其实刚开始还是有点儿犹豫，一是价钱有点儿贵，而是有点儿恐惧（我胆儿小😱），但是想到在正儿八经的草原骑马的经历还是很难得的，就开始了人生的第一次骑马。一个藏族小哥和我一前一后，这个小哥爱开玩笑，老是让马跑步前进，本身就很抖，在一跑，我去，勾deng子qing疼。视频里看别人骑马很飒，真轮到我了就呵呵了。不过慢慢就熟悉了骑马的奥义：肌肉不要太紧绷，要迎合马身体的抖动带动自己身体的抖动，这样就会轻松很多。中途骑着马到达草原上一个山包顶，风很大并且夹杂着雨水，冻得我呀，早知道还是应该穿件藏袍。总之，骑马还是挺好玩的，不知道下一次骑马又是几年后。 之后继续赶路，一路上都是原生态草原景观，中途一些牧民赶着牦牛群穿过公路，刚好碰上，近距离观赏了牦牛这个高原特殊畜种，中途还是顶不过困意睡了一觉。 最后到了唐克的旅馆，放好行李准备去九曲黄河第一湾看日落。 阴差阳错，锟哥想爬上去结果做了电梯；我和杰哥想做电梯结果被锟哥忽悠买了普通票。所以我就和思杰一路顺着木制阶梯一段一段地爬到顶部。不得不说，站在一定高度俯瞰草原是最能体会草原辽阔的手段，感谢锟哥的歪打正着😄。一路上的风景确实非常不错，望着辽阔无边的草原，仿佛此时此刻所有的烦恼都不存在了。这里的海拔没有黄龙那么高，但是3500m左右的海拔然是让我俩每爬一段路就气喘吁吁。 最后在最高点和锟哥会合。不久，太阳从草原最远方的地平线上缓缓落下。没了太阳的草原温度迅速降低，赶快回去享受被窝的我温暖。 Day5第五天开始返回，顺着红原、瓦切一线返回松潘。其实玩了这几天大家都有点儿累了，草原看了一天也看厌了。今天的最大期待是草原上的烤羊腿。 开整 不出意外，没吃完。 晚上回到松潘，准备搭乘第二天早上的班车回江油 Day6第六天一大早，简单吃了点儿饭就坐车回江油了，一路上的颠簸还是和来时一样，车程6个小时，到了江油。思杰说来江油读高中3年都没吃过肥肠，哈哈，那还不尝尝，江油肥肠名店除了老火车站的罗肥肠，城里就数这家小小吃了。杰哥很满意，说如果广元肥肠有这个味道，绝对天天吃肥肠。。。 九寨沟的这次旅行，和高中挚友同行，一路都很开心，足矣！","link":"/2021/07/08/%E6%AF%95%E4%B8%9A%E4%B9%9D%E5%AF%A8%E4%B8%89%E4%BA%BA%E6%B8%B8/"},{"title":"我的Linux工作平台搭建","text":"Mint LInux安装概述 rufus录入iso镜像到U盘 进入bios界面调节启动位置为U盘 开机进入安装界面，下一步… efi分区自动放入win10的efi分区，/分区45G，/home分区300G，swap分区1G 安装后配置双系统时间不同步12345678sudo apt update# 禁用Ubuntu的UTCtimedatectl set-local-rtc 1 --adjust-system-clock# 更新本地时间sudo apt install ntpdatesudo ntpdate time.windows.com# 将本地时间更新到硬件上sudo hwclock --localtime --systohc 输入法里安装ficix &amp; 安装搜狗输入法 IDEA等jetbrain公司的IDE的搜狗输入法不跟随问题可以采用更改这些IDE的运行环境解决 完善mint的中文支持1234567891011sudo apt-get install language-pack-zh-hans language-pack-gnome-zh-hans#添加微软雅黑字体#雅黑字体文件放在 Windows/fonts/ 文件夹，或者在控制面板-字体中查找，两个文件名分别为：msyh.ttf和msyhbd.ttf。字体# 在Linux mint 系统字体文件夹中创建对应的字体文件夹：sudo mkdir /usr/share/fonts/msyh# 移动字体文件到对应的文件夹下：udo mv msyh.ttf msyhbd.ttf /usr/share/fonts/msyh# 更新字体：sudo fc-cache -fv 安装typora1234wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # 添加公钥sudo add-apt-repository 'deb https://typora.io/linux ./' # 添加typora仓库sudo apt-get update sudo apt-get install typora # 安装typora 安装Qv2rayQv2ray下载：密码1lph 插件下载：密码ha9k 制作启动项： 12345678[Desktop Entry]Name=qv2rayComment=network ladderExec=/home/jack1024/Programs/Qv2ray/Qv2ray.v2.6.3.AppImageIcon=/home/jack1024/Programs/Qv2ray/qv2ray.pngTerminal=falseType=ApplicationCategories=Network; 主题美化 Cinnamon主题：选择Full Icon Themes 和 Cinnamon Themes分别下载图标包Papirus和主题包Adapta Colorpack Normal 在Gnome主题的GRUB Thmes中选一个开机引导的主题下载安装 面板移到顶部，调整面板控件摆放 安装扩展、小程序、桌面小工具等插件 选一张好看的壁纸 安装各种软件vim简单配置123456789101112cd ~vim .vimrcset nuset tabstop=4set nobackupset cursorlineset rulerset autoindentset mouse=cset showmode set hlsearch 安装&amp;配置git1234git config --global user.name &quot;yangfanjack&quot;git config --global user.email &quot;1144536063@qq.com&quot;ssh-keygen -t rsa # 生成两把钥匙ssh -T git@github.com # 验证ssh配置是否配置好 安装postman12345678[Desktop Entry]Name=postmanComment=API developmentExec=/home/jack1024/Programs/Postman/PostmanIcon=/home/jack1024/Programs/Postman/app/resources/app/assets/icon.pngTerminal=falseType=ApplicationCategories=Network,Development; 安装wireshark12# 使用usermod命令将您自己添加到wirehark组sudo usermod -aG wireshark $(whoami) 安装picgo-core并配置1234567891011121314151617181920212223242526272829303132# 安装nvm和nodejscurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashnvm --versionnvm ls-remotenvm install v12.18.0nvm ls# 安装gitee插件cd /home/jack1024/.config/Typora/picgo/linux./picgo install gitee-uploader# 配置picgo-core{ &quot;picBed&quot;: { &quot;current&quot;: &quot;gitee&quot;, &quot;uploader&quot;: &quot;gitee&quot;, &quot;gitee&quot;: { &quot;repo&quot;: &quot;gitee用户名/仓库名&quot;, &quot;branch&quot;: &quot;master&quot;, &quot;token&quot;: &quot;你的私人令牌&quot;, &quot;path&quot;: &quot;img/ #你的仓库下的路径&quot;, &quot;customPath&quot;: &quot;default&quot;, &quot;customUrl&quot;: &quot;&quot; }, &quot;transformer&quot;: &quot;path&quot; }, &quot;picgoPlugins&quot;: { &quot;picgo-plugin-gitee-uploader&quot;: true },} 安装zsh &amp; oh-my-zsh123456789101112131415161718192021222324252627282930313233343536# 安装zshsudo apt-get install zsh# 安装oh-my-zshcurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh# 移动配置文件到homecp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc# 设置zsh为默认shellchsh -s /bin/zsh# 优化zsh# 添加nvm环境变量到.zshrcexport NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion# zsh速度优化# Add default node to pathexport PATH=$HOME/.nvm/versions/node/v10.22.0/bin:$PATH# load nvmexport NVM_DIR=&quot;$HOME/.nvm&quot;[[ -s &quot;$NVM_DIR/nvm.sh&quot; ]] &amp;&amp; source &quot;$NVM_DIR/nvm.sh&quot; --no-use# 插件安装apt install batgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlightinggit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsgit clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-openplugins=(其他的插件 zsh-autosuggestions zsh-syntax-highlighting git-open Z)HIST_STAMPS=&quot;yyyy-mm-dd&quot;source ~/.zshrc# 对于powerline主题的字体要求,进入fonts后bash .install.shhttps://github.com/powerline/fonts 安装Powerlevel10k zsh主题1234567891011# 下载Powerlevel10kgit clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k# 配置.zshrcZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;# 安装MesloLGS NF字体文件https://github.com/romkatv/powerlevel10k#meslo-nerd-font-patched-for-powerlevel10k# 自定义主题p10k configure 安装wps缺失字体字体下载地址：密码n9xc 1sudo unzip wps_symbol_fonts.zip -d /usr/share/fonts/wps-office 进入wps-office目录，一个一个地安装 配置各种环境1sudo apt install openjdk-8-jdk gcc g++ cmake 安装mysql官网下载：安装5.7.31 解压，得到13个包，删除两个test包 12345sudo dpkg -i mysql-*.debsudo apt install -fsudo dpkg -i mysql-*.debmysql -uroot -prootshow databases; 因为基于ubuntu20.04的mint20.1的默认mysql版本是mysql8，所以需要锁定版本 12345678# 锁定软件包版本sudo apt-mark hold mysql-commonsudo apt-mark hold mysql-clientsudo apt-mark hold mysql-server# 检查标记为锁定的包sudo apt-mark showhold# 接触锁定sudo apt-mark xxx 安装tomcat官网下载：安装9.0.43 解压后移动： 1sudo mv apache-tomcat-9.0.43 /opt/ 安装maven官网下载：安装3.6.3 解压后移动 1sudo mv apache-maven-3.6.3 /opt/ 配置环境变量 12345678cd /etc/profile.dsudo vim maven.shexport M2_HOME=/opt/apache-maven-3.6.3export CLASSPATH=$CLASSPATH:$M2_HOME/libexport PATH=$PATH:$M2_HOME/binsource maven.sh 拷贝setting.xml到~/.m2下 123456789&lt;!-- 修改respository--&gt;&lt;localRepository&gt;/home/jack1024/.m2/repository&lt;/localRepository&gt;&lt;!-- 修改源--&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; IDEA和Clion配置 大小写不敏感：Editor，General，Code Completion，取消Match case 取消打开默认项目：Appearanc&amp;Behavior，System Settings，取消Reopen 主题：Appearanc&amp;Behavior，Appearance，Theme 编辑区主题：Editor，Color Scheme，Color Scheme Font 字体：Editor，Font 自动导包：Editor，General，Auto Import 自动编译：Build，Compiler，Build Project Auto，Compile independent 软件：日常：搜狗输入法：中文输入法 edge：微软浏览器 chrome：谷歌浏览器 qv2ray：科学冲浪 xdm：下载 utools：让你效率倍增的快速启动软件 每日英语听力：学英语 网易云音乐：在线听歌 1music：一个聚合听歌开源软件 audacious：本地听歌 gimp：图片处理 shotcut：视频剪辑 steam：游戏 vlc：视频播放器 telegram：加密聊天 qq for linux：复古风qq wps：办公套件 百度网盘：限速达人 mindmaster：思维导图 开发clion：C/C++开发IDE idea：Java开发IDE dbeaver：数据库管理客户端 filezilla：ftp客户端 smartgit：git客户端 typora：markdown笔记 virtualbox：虚拟机 vscode：强大拓展性文本编辑器 wireshark：网络抓包 zeal：离线文档 ARDM：redis管理客户端 postman：http调试 小工具keepassXC：密码管理 copyQ：剪切板历史 caffeine：屏幕常亮 keepassxc：密码管理 新立得：apt包管理客户端 Gparted：磁盘管理 bleachbit：清理垃圾 zsh：舒服的shell oh-my-zsh：zsh快速配置 tldr：查看命令帮助文档 htop：系统监视 kdeconnect：电脑手机强大交互软件 plank：dock栏 obs-studio：录屏 etcher：U盘镜像制作 Qredshift：根据时区自动调整屏幕亮度，温感 环境jdk1.8 gcc g++ maven3.6.3 mysql5.7 cmake tomcat9 nvm node 插件扩展watermark 透明面板 小程序Qredshift 系统监视器 Linux系统卸载在win10+linux双系统的环境下，如果要卸载linux系统，采用以下方式： 进入win10系统，磁盘管理中直接清空linux的/分区和/home对应的磁盘分区 如果安装linux系统时新建了linux的efi分区，在win10的磁盘管理工具中是删除不了的，推荐使用Genuis这款windows下的第三方磁盘管理软件来清除efi分区。 如果安装linux系统时将linux的efi分区和win10的efi放在了一起，那么需要进行如下操作： 1234567891011# 以管理员身份进入PowerShelldiskpart #进入diskpartlist disk #列出所有磁盘select disk 0 #根据自己的情况选择efi分区对应的磁盘list partition #列出该磁盘所有分区select partition 1 #根据自己的情况选择efi分区对应的分区assign letter=p: #为所选分区分配盘符pexit #退出diskpartp: #进入p盘cd efi #进入efi文件夹，然后根据自己的情况删除相应的文件夹 但是这个时候bios中还是有ubuntu的选项，可以通过easyUEFI或者Bootice来删除","link":"/2021/03/06/%E6%88%91%E7%9A%84Linux%E5%B7%A5%E4%BD%9C%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/"},{"title":"精简版JS:jQuery","text":"JavaScript 和 JQueryjQuery就是一个JavaScript库，里面封装了大量JavaScript函数 推荐一个各种开源项目CDN服务搜索网站：https://www.bootcdn.cn/ 1234567891011&lt;a href=&quot;&quot; id=&quot;text-jquery&quot;&gt;click me&lt;/a&gt;&lt;!--JavaScript的在线cdn引入--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //公式：$(css的selector).action(); //document.getElementById(&quot;text-jquery&quot;).onclick = function(){} $(&quot;#text-jquery&quot;).click(function(){ alert(&quot;hello,jquery&quot;); })&lt;/script&gt; $是什么123456789//jQuery的文件结构：其实是一个自执行函数,引入了jquery的js文件，会执行这个自执行函数。(function(){ window.jQuery = window.$ = jQuery;//给window对象添加一个jQuery属性和$属性，用JQuery函数赋值给$ //$是一个函数，所以会根据参数的不同进行不同的处理 $(function(){});//入口函数 $(&quot;#div&quot;);//选择器 $(&quot;&lt;div&gt;我是一个div标签&lt;/div&gt;&quot;);//创建div标签 $(dom对象);//把dom对象转化为jquery对象}) Dom对象和jQuery对象dom对象：原生js选择器获取到的对象，只能调用dom属性或者方法，但是不能调用jQuery的属性和方法 12var div1 = document.getElementById(&quot;div1&quot;);div1.style.backgroundColor = &quot;red&quot;; jQuery对象：由jQuery选择器获取到的对象，只能调用jQuery的属性或者方法，但是不能调用原生js的属性和方法 12var div1 = $(&quot;#div1&quot;);div1.css(&quot;backgroundColor&quot;,&quot;red&quot;); jquery对象是一个伪数组，其实是dom对象的一个包装集 jQuery和JavaScript对象的互相转化： 123456789//JavaScript对象——》jQuery对象var div1 = document.getElementById(&quot;div1&quot;);var $div1 = $(div1);$div1.css(&quot;backgroundColor&quot;,&quot;red&quot;);//jQuery对象——》JavaScript对象var $div1 = $(&quot;#div1&quot;);var div1 = $div1[0];var div2 = $div1.get(0); 选择器12345678910111213141516171819202122//原生JavaScript//标签document.getElementsByTagName();//iddocument.getElementById();//类document.getElementsByClassName();//jQuery选择器$(&quot;p&quot;);//标签$(&quot;#id1&quot;);//id$(&quot;.class1&quot;);//类//......(css中所有选择器都适用：基本选择器，层次选择器，伪类，伪元素，属性选择器...)//还有一些筛选方法来过滤children(selector);//子类选择器find(selector);//后代选择器siblings(selector);//兄弟节点parent();//父亲eq(index);//索引next();//下一个兄弟prev();//上一个兄弟 事件鼠标事件，键盘事件，其他事件 1234567891011121314151617181920212223blur()//元素失去焦点change()//用户改变域的内容click()//鼠标点击某个对象dbclick()//鼠标双击某个对象error()//加载文档或者图形时发生错误focus()//元素获得焦点keydown()//用户摁下摁键时发生keypress()//用户摁下摁键，并且产生一个字符时发生keyup()//用户释放某一个摁键时触发load()//某个页面或图像完成加载mousedown(//某个鼠标按键被按下mousemove()//鼠标被移动mouseout()//鼠标从某元素移开mouseover()//鼠标被移到某元素上(子元素也会触发)mouseenter()//鼠标必须点到选取的元素上才触发，注意和mouseover区别mouseup()//某个鼠标按键被松开resize()//窗口或者框架被调整大小scroll()//滚动文档的可视部分select()//文本被选中submit()//提交按钮被点击unload()//用户退出界面//有的函数通过回调函数中的参数获取更多操作的细节：键盘鼠标按键wihch，mouse移动横纵坐标 1234567891011121314151617181920//入口函数//window.onload() 方法用于在网页加载完毕后立刻执行的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。window.onload=function(){//入口函数唯一 Func1(); Func2(); Func3(); ...}//$(document).ready()注意在body中没有onload事件，否则该函数不能执行。在每个页面中可以有很多个函数被加载执行，按照fn的顺序来执行。$(document).ready(function(){//入口函数可以不唯一 alert(&quot;网页已经加载完成&quot;);})//简化为$(function(){ alert(&quot;网页已经加载完成&quot;);}) //window.onload和$(function(){})的执行流程是jQuery先执行//$(function(){})要等待页面上dom树加载完毕后执行，window.onload要等待页面上所有资源都加载完毕后再执行 on注册事件jQuery1.7之后，jQuery用on统一了所有时间的处理方法，之后都建议使用on来注册事件 12345//on注册简单事件，不支持动态绑定$(selector).on(&quot;click&quot;,function(){});//on注册事件委托(selector是子元素的父元素，所以必须是selector的内部子元素才能触发这个事件，支持动态绑定)$(selector).on(&quot;click&quot;,&quot;子元素&quot;,function(){}); 123//使用off()来解绑事件$(selector).off();//解绑所有事件$(selector).off(&quot;click&quot;);//解绑指定事件 事件触发自定义事件发生的时机条件 12345678910//自定义条件的时候执行click函数内容//两种方法都可以。$(selector).click();$(selector).trigger(&quot;click&quot;);//对于自定义事件，就只能使用触发器来了$(selector).on(&quot;jack&quot;,function(){ console.log(&quot;hello,jack!&quot;);})$(selector).trigger(&quot;jack&quot;); 事件对象 什么是事件对象 注册一个事件，系统会帮我们生成一个对象记录这个事件触发时候的一些信息 比如触发事件的时候有没有按住某个键，以及一些坐标信息 jQuery中的事件对象由形参e来获取，jQuery中的事件对象是对js原生事件对象的封装，处理好了浏览器兼容性 123456789101112131415161718$(selector).on(&quot;click&quot;,function(e){ //距离屏幕左上角的值 console.log(e.screenX+&quot; : &quot;+e.screenY); //距离页面坐上角的值 console.log(e.clientX+&quot; : &quot;+e.clientY); //距离页面最顶部左上角的值 console.log(e.pageX+&quot; : &quot;+e.pageY); //阻止事件冒泡 e.stopPropagation(); //阻止浏览器默认行为 e.preventDefault(); //上面两个同时阻止 return false; //按下的键盘代码 e.keyCode; e.which;}) 操作DOM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;ul id=&quot;test-ul&quot;&gt; &lt;li class=&quot;js&quot;&gt;JavaScript&lt;/li&gt; &lt;li name=&quot;python&quot;&gt;Python&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(&quot;#test-ul li[name=python]&quot;).text();//获得值 $(&quot;#test-ul li[name=python]&quot;).html(); $(&quot;#test-ul li[name=python]&quot;).text(&quot;派森&quot;);//获得值 $(&quot;#test-ul li[name=python]&quot;).html(&quot;&lt;em&gt;派森&lt;/em&gt;&quot;);//获得值 $(&quot;input元素名称&quot;).val();//获取input元素的值 $(&quot;input元素名称&quot;).val(value);//设置input元素的值为value $(selector).attr(&quot;属性名&quot;);//获取属性 $(selectorselector).attr(&quot;属性名&quot;,&quot;属性值&quot;);//设置属性 $(selector).removeAttr(&quot;属性名称&quot;);//给某元素删除指定的属性以及该属性的值 $(selector).addClass(&quot;class1 class2&quot;);//给某元素添加指定的样式 $(selector).removeClass(&quot;class1 class2&quot;);//给某元素删除指定的样式 $(selector).toggleClass(&quot;class1 class2&quot;);//给某元素切换指定的样式 $(selector).hasClass(&quot;class&quot;);//判断是否有样式 //对于checked,selected,disabled这类boolean类型的属性来说，不能用attr方法获取属性值，只能用prop方法 $(&quot;input:checked&quot;).prop(&quot;check&quot;);//返回true或false $(&quot;input:checked&quot;).prop(&quot;check&quot;,true); //css操作 $(&quot;#test-ul li[name=python]&quot;).css(&quot;color&quot;,&quot;red&quot;); $(&quot;#test-ul li[name=python]&quot;).css({ &quot;width&quot;: &quot;100px&quot;, &quot;backgroundColor&quot;: &quot;red&quot; }); //显示&amp;隐藏（本质是设定display） $(&quot;#test-ul li[name=python]&quot;).show(); $(&quot;#test-ul li[name=python]&quot;).hide(); $(&quot;#test-ul li[name=python]&quot;).toggle(); //宽高 //不带padding，margin和border height();//直接返回200，没有px，如果用css返回值带px单位 height(100);//不带单位默认px widtn(); //带padding innerWidth(); innerHeight(); //带padding和border outerWidth(); outerWidth(); //带padding，border和margin outerWidth(true); outerWidth(true); //获取网页可视区的宽高 $(window).width(); $(window).height(); //增删改DOM元素 //方法1(直接显示在页面上) $(&quot;元素&quot;).html(&quot;html标签内容&quot;); //方法2(通过下列方法追加) var dom1 = $(&quot;html标签内容&quot;); $(selector).after(content);//在匹配元素后面添加内容 $(selector).append(content);//将content作为元素的内容插入到该元素内的最后 $(selector).appendTo(content);//和append方向相反 $(selector).before(content);//与after方法互换 $(selector).prepend(content);//将content作为该元素的一部分，放到该元素的最前面 $(selector).prependTo(content);//和prepend方向互换 $(selector).insertAfter(content);//将该元素插入到content之后 $(selector).insertBefore(content);//将该元素插入到content之前 $(selector).remove();//删除所有的指定元素,自杀（本质上还是先找父再删自己） $(selector).remove(&quot;exp&quot;);//删除所有含有exp的元素 $(selector).wrap(&quot;html&quot;);//用html来包围该元素 $(selector).wrap(element);//用element来包围该元素 $(selector).clone(布尔表达式);//当布尔表达式为真时，克隆元素（无参时，当作true处理） $(selector).empty();//将该元素的内容设置为空 //克隆 $(selector).clone(true/false);//返回元素的一份副本，参数代表是否把事件一起克隆，默认时false //offset &amp; position //offset获取元素距离document的位置，返回值为对象[left:100,top:100] $(selector).offset(); //position获取相对于其最近的有定位的祖先元素的距离 $(selector).position(); //scrollTop &amp; scrollLeft //设置或者获取垂直滚动条的位置 $(window).scrollTop(); $(window).scrollLeft(); //也可以带参数设置滚动条滚动的距离&lt;/script&gt; 动画12345678910111213141516171819202122232425262728293031323334 //显示 &amp; 隐藏动画 $(selector).show(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数}); $(selector).hide(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数}); $(selector).toggle(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数}); //其他动画 $(selector).slideDown(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//下滑生成 $(selector).slideUp(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//上滑消失 $(selector).slideToggle(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//反复横跳 $(selector).fadeIn(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//淡入 $(selector).fadeOut(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//淡出 $(selector).fadeTo(参数1:毫秒数/'fast'/'normal'/'slow',参数2:透明度,参数3:function(){动画执行完后的回调函数});//淡入到哪里 $(selector).fadeToggle(参数1:毫秒数/'fast'/'normal'/'slow',参数2:function(){动画执行完后的回调函数});//反复横跳 //自定义动画 /*参数： 参数1：需要做的动画属性 参数2：执行动画的时长 参数3：缓动swing or 匀速linear 参数4：动画执行完毕后的回调函数 */ $(&quot;元素&quot;).animate({ left: 800, width: 200, height: 300, opacity: 0.5 },2000,'linear',function(){ alert('动画执行完毕了'); //这里面又可以继续animate，无线套娃 });//因为都设置了动画的时间，所以存在一个动画队列，即使操作已经结束，但是动画可能并没有结束，导致交互很糟糕，需要在操作结束时stop动画stop(true,true);//参数1：是否清除队列；参数2：是否跳转到最终效果 多库共存12345678910111213141516//查看jQuery版本console.log(jQuery.fn.jquery);console.log(jQuery.prototype.jquery);console.log($.fn.jquery);console.log($.prototype.jquery);//引入多个jQuery文件，使用的是哪个版本的？//哪个文件后引入就使用的那个版本的 $对象 和 jQuery对象 //多库共存$.noConflict();//主动把当前自己版本的$控制权释放掉console.log(jQuery.fn.jquery);console.log($.fn.jquery);//这样上面就是两个版本的jQuery了，实现了多库共存//同时noConflict返回原来的版本_$var _$ = $.noConflict(); 插件jQuery插件搜索网站：https://www.jq22.com/ 123456789101112131415161718192021222324//常用jQuery插件：颜色插件，省市联动插件，jQuery ui插件/*自己开发jQuery插件 1. 给jQuery原型添加方法 2. 给jQuery直接添加方法*/(function($){ //给jQuery原型添加方法(jquery.fn = jquery.prototype ) $.fn.bgColor(bg_color){ //this是调用这个bgColor方法的jQuery对象 this.css(&quot;backgroundColor&quot;,bg_color); return this;//为了能链式编程 }}(jQuery))(function($){ //给jQuery原型添加方法(jquery.fn = jquery.prototype ) $.bgColor(bg_color){ //this是调用这个bgColor方法的jQuery对象 this.css(&quot;backgroundColor&quot;,bg_color); return this;//为了能链式编程 }}(jQuery)) jQuery支持链式编程 原因：因为很多jQuery方法直接返回 当前的jQuery对象，所以可以接着 . 出方法； 不返回jQuery对象的方法：val(),html(),text(),attr(), 返回文本字符串； 返回新的jQuery对象的方法：next() nextAll() parent() children() prev() … 剩下基本都是返回当前jQuery对象； 1$(&quot;div&quot;).width(200px).height(100px).css(&quot;backgroundColor&quot;,&quot;red&quot;).text(&quot;哈哈&quot;); jQuery的很多操作通过实践中自己总结。","link":"/2021/01/13/%E7%B2%BE%E7%AE%80%E7%89%88JS-jQuery/"},{"title":"浅谈日清1894海战（二）","text":"上篇文章简单谈了下洋务运动的时代背景，北洋水师就是在19世纪中叶后的这样一个科技，政治大变革时代下诞生的。这次主要谈谈甲午战争中的大东沟海战，从一场海战放开来看，日本和清国之后的命运似乎就能说得通了。 先看战前。朝鲜内战，清朝以宗主国的身份入朝作战（主要是淮军）。此时，走上帝国主义道路的日本按照福泽谕吉的大陆政策，第一步正是朝鲜。在甲午战争正式爆发前的这个阶段，随着日本源源不断的向半岛派兵，日本逐渐掌握优势。清廷上的一群键盘侠就开始炮轰李鸿章，以前受洋人欺负，现在连日本也打不过，你李鸿章还想讲和。李鸿章心里清楚，此时的清军里就那么几个地方军能打仗，朝鲜战事上非淮军不可，用淮军和日本现代化军队打，无论是出于自保还是现实，避战都是正确的，在外交上依靠英法俄在华利益制衡日本相比之下更合适。奈何光绪也是年轻气盛，权力好不容易回来了（1889年，慈溪试探性地交还权力给了光绪），有大做一番的雄心壮志，加上一部分人的鼓动，不顾李鸿章反对，向日本宣战。国家统治层没有一套现代化的完备的战略决策制度，朝堂仪事+皇帝拍板定案的形式局限性很大。清廷统治层这种只图嘴上痛快就将一个国家推向战争的做法是极不负责的。 再看战时，甲午战争分为陆战和海战，这里谈的是海战中的大东沟海战。主要从军费，军舰（航速，射速，炮弹，老化），战术，官兵，情报几个角度简单谈谈： 先说军费：北洋水师成立的初衷就是一支防御性质的舰队，他的作用是守住京畿海口，配合陆军作战，这就限制了其规模上限。1888年建立初的北洋水师是亚洲最强舰队这一点不假，但是之后几乎未新添一舰，反观日本，虽然前期比不上北洋水师，但是直到1894开战，几乎一直在接收新式军舰。海军是一个需要长期投入才能起到效果的军种，更何况是在海军装备更新换代的关键时期（可以说甲午海战也是之后战列舰发展方向的参考案例）。再说清廷内部的问题，李鸿章和户部尚书翁同龢的私仇，海军衙门高层的人事变动，我觉得也是导致北洋水师后期装备停止更新的重要原因。 再说军舰：北洋水师的核心就是两艘德国制造的7000t铁甲舰，其他的都是2000t左右中规中矩的炮舰。由于年久未修的主观因素和装备革新的时代客观因素，开战前的航速已经明显下滑并落后于时代；火炮在开战前已经和日本形成代差；北洋水师炮弹配置上多为穿甲弹，少有开花弹，与之相比是日本的下濑火药。这些致命问题的根本原因就是军费没有跟上，五年陆军，十年空军，百年海军，这话不是没有道理，更何况是处在“铁甲舰到前无畏舰”的关键过渡时期。 10艘舰艇两两相伴，凭借定镇两舰打头阵冲进敌阵，然后再各自搏杀，寻找机会冲撞。日本这边的舰艇有几艘快速巡洋舰，组成了第一分队，航速远高于北洋舰队，快速绕道北洋侧翼集火超勇扬威，整场战争日本联合舰队没有给北洋水师留近身的机会，一直保持在一定距离利用速射炮快速倾泻弹药。可见，装备很大程度上决定了战术，不同的历史时期下的装备和战术结合产生的结果可能恰恰相反。 官兵素质上，据最新的历史考证发现，整个大东沟海战中，北洋水师的命中率是要高于日本的，甚至不输同时期的欧美海军。北洋海军雇佣洋人教官，模式也采用西方标准，虽然后期撤换掉了郎威理，但北洋水师多年的严格训练是很有成果的。从海战中的实际表现上来看，北洋海军的绝大部分官兵的表现确实都是值得肯定的。 间谍战是最容易被忽视的战争形式，据史料解密，甲午战前活跃在中国的日本间谍数量惊人，其伪装程度很高，通过各种手段获取了大量军事情报。 大东沟海战之后，虽然北洋舰队损失很大，但是家底还是有的，尚有一战之力，奈何陆军增援始终不到，等于是放弃了威海卫，最终难逃覆灭。 不管如何，1894年，大清还能倚靠李中堂的北洋水师在海上和日本真刀真枪地干一场，可谁又能想到，短短6年后，八国联军从中国的内海长驱直入直达紫禁城，讽刺的是，攻占京城时不少大清子民争着给洋人带路，诚然，“普天之下，莫非王土，和我有什么关系”，中国几千年的朝代更迭，底层百姓仍然只是过客。或许，大清只是败给了时代。","link":"/2020/06/24/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"浅谈日清1894海战（一）","text":"“威海卫陷落，北洋舰队全军覆没标志着洋务运动的失败”，这是历史课本记述的那场战争，语文课本和影视作品中关于邓世昌率致远全舰撞击吉野的描述同样深入国人心。提起甲午，大家会想到很多关键词，然而，120多年前，围绕这场战争，当时的日本和大清的都是一个怎样的状态。1888年北洋海军建立，其实力一举被列强排位世界海军前10，是什么原因导致短短6年后被清人口中的矮子日本胖揍，再六年，八国从中国内海长驱直入，直取京畿。 1864年，持续十多年的太平天国运动结束。太平军本来是有能力推翻清王朝的，为什么没有？我觉得一方面是太平天国内部在起义运动后期统治层之间的分裂和战略分兵错误。另一方面，慈溪放开部分军权，让地方练兵，曾国藩的湘军就是镇压太平天国的主力，李鸿章的淮军同样源于此。太平天国结束后，加上之前两次鸦片战争的失败，慈溪支持的洋务派压倒了守旧派，其实慈溪这时很很清楚，如果不做出点改变朝廷只有死路一条，这也是她一开始支持维新变法的原因，但是这里的矛盾就是你改革可以，但是不能威胁慈溪的绝对统治，不然慈溪绝对搞死你。 洋务运动从19世纪60年代开始，持续了大约30年。我们可以看看这个时间段，世界上其他国家在干嘛？1861—1865年，美国通过南北战争实现实质统一。1871年，俾斯麦带领德国走向统一并在普法战争中击败法国。法国虽然在普法战争中战败，但是由于国库殷实，之后迅速复兴。英国在第一次工业革命后成为世界第一强国，正在全世界扩张。日本从1868年开始明治维新。沙俄1856年在克里米亚战争中失败开始搞农奴制改革。可见洋务运动这30年清国周边相对太平，也给了这个机会。但是，要知道，从60年代后期开始，第二次工业革命开始，与第一次几乎英国独享不同，这次是英德美法遍地开花。在其他列前纷纷崛起的19世纪，倡导“中体西用”的洋务运动注定不会一帆风顺。 洋务运动是一场大工程，在慈溪的授权下，中央是以奕昕为代表的满族官员。地方是以林则徐，魏源，左宗棠，曾国藩，李鸿章，沈葆桢，张之洞等等为代表的地方汉族官员。其涉及面较广，我要谈的围绕大清国海防建设，注意，是海防，不是海权。当时的清国，能有诸如李鸿章这样的洋务派的思想就已经很不错了，他们要的是建立海军守住海疆继续封建，没有一个海权的认识。 “师夷长技以制夷”，洋务派随即开始筹备海军建设。最开始的想法就是买，但被英国人李泰国摆了一道。之后沈葆桢逐渐意识到得自己建船厂，海军基地，同时培养自己的海军将领。于是在法国人的帮助下建立了马尾船厂，海军基地和船政学堂，聘请英法教师教学。在这里培养了中国第一批近代海军人才，也可能第一批睁眼看世界的中国人。 这些人当中很多留学英法，是那个时代西方世界中唯一的中国面孔。他们有的成了外交官，有的做了船政讲师、船舶设计师，但大部分都是之后北洋舰队的主要将领。当时的他们并不知道，身处时代浪潮下，自己将会何去何从。 1869年，自主建造的蒸汽化炮舰万年清号下水，1888年，自造铁甲舰平远号下水编入北洋水师。短期来看，洋务运动在海军上的建设很有效果，和同时也在建设海军的日本比起来至少在效果上甚至要更好。但是，清帝国的体系承自千年，已经是集权制的顶峰，正因如此，在人类历史最大变革的19世纪，肯定没有幕府统治下的日本好掉头，更何况倒幕运动已经把明治天皇请回来进行几乎全盘的西化。所以，长期来看，日本对中国的优势从这时就开始了，日本的野心也开始显现。 1874年，日本以琉球事件为借口发动了对台湾的军事行动，这次事件以大清承认日本对琉球的主权和赔款而告终。这次事件刺激了清廷，随机决定创办北洋水师和南洋水师。1884年，中法战争爆发，法国人偷袭了马尾，南洋水师全军覆没。1894年，日本趁着朝鲜内乱，跨海发兵。在牙山和丰岛两次海陆失利后，9月17日，护送运兵船支援平壤战役的北洋海军编队和在海上寻找决战的日本联合舰队在大东沟外海相遇，黄海海战爆发。海战历时5小时，北洋方面被击沉5艘，退回威海卫，失去制海权。关于这场海战的评价有很多，有说编队雁形阵错误的，有说北洋官兵军纪差的，有说慈溪挪用海军军费的，有说劣质炮弹的，诸如此类。海战战术层面上，国家制度落后就必败这类话没有任何意义，要尽可能准确地了解这场战争失败的直接原因，还得实事求是，从实际出发多方面分析。（接下文）","link":"/2020/06/22/%E6%B5%85%E8%B0%88%E6%97%A5%E6%B8%851894%E6%B5%B7%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"股票入门","text":"理财的几种投资渠道： 银行利息 年利率1.5% 银行的利率跑不赢通货膨胀 证券投资：股票 收益高 波动很大，技术要求大 房地产投资 基金 收益低点：货币基金，纯债基金 收益高点：股票型基金，混合型基金 一些概念： 债券：别人买你，还你利息 股票：共同分享开公司的成果 A股：中国大陆公司发行的股票 指数：一家公司一只股票，多支股票组合形成指数 大盘（上证指数）：在上海债券交易所上发行的所有股票组合 小盘（中证500指数）：选取了500家中小公司的股票组合 基金：由基金公司拿我们的钱，帮我们买股票，债券，帮助我们打理我们的钱 我们不会理财，可以找大的基金公司（天弘，富国……），千万不要找P2P 关于基金Fund的一些概念开放式基金（随买随卖）按照投资类型一般分为： 股票型：风险较高收益较多 债券型：风险较低收益较少 混合型：股票+债券 货币型：风险最小，收益最少。投资于货币市场的基金。例：一年以内的银行定期存款，剩余期限397天以内的债券 经济 &amp; 金融 ？ 经济 一次性的买卖，为了自己消费 供需定价 金融 买家炒来炒去，为了自己赚钱 预期决定价格，大家看涨它就涨 股票分类： A股，B股，H股，N股，S股 一般做的都是沪深A股（上海证券交易所 &amp; 深圳证券交易所） 60开头——上证A股 0开头——深证A股 3开头——创业版（证券公司去开通） 688开头——科创版（最低50W资金） 股票交易时间 周一到周五（09:30-11:30，13:00-15:00） 周六周日休市，法定节日休市 09:15-09:20：随便挂单随便撤单 09:20-09:25：随便挂单不可撤单 股票的涨跌幅 0和60股票每天涨跌幅是10% 3股票每天涨跌幅是20% 68股票前5个交易日无限制，后面涨跌幅是20% 新股第一天涨跌幅44% ST股（亏损股）：涨跌幅是5% 股票分时图和K线图 股票交易规则 股票最低买1手=100股，不同上市股票每股价格不同 股票交易费由三部分组成：佣金，印花税，过户费（仅上股收取） 印花税：0.1% 过户费：0.002% 交易佣金：最高0.003%，最低5元 交易佣金是双向收取：买 &amp; 卖 看盘软件界面介绍 股票趋势 顺势而为，不能和大盘逆向操作 尽量做上涨趋势的股票 支撑位和压力位 突破和跌破 股票盘口 股票买卖机制 自己通过各种软件买卖软件中的模拟买卖来练习 选股票 做空（Short Selling）是啥？ 做多： 股票上升时，低价买入，高价卖出。 利润无限，亏损有限。 做空： 股票下降时，高价卖出，低价买入。 从证券公司借股票。高价卖出，低价买入；然后还给证券公司股票，赚差价。 利润有限，亏损无限。","link":"/2021/05/15/%E8%82%A1%E7%A5%A8%E5%85%A5%E9%97%A8/"},{"title":"经济学原理学习","text":"经济学入门宗旨：没有对的经济学理论，只有好的经济学理论 Let‘s Go 经济学演变 自给自足，没有交换 开始分工，根据劳动量交换产品 随着生产力发展，更多的产品生产出来，产生货币：从商品中分离出来充当一般等价物的商品，专门用于交换（吾以吾之所有予市场，换吾之所需，货币就是这一过程的约定，它反映的是个体与社会的经济协作关系） 交换促进了分工，分工带来了生产率提升，反过来又促进了交换 交换的前提是交换双方彼此信任。 货币要么是具有稀缺性，要么背后有强权背书。所以一旦遇到乱世，大家都会把货币兑换成普通商品或者硬通货。 早期交易体系：以铜币为基础的弱信用链（谷物，绢帛，铜钱） 早期铜钱货币交易体系中，铜钱较稀缺，铜钱铸造速度&lt;生产率提高速度，市场流通货币减少，货币增值，商品价格下降，会导致通货紧缩 经济由所有市场内的全部交易构成 信任是分工的基石人类社会的每次变革，都伴随着社会信任关系的重构： 部落内的分工：私人信用体系 国家内的分工：政府信用体系 国家间的分工：银行信用体系 任何交易都依赖于信用体系：所以理论上，只要构建一个足够完善的信用链将所有人纳入其中，就能让更多的人参与交换活动，从而让更多的交易达成，经济得到发展 但是由各种问题阻碍这种理想信任链的形成：分配问题，国家对抗，金融危机…… 现代经济学以银行发放贷款创造出存款货币的银行信用货币体系 政府：负责收税，花钱 中央银行：负责控制货币，信贷数量（通过利率和发行货币） 经济学三类问题： 人们如何作出决策（微观） 人们如何相互作用（微观） 整体经济如何运行（宏观） 经济学的十个原理：人们如何作出决策？ People face tradeoffs：人们面临得失交换 The cost of somothing is what you give up to get it：某物的成本是为此所放弃的东西 Rational people think at the margin：理性人考虑边际量 People respond to incentives：人们会对激励作出反应 人们如何相互作用？ Trade can make everyone better off：贸易使人人收益 Markets are usually a good way to organize economic activity：市场是组织经济活动的好方式 Governments can sometimes improve market outcomes：政府有时可以改进市场结果 整体经济如何运行？ The standard of living depends on a country’s production：一国的生活水平取决于它的生产 Prices rise when the government prints too much money：当政府发行了过多的货币时，物价上涨 Society faces a short-run tradeoff between inflation and unemployment：社会面临通货膨胀和失业之间的短期得失交换 经济学历史： 古希腊经济思想：家庭理财 重商主义经济理论（大航海时代）：商业贸易和财富(金银)积累，鼓励出口限制进口 古典经济学的理论（亚当斯密，李嘉图，马克思）：财富的性质与原因：交换，分工，市场 新古典经济学理论：资源配置及优化问题：Math被广泛应用到经济领域 经济学的帝国主义：人类选择行为，经济学扩展到其他社会科学领域 经济学分类 非常非常多（&gt;1000种） 微观经济学，宏观经济学，计量经济学 怎么学？ 经济理论 数学工具（统计，微积分） 经济史 经济学原理正式开始经济：为取得经济品有代价的活动就是经济 经济学：研究人们如何利用稀缺资源来满足人们无限需求的一门社会科学 经济学的两个基本假说：（经济学是经过实践检验的假说） 经济人：每个人都会有个性追求，是一个理性人；消费者满足最大化，生产者利润最大化。 信息完备性：】 经济学常用的解决问题的方法：表格、图线、文字、数学函数 在资源一定的情况下，所能够生产的两种商品的最大组合的运动轨迹，就是生产可能曲线 微观经济学研究对象： 以价格为核心，用价格衡量资源稀缺性，也就导致了供求关系 以单个经济单位为研究对象：消费者和生产者 研究单个经济单位的经济行为：消费者怎么满足最大化 &amp; 生产者怎么利润最大化 解决资源的配置问题：生产什么？生产多少？为谁生产？ 怎么学？ 两种研究方法： 实证经济学：就事论事 规范经济学：就事论理 欲望和需求需求是消费者在一定时期内，在一定价格水平上，愿意购买而且能购买的商品量。 需求=欲望+钱，满足其一是潜在需求，同时满足是有效需求 有效需求 可以代表 市场容量 需求的影响因素： 商品本身价格（最重要） 收入水平 偏好 相关商品的价格：互补品、替代品、独立品 未来预期 需求的规律：（通过价格） 文字表达：其他因素不变的情况下，消费者对某种商品的需求量和商品本身的价格呈反向变动的关系 需求表：价格和数量两行 需求曲线：横轴Q，纵轴P；需求曲线 需求函数：Q=f(P)；Q=a=b×P 个人需求的加和就是市场需求 需求规律的例外： 价格稳定不变：黄金、紧俏物资 需求稳定不变：生活必需品（盐、药、厕所） 价格需求呈正比：高档消费品、奢侈品 毫无规则：金融产品（债券、基金、股票、期货）只有行家，没有专家 非价格因素对需求的影响 宏观经济学","link":"/2021/05/15/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/"},{"title":"计网-应用层","text":"域名系统DNS QQ客户端能登录，但是QQ网站打不开，可能说明DNS出问题了 域名服务器采用分布式的域名查询解析 我个人认为这里的本机缓存指的是本机的DNS缓存，访问网站的时候是先查询本机缓存，再查询hosts配置，之后才去请求本地DNS缓存。 动态主机配置协议DHCP 静态IP地址：手动配置 一般固定的台式机 动态IP地址：通过DHCP协议自动获得 一般的移动的设备，例如wifi连接的笔记本电脑 计算机通过广播向DHCP服务器发送广播请求，DHCP服务器从地址池里选择一个地址给计算机发过去。如果同时有多个DHCP服务器应答，计算机还要选择一个DHCP服务器发一个确认信息，然后DHCP服务器才能把所有设置给计算机。 DHCP服务器要是静态地址，一般只给本网段的计算机分配地址。 了解租期和续约 除了同网段的DHCP分配，还可以跨网段DHCP分配 对比RARP逆向地址解析协议：从功能上说，RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。 文件传送协议FTP 控制连接：标准端口21，用于发送ftp命令信息 数据连接：标准端口22，用于上传下载数据 数据连接的建立类型： 主动模式：ftp客户端告诉ftp服务器使用什么端口侦听，ftp服务器和ftp客户端的这个端口建立连接 被动模式：ftp服务器打开一个端口等待客户端来连接 FTP服务器端如果有防火墙，需要在防火墙上开21和20端口，需要使用主动模式进行连接 远程终端协议TELNET 默认使用TCP 的23端口 远程桌面RDP net user administrator all 更改用户密码 net user han all /add 添加用户 将用户添加到远程桌面组 Remote Desktop Users组 Server多用户操作系统，启用远程桌面可以都用户同时使用服务器 XP和Windows 7是单用户操作系统，不支持多用户同时登录 远程时可以将本地的硬盘资源映射到远程计算机上 万维网WWW 一个网站的标志：可以通过不同端口，不同的IP地址，不同的主机头（域名）来区分； tomcat服务器部署了多个项目，阿里云的域名解析到服务器ip，可以通过配置，让不同域名解析访问不同的项目。 http协议 web代理服务器 节省内网访问Internet的带宽 使用代理服务器连网关，DNS都不需要，只需要和代理的服务器通信就行了，所有访问Internet的工作都是代理服务器做的。 能绕过防火墙直接访问墙外的网站，这是一种正向代理 电子邮件（SMTP，POP3，IMAP）发送协议：SMTP接收邮件协议：POP3，IMAP 注意： DNS占用53号端口，同时使用TCP和UDP协议。DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。 DNS区域传输的时候使用TCP协议： 1.辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 2.TCP是一种可靠连接，保证了数据的准确性。 域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E5%BA%94%E7%94%A8%E5%B1%82/"},{"title":"英语语法框架构建","text":"Simple Sentence：主语+谓语 可以独立完成的动作：不及物动词Intransitive Verbs 主语+不及物动词 有一个动作的承受者：单及物动词Monotransitive Verbs 主语+单及物动词+宾语 有两个动作承受者：双及物动词Ditransitive Verbs 主语+间接宾语+直接宾语 只有一个动作承受者（不同于2）：复杂及物动词Complex-Transitive Verbs 主语+复杂及物动词+宾语+宾语补语 不是狭义的”动作“：系动词Linking Verbs 主语+系动词+主语补语(表语) Parts Of Speech：句子成分 Subject：主语 Predicate Verb：谓语动词 Object：宾语 Object Complement：宾语补语 Subject Complement（Predicative）：主语补语（表语） Attributive：定语—修饰主语/宾语 Adverbial：状语—修饰谓语动词 Appositive：同位语—再把主语/宾语说一遍 Non Simple SentenceCompuond Sentence：Simple Sentence+Simple Sentence… Complex Sentence：Main Clause（主句）+Subordinate Clause（从句） Subordinate Clause 主语从句 宾语从句 表语从句 同位语从句 定语从句 状语从句 词类 Nouns：名词 Articles：冠词 Pronouns：代词 Adjectives：形容词 Numerals：数词 Adverbs：副词 Prepositions：介词 Interjections：叹词 Conjunctions：连词 Verbs：动词 注意：对于句子成分和词类的关系而言，除了谓语动词只能用动词，其余句子成份都可能包含不同的词类 Predicate Verbs’ Big Three（谓语动词的三大本领） 表示动作的时间：Tense 现在 过去 将来 过去将来 表示动作的状态：Aspect 一般 完成 进行 完成进行 表斯动作的假设，情感等：Mood 虚拟语气：If i were a boy … 陈述语气：I ate a carrot and … 祈使语气：Eat this carrot and … 谓语动词充分发挥功能，需要助动词的帮助 注意：不要把助动词和它的其他身份（实义动词）混淆 Non Predicate Verbs注意：正如上面介绍词类和句子成份的关系时所讲，动词除了可以充当谓语动词这个句子成份，还可以充当其他任意一个句子成份，这些统称非谓语动词Non Predicate Verbs 动词不定式 现在分词 动名词 过去分词 重点：非谓语动词可以充当除谓语动词外所有句子成份，取代所有从句，从而简化句子。 只是这些动词就不再具有表示动作时间，状态，语句的功能了。 总结English Grammer的核心就是动词：","link":"/2021/05/17/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA/"},{"title":"计网-无线网络","text":"无线网络的比较 PAN：蓝牙 LAN：WiFi MAN：WiMAX WAN：2G，3G，4G，5G 以无线AP（无线交换机）为中心的无线局域网 最原始的单计算机拨号上网： 要实现一个局域网网段的多计算机同时上网，加入一个无线路由器来实现： 通常所说的所谓“无线路由器”实际上是一个三合一设备：路由器功能+交换机功能+无线AP功能 左边教室的所有机器按照上述能上网，右边教师的也想并入左边的网段上网，只需要把右边的无线路由器当作一个路由器来使就行了，拿一根网线把两个交换机连接起来，同时右边的无线设备也可以通过以无线AP为中心的无线局域网并入左边教室的网段。 还有一种无线网络是不需要无线AP接入设备的：临时的无线网络 手机通过3G,4G,5G来上网的原理： 手机打电话的方式：从最近的基站注册然后发出通信，基站之间通过光纤或者其他线连接。手机移动位置的时候需要连接新的基站，然后就会更新基站数据库 上网就是通过基站的光纤连接的网关来访问Internet，2G,3G,4G,5G，一代比一代的带宽高","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"},{"title":"计网-数据链路层","text":"数据链路层基本概念及基本问题基本概念 两种信道类型： 点到点信道 广播信道 链路和数据链路：链路是物理层，数据链路包含物理层和数据链路层 帧：在网络层包的基础上增加头和尾 三个基本问题封装成帧 在网络层数据报基础上+帧首部&amp;帧尾部，帧的数据部分MTU≤1500Byte 透明传输 用字节填充法解决透明传输问题 差错控制 传输过程中可能会有比特差错（0变1或者1变0），误码率 循环冗余检验CRC（除数由数据链路层协议确定）,通过CRC算法生成FCS帧检验序列 不纠错，有错误直接丢掉（重传不是数据链路层管的事情） 有可能出错也检查不出，CRC不是可靠传输 两场情况下的数据链路层使用点对点信道的数据链路层（PPP协议） 例子：拨号上网 特点：简单，封装成帧，支持多层网络协议，多种类型链路，差错检验，检测连接状态，最大传送单元，网络层地址协商，数据压缩协商 由三部分组成： 一个将IP数据报封装到串行链路的方法； 一个用来建立、配置和测试数据链路连接的链路控制协议LCP； 一套网络控制协议NCP，其中的每一个协议支持不同的网络层协议 PPP帧格式 解决透明传输：传输比特（零比特填充法），传输字节（字节填充） PPP协议工作流程 当用户拨号接入ISP后，就建立了一条从用户PC机到ISP的物理连接。 这时用户PC机向ISP发送一系列的LCP分组(封装成多个PPP帧)，以便建立LCP连接。 这些分组及其响应选择了将要使用的一些PPP参数。 接着还要进行网络层配置，NCP给新接入的用户PC机分配一个临时的IP地址。 这样，用户PC机就成为因特网上的一个有IP地址的主机了。 当用户通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。 接着，LCP释放数据链路层连接。 最后释放的是物理层的连接。 PPPoE:一种建立在以太网上的点到点的隧道技术。以太网本身是基于广播的，无法提供可靠的点到点支持，PPPoE解决了这个问题，在以太网上提供了可靠的点到点连接，可以让运营商验证你的身份并予以计费。 使用广播信道的数据链路层（以太网的CSMA/CS协议） 局域网的拓扑：星形网，总线网，树形网，环形网 共享通信媒体： 静态划分信道：频分/时分/波分/码分复用 动态媒体接入技术：随机接入（以太网），受控接入 多点接入，载波监听 碰撞检测，发现冲突最长时间是2焘 半双工通信 2套=51.2微秒=1争用期=基本退避时间；10Mb/s的以太网争用期发送512bit（64Byte），前64字节没有发现冲突情况，之后也就不会有冲突了。所以10M以太网中最短有效帧为64字节。 退避算法 以太局域网 两个标准：Ethernet V2和802.3 用集线器组以太局域网 以太网信道利用率 MAC层的硬件地址：48位二进制（前24为代表厂家，后24为厂家自己指定） 网卡从网络上每收到一个MAC帧就会用硬件检查MAC帧中的MAC地址，如果是发往本站的帧则收下，其他的丢弃。包括单播帧，广播帧，多播帧 一个局域网不能出现两个相同的mac地址，因为mac可以手动指定自定义的mac地址 帧间最小的间隔时间为9.6微秒，是为了使刚刚收到的数据帧站的接收缓存得以清理，做好接收下一帧的准备 扩展以太网 物理层的扩展 用集线器连网最多不要超过30台机器，否则效率极慢 数据链路层的扩展 网桥：有一个mac记忆表，可存储（来源）转发（目的），可以隔离冲突域 透明网桥：以太网上的站点不知道所发送的帧将经过那几个网桥，是一种即插即用的设备——自学习 源路由网桥：在发送帧时，把最详细的最佳路由信息（路由最少/时间最短）放在帧的首部中。（通过发送 ’ 发现帧 ‘ 来寻找最佳路由信息） 交换机：可以看作多口网桥。基本上每个口直接连一台机器，一台机器一个冲突域，也就是没有冲突了。可以实现全双工。 交换机的mac表的生成的流程： A 先向 B 发送一帧，从接口 1 进入到交换机。 交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧。 交换机把这个帧的源地址 A 和接口1 写入交换表中，并向除接口1以外的所有的接口广播这个帧。 C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧。这也称为过滤。 从新写入交换表的项目 (A, 1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是A，就应当把收到的帧从接口1转发出去。 B 通过接口 3 向 A 发送一帧。 交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给A的帧（即目的地址为 A 的帧）应从接口1转发。于是就把这个帧传送到接口 1 转发给 A。显然，现在已经没有必要再广播收到的帧。 交换表这时新增加的项目 (B, 3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。 经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号（2 或 4）写入到交换表中。 考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。 理解冲突域和广播域的区别（对于集线器，交换机，路由器） 虚拟局域网： LAN局域网：用集线器组成的一个网段就是一个LAN VLAN虚拟局域网：用交换机组成的每个网段之间又可以组成新的一个个网段，就是虚拟局域网（相当于n刀把交换机分成n+1段） 高速以太网 速率达到100Mb/s以上的以太网成为高速以太网 100BSSE-T以太网全双工，不使用CSMA/CS协议，因为可以在接口处排队 帧间时间间隔变为0.96微秒 半双工/全双工&amp;集线器/交换机 集线器只能实现半双工。全双工的网络必须要使用交换机组网。 集线器，是共享带宽型网络设备，它本身没有数据处理能力，不能实现点到点的连接，所以不能实现全双工。虽然集线器可以使用双绞线，提供了两对线，但在任一时刻，只能有一对线工作，所以集线器只能是半双工的，不可能是全双工的。除非它带有部分交换机的功能。 交换机，是独享带宽型网络设备，它本身有类似PC机CPU的数据交换处理器，能够识别连接到交换机各端口上的网络设备的MAC地址，能够实现点到点的专用连接，所以能够实现全双工操作。 注意：如果要实现全双工，交换机的端口不能和集线器相连，否则这个端口也只能工作在半双工状态下。交换机具有自动识别全双工和半双工状态的功能。(如上图)","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"title":"计网-概述","text":"计算机网络在信息时代的作用连通性，信息共享，软硬件共享 因特网概述 网络 network：结点（计算机，交换机）+链路 互联网 internet（数量距离相对网络增大）：网络+路由器 因特网 Internet：全球最大的互联网 因特网发展三个阶段： ARPANET向互联网发展 三级结构的因特网（校园网，地区网，主干网） 多层次的ISP结构的因特网 因特网的标准化工作由因特网协会定义：因特网研究部，因特网工程部 因特网组成 C/S：客户机/服务器下载东西，客户机越多下载越慢 P2P：结点越多下载越快 电路交换：需要建立连接搭建专线（建立连接-》通话-》释放资源），适用于实时通讯（打电话） 分组交换：不需要建立连接，没有专线。将一个报文拆分为多包，每一个包不一定走同一条路。路由器由存储转发的功能。但是比电路交换延迟更大。 报文交换：和分许交换类似，但是不用拆分。 计算机网络在我国发展1994年4月20日PRC接入互联网 计算机网络的类别 局域网：自己购买设备，自己维护，带宽固定。 广域网：花钱买服务，花钱买带宽。 计算机网络的性能 速率：连接在计算机网络上的主机在数字信道（一个接收端到一个发送端）上的传送位数的速率。b/s,kb/s,Mb/s,Gb/s 带宽：数字信道所能传送的最高数据率。b/s,kb/s,Mb/s,Gb/s 吞吐率：单位时间内通过某个网络的数据量（总的）b/s,Mb/s 时延：发送时延，传播时延，处理时延，排队时延 时延带宽积：传播时延✖带宽（一个信道承载数据能力） 往返时间：从发送方发送数据开始，到发送方收到接收方确认 利用率：有数据通过时间/(有无)数据通过时间 非性能指标：费用，质量，标准化，可靠性，可扩展性，可升级性，管理与维护 计算机网络的体系结构 分层的原因：标准化并降低每一层的相互关联 OSI7层 应用层：能够产生网络流量，能和用户交互的应用程序 表示层：加密，压缩，编解码（开发人员需要考虑的问题） 会话层：服务器和客户端建立的会话（可以用来查木马：netstat -nb）木马一般时隐藏盗窃信息 传输层：可靠传输(建立会话)，不可靠传输(QQ发消息，广播发送)，流量控制 网络层：IP地址编址，选择最佳路径 数据链路层：数据如何封装，添加物理层mac地址 物理层：电压，接口标准 网络排错：从底层往高层排错 网络安全和osi参考模型 物理层安全(连线安全) 数据链路层安全(ADSL和AP密码) 网络层安全（网关对某些网段的ip限制访问外网） 应用层安全（SQL注入漏洞，上传漏洞） 应用层 传输层 网络层 数据链路层 物理层 应用程序（传输数据单元PDU） 段（报文） 包（数据报） 帧 比特流","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E6%A6%82%E8%BF%B0/"},{"title":"计网-物理层","text":"物理层的基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流 主要任务时确定与传输媒体接口的一些特性 机械特性：接口形状，大小，引脚数量 电气特性：电压范围 功能特性：例如规定-5V表示0，+5V表示1 过程特性：连接时各个部件的工作步骤 数据通信的基础知识 消息：具有意义的数据 数据：运送消息的实体 信号：数据的电气或电磁的表现 模拟信号：消息的参数取值时连续的 数字信号：消息的参数取值是离散的 码元：在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元，而这个间隔被称为码元长度 码元长度：1码元可以携带的nbit信息量 信道：向一个方向传送消息的媒体（一条发送的信道+一条接收的信道） 单工通信：单向高速公路 半双工通信：对讲机 全双工通信：电话 基带信号：来自信源的信号 带通信号：将基带信号经过载波调制（调幅，调频，调相）后（加频） 单极性不归零码，双极性不归零码，单极性归零码，双极性归零码，曼彻斯特编码，差分曼彻斯特编码 奈氏准则：在任何信道中，码元传输速率是有上限的，否则会出现码间串扰导致的干扰和失真，理想的信道的最高码元传输速率=2✖W(信道带宽:Hz) 波特 香农定理：信道的极限信息传输速率C=W✖log2(1+S/N) b/s 物理层下面的传输媒体 导向传输媒体 双绞线：STP，UTP 同轴电缆：50Ω，75Ω 光纤 非导向传输媒体 无线电磁波传播（短波，微波） 物理层设备 集线器：是一个很大的冲突域，采用广播的方式 信道复用技术充分利用一条共享信道 频分复用技术（FDM） 时分复用技术（TDM） 统计时分复用（STDM） 码分复用技术（CDM）同一个频率同时传就只能采用码分复用 数字传输系统 PCM（脉码调制）：电话通信局用的，有两个标准（24路和32路） 宽带接入技术 xDSL技术：用电话线提供internet接入。低频留给传统电话，高频给上网用，打电话和上网互不影响。采用频分复用技术 HFC光纤同轴混合网：用有线电视提供internet接入。 FTTx技术：光纤到户","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E7%89%A9%E7%90%86%E5%B1%82/"},{"title":"计网-网络安全","text":"网络安全问题概述网络安全面临的4种威胁 截获（被动式攻击）：窃听他人通信内容 中断（主动式攻击）：中断他人的网络通信 篡改（主动式攻击）：故意修改网络上传送的报文 伪造（主动式攻击）：伪造信息在网络上传送 Cain工具：捕获同一网段中用户输入的账号密码；篡改域名解析结果 通过arp欺骗实现（应对方法就是在自己的计算机上安装arp防火墙，但是如果交换机能监视，cain能直接从交换机拿数据，自己机器上的arp防火墙就没用了） DNS欺骗（篡改DNS解析结果）的实例：钓鱼网站：你输入工商银行的域名，经由篡改服务机到DNS服务器得到正确的ip地址，回来先到篡改服务机，会把正确的ip改为一个和工商银行界面相似的钓鱼网站的ip，然后你进入钓鱼网站输入工商银行的域名，钓鱼网站就把你的账号密码拿到了。 伪造：一个服务器只允许某几台计算机能访问，这时一台范围外的计算机伪造自己的ip为其中一台有访问权限的ip来访问目标服务器，前提是那一台计算机没有运行，否则会出现ip冲突。 中断：Dos攻击和DDos攻击 计算机面临的威胁（恶意程序） 计算机病毒：熊猫烧香 能传染，通过修改其他程序来吧自身或者变种复制进入完成的 计算机蠕虫：一般是消耗系统资源，不一定更改系统的设置 通过网络的通信功能将自身从一个节点发送到另一个节点并启动运行的程序 特洛伊木马：盗号木马，灰鸽子远程控制木马，特点是需要和外界通信 一种程序，执行的功能超出其所声称的功能 逻辑炸弹：定时错误 一种当运行环境满足某种特定条件时执行其他特殊功能的程序 如何养病毒：需要把病毒文件加密，否则杀毒软件会清除掉这些文件。 两类密码体制对称加密： 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。 常见的对称加密算法：DES（分组加密后在解密合并），AES，3DES等等。 缺点： 密钥不能在网上传，只能本地保存，否则不安全 密钥要两个人一对，密钥维护相当麻烦 优点： 加密效率高 非对称加密： 非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。 常见的非对称加密算法：RSA，ECC 公钥可以随便传，私钥需要本地保管。 非对称加密单独使用效率不如对称加密，所以实际过程中的使用方法往往是非对称和对称的融合：用对称加密加密传输内容，用非对称公钥加密加密对称加密的密钥，把这两部分一起发给接收方。接收方先通过非对称加密的私钥解密得到对称加密的密钥，用这个密钥再去解密得到传输内容。 对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用. 数字签名 数字签名是非对称加密的一个实际应用 作用：防止抵赖，能够检查签名之后内容是否被更改 目的不是为了保密，而是确保传输的文件没有被更改而且发送方无法狡辩说不是我发的（例如：中央红头文件发到地方政府） 图示： 注意观察上面的过程，有个细节问题：接收方如何确认解密的公钥是发送方发的。此时就需要第三方的证书颁发机构CA 因特网使用的安全协议安全套接字层SSL 在应用层和传输层之间加入一个SSL加密层 在发送方，SSL接收应用层的数据，对数据进行加密，然后把加密的数据送往TCP套接字 在接收方，SSL从SSL套接字读取数据，解密后把数据交给应用层 例如：访问web时，不使用安全套接字的协议是http（80端口），使用了安全套接字的协议是https（443端口） 实现SSL需要的配置：也是用非对称密钥加密对称密钥来解决的（上面有介绍） 几个可以加上SSL层的应用层协议： 1234IMAPS tcp-993POP3 tcp-995SMTPS tcp-465HTTPS tcp-443 其实SSL层可是实现如下三个功能 加密SSL会话：（上面介绍的） SSL服务器鉴别：允许用户证实服务器身份 SSL客户鉴别：允许服务器证实用户身份 网络层安全协议IPSec网络安全是分层的： 数字签名/数字加密：属于应用层安全，需要应用服务的支持加密解密 SSL层：位于应用层和传输层之间，不需要应用程序的支持，但是需要配置证书才能实现SSL层安全 IPSec：位于网络层(属于底层加密)，不需要应用程序的支持，也不需要配置任何证书，时自动加密的，对上层透明。 使用IPSec建立通信之前，两个节点之间需要建立一个SA安全关联 IPSec中的两个协议AH和ESP AH：只数字签名 ESP：既要签名又要加密 链路加密与端到端加密 数据链路层的安全：每个网段传输数据加密解密 数据链路层身份验证：PPP身份验证；ADSL数据链路层安全 防火墙 防火墙时由软件硬件构成的系统，是一种特殊编程的路由器，用来在两个网络之间实施接入控制策略。该策略由防火墙使用者自行制定以适合自身内网需要。 墙内的网络称为“可信赖的网络”，而将外部的因特网称为“不可信赖的网络”。 防火墙可以通过控制内网到Internet的数据流量来解决内联网和外联网的安全问题 可以分为： 网络级防火墙：是基于数据包，源地址，目标地址，协议和端口，控制流量 来控制 应用级防火墙：根据数据包，源地址，目标地址，协议，端口，用户名，时间段，内容来控制，可以防病毒进入内网 防火墙基于的结构有： 边缘防火墙 三向外围网 背靠背防火墙 单一网卡","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"title":"计网-音频服务","text":"在Internet上传输音频视频面临的问题？ 音频视频：占用的带宽高，网速需要恒定，延迟要低（尤其是交互性的） 数据信息：对带宽，网速是否恒定，有延迟要求不高 延迟：对需要实时交互的音视频影响大。 网速是否稳定：对非交互式的音视频也有很大影响，可以通过在客户端设置缓存来实现 目前因特网提供的音视频服务的三种类型： 流式存储音视频——边下载边播放 只能在线播放，有利于保护版权 节省客户端硬盘空间 流式实况音视频——边录制边播放 通过网络现场直播 交互式音视频——实时交互式通信 视频/音频聊天 一般的流媒体服务器中存放了所有音视频，通过一个web站点调用这些流媒体，一般顾客通过访问这些web站点就可以访问到流媒体了。 利用流媒体服务器实现现场直播： 就近选择流媒体服务器，让就近的流媒体服务器从远处编码器要数据，然后再分发给每台计算机，这样可以极大节省带宽 IP电话 传统电话是用电路交换实现面向连接的通信 IP电话是利用分组交换通过互联网实现通信（交换式音视频），长途电话可以利用语音网关 改进的“尽最大努力交付”：分组标记，路由器加分类，流量管制，路由器调度，呼叫接纳","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E9%9F%B3%E9%A2%91%E6%9C%8D%E5%8A%A1/"},{"title":"计网-运输层","text":"传输层两个协议的应用场景： TCP：基于可靠传输的，丢包重传，分段编号，流量控制，建立会话(三次握手) QQ传文件，访问网站，下载文件 UDP：基于不可靠传输，一个数据包就能完成数据通信，不建立会话，支持多播 QQ聊天， UDP中IP分片是在IP层完成的， 而TCP分段是在TCP层完成的，TCP在ip层会尽量避免分片 MTU = IP头+【TCP头+(MSS)】 TCP层提前完成了分段， 而且， 两个TCP包中都有TCP头， 这是必然的。 所以到了IP层后， 都保留了TCP头， 当然就有了端口信息啊。 这一点与IP层次的分片是不同的。 ​ 而且我们应该看到， 因为TCP包在TCP层已经做了限制， 这就决定了， 等TCP包达到IP层的时候， IP层的数据绝对不会超过MTU, 因此， 对于TCP传输来说， IP层是没有必要分片的， 因为TCP层分段的时候， 已经考虑到了这个限制。 ​ 所以， 我们经常会说， UDP传输中， IP分片， 是受到了MTU的限制， TCP传输中， TCP分段， 是受到了MSS的限制（实际上最终还是受到了MTU的限制） http=TCP+80 https=TCP+443 ftp=TCP+25 SMTP=TCP+25 POP3=TCP+110 RDP=TCP+3389 smb=TCP+445 SQL Server=TCP+1433 MySQL=TCP+3306 DNS=UDP+53 or TCP+53 Telnet=TCP+23 SSH=TCP+22 应用层协议和服务之间的关系： 用ip地址定位计算机，用端口来定位服务，服务本质上是运行在TCP或UDP的某个端口侦听客户端请求的软件 查看自己计算机侦听的端口：netstat -an 测试远程计算机打开的端口：telnet xxx.xxx.xxx.xxx 可以更改服务的端口和只打开必要的端口来增加服务器安全 Windows防火墙安全： 在网卡上加一层过滤器：只允许某些端口的数据进来 防火墙是单向的，只拦截来的，不管出去的，出去的时候自动打开端口，出去了就关了，外面的就不要想进来的。 Windows防火墙程序防不了灰鸽子木马程序 防火墙是严进宽出，灰鸽子利用了这一点，让中木马的计算机灰鸽子客户端主动连到服务端。所以防火墙防不了灰鸽子木马。 解决灰鸽子木马的问题：用IPsec的网络层安全严格控制网络流量 运输层的功能 TCP传送的协议数据的那元是TCP报文段 UDP传送的协议数据单元是UDP报文或者用户数据报 运输层协议UDP和TCP UDP是无连接的，即是发送数据之前不需要建立连接 UDP使用尽最大努力交付数据，既不保证可靠交付，同时也不使用拥塞控制 UDP是面向报文的，UDP没有拥塞控制，很适合多媒体通信的要求 UDP支持一对一，一对多，多对一和多对多的叫交互通信 UDP的首部开销小，只有8个字节 TCP中的几个标志位的作用 URG 紧急指针，告诉接收TCP模块紧要指针域指着紧要数据。 ACK 置1时表示确认号（为合法，为0的时候表示数据段不包含确认信息，确认号被忽略。 PSH 置1时请求的数据段在接收方得到后就可直接送到应用程序，而不必等到缓冲区满时才传送。 RST 置1时重建连接。如果接收到RST位时候，通常发生了某些错误。 SYN 置1时用来发起一个连接，建立通话和同意建立通话的标志。 FIN 置1时表示发端完成发送任务。用来释放连接，表明发送方已经没有数据发送了。 TCP是面向连接的传输层协议 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的，这里的端点是应用程序，也就是套接字(IP+端口号)。 TCP提供可靠交付的服务 TCP提供全双工通信（表现为通信与反馈） 面向字节流 TCP可靠传输的实现提供可靠传输，流量控制，拥塞控制功能 可靠传输的工作原理：停止等待，超时重传，确认丢失，确认迟到，自动重传 使用ARQ机制的优点是简单，但是信道利用率太低（发送所用的时间占比太小）；基于此可以采用流水线传输（连续ARQ协议），可以得到更高的信道利用率，采用滑动窗口设计实现流水线的可靠传输 发一个确认一个 累计确认 netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况 123456789101112-a (all)显示所有连接和监听端口选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-o 显示与每个连接相关的所属进程 ID-u (udp)仅显示udp相关选项-n 以数字形式显示地址和端口号。-l 仅列出有在 Listen (监听) 的服務状态-p 显示 proto 指定的协议的连接-r 显示路由信息，路由表-e 显示以太网统计信息。此选项可以与 -s选项组合使用，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到 Wireshark抓包后的网络层次说明： Frame:物理层的数据帧概况 Ethernet II: 数据链路层以太网头部帧 Internet Protocol Version 4：网络层IP包头的信息 Transmission Control Protocol：传输层的数据段头部信息，此处是TCP协议。 Hypertext Transfer Protocol：应用层的信息，此处是HTTP协议 TCP协议连接管理：三次握手/四次挥手协议的大致执行流程 STP协议默认采用滑动窗口累计确认的机制： 利用TCP的三次握手协议实现对XP系统的攻击：SYN攻击和LAND攻击 TCP实际上的可靠传输实现：以字节为单位的滑动窗口 UDP的可靠传输有上层的应用层协议来实现 TCP传输过程中无数据包丢失 TCP传输过程中有数据包丢失 超时重传时间确认： TCP的流量控制 TCP的流量控制是基于滑动窗口机制的 TCP的拥塞控制 TCP的拥塞控制指的是将网络中的所有计算机，是一种全局控制，是如何避免让网络产生网络堵塞的。当一个计算机发现有丢包问题出现时，会主动把发送数据包的速度降下来。 当资源的需求综合&gt;可用的资源时，将产生资源拥塞。 拥塞控制的四种算法：慢开始，拥塞避免，快重传，快恢复 A发送窗口的上限值=Min[A的拥塞窗口,B的接收窗口]","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"title":"软件过程模型","text":"软件工程 三要素： 方法：软件工程方法为软件开发提供了“如何做”的技术。软件工程方法分为两类：结构化方法和面向对象方法。 工具：软件工具为软件工程方法提供了自动的或半自动的软件支撑环境。集成的软件工程工具再加上人的因素构成了软件工程环境。 过程：软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。 七原则 用分阶段的生命周期计划严格管理 坚持进行阶段评审 实行严格的产品控制 用现代程序设计技术 结果应能清楚地审查 开发小组的人员应该少而精 承认不断改进软件工程实践的必要性 知识体系 开发与维护过程 软件需求 软件设计 软件构造 软件测试 软件维护 支持组织过程 软件配置管理 软件工程管理 软件过程 软件工具（编码，测试等） 软件质量 软件过程（生命周期）软件生命周期： 问题定义：项目计划报告 可行性研究：可行性研究报告 需求分析：需求规格说明书 概要设计：概要设计说明书 详细设计：详细设计说明书 编码：源程序 测试：软件测试报告 维护：软件维护说明 软件过程模型/软件生存周期模型传统软件过程模型1. 瀑布模型：适用于系统需求明确且稳定，技术成熟，工程管理较严格的场合，如军工，航天，医疗。 2. V模型 3. 原型模型（当客户不清楚系统的具体输入输出；或开发者不确定算法的效率，软件与操作系统是否兼容以及客户与计算机交互的方式时，使用原型模型）原型：一个部分开发的产品，是客户和开发人员能够对加护开发的系统的相关方面进行检查。 原型化的目的： 明确并完善需求 研究技术选择方案 原型结果： 抛弃原型 把原型发展为最终产品 4. 增量模型（适用于软件开发过程中可能发生变化，具有较大风险，或者希望尽早进入市场的项目） 5. 螺旋模型(适用于需求不明确或需求可能发生变化的大型复杂软件系统) 6. 喷泉模型 现代软件过程模型1. 基于构件的开发模型（使用于系统之间有共性的情况） 2. 统一过程模型 由Rational公司推出的完整且完美的软件工程方法 基于面向对象方法学 使用统一建模语言UML 实践视角（6条最佳实践） 迭代式开发 管理需求 基于构件体系结构 可视化建模 验证软件质量 控制软甲变更 3. 敏捷开发(适合需求模糊且经常改变的场合，适合商业竞争环境下的项目)，重点。 为了解决瀑布流开发模式因为前阶段修改而导致的耦合问题 把一个大项目拆分为多个互相联系且能独立运行的小项目，分别完成，主体软件要随时能交互给用户 人员架构： PO(Product Owner)：项目经理，确定产品方向愿景，交付优先级、时间 SM(Scrum Master)：小组队长 Team(DEV开发人员&amp;QA测试人员)： 会议： 敏捷计划会：一个Sprint开一次（一个sprint就是一个迭代），每一个Sprint的任务明确，需求分析，故事点划分 每日立会： 从昨天到现在，我完成了什么 从现在到明天，我计划完成什么 有什么阻碍我的发展，抛出困难和风险 敏捷评审会：获取客户反馈 敏捷回顾会：每个Sprint末尾开一次，总结经验和教训 迭代速率，迭代燃气燃尽图 迭代计划故事和实际完成故事 计划发布日期和实际发布日期 客户满意度，团队满意度，生产环境Bug数，生产Bug解决时间，用户故事 总的项目需要拆分，包括代码库页拆分，便于管理。立会时领取故事点完成，自行验证（静态检查，复杂度，测试用例，功能测试），git push后触发CI(持续集成)流程。有团队骨干代码评审（code review），如果都通过了就入库了。 主分支的代码随时可交付。 每个开发人员的开发互不影响。 选择软件过程模型 软件过程模型是不断发展的 各种软件过程模型各有优缺点和使用场合 不同类型软件往往需要不同软件过程模型 选用时不必拘泥于某种模型 可组合多种模型 可根据实际创造新的模型","link":"/2020/11/14/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"},{"title":"软件生命周期","text":"需求分析 概念：确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。 需求的获取 概念：软件需求的来源，软件工程师收集这些软件需求的方法 包含 功能性需求：用户和其他系统完成的功能，提供的服务 非功能性需求：必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等。 来源：用户目标，领域知识，投资者，运行环境，组织环境 获取方式：采访，设定情景，原型，会议，观察商业过程和工作流 需求获取面临的挑战： 客户说不清需求 需求易变性：在系统设计时，将软件的核心建筑放在稳定的需求上。 问题的复杂度和对问题空间理解的不完备性与不一致性 需求诱导十原则： 倾听 有准备的沟通 需要有人推动 最好当面沟通 记录所有决定 保持同理协作 聚焦并协调话题 采用图形表示 继续前进原则 谈判双赢原则 需求确认 需求获取 需求提炼：对应用问题及环境的理解和分析，为问题涉及的信息，功能和系统行为建立分析模型，将用户需求精确化，完全化，最终形成下一步的需求规格说明书 需求描述（需求规格说明书）：对待开发系统的行为的完整描述，包含了功能性需求和非功能性需求，完成的标志是形成一份完整规范的需求规格说明书。 需求验证：对需求文档进行检查：有效性检查，一致性检查，完备性检查，现实性检查 需求变更 需求分析的任务建立分析模型：面向过程，面向对象 面向过程分析模型：用系统工程的思想和工程化的方法，根据用户至上的原则，自始自终按照结构化，模块化，自顶向下地对系统进行分析与设计。 采用结构化分析方法（面向数据流进行需求分析的方法），用抽象模型的概念，按照软件内部数据传递，变换的关系，自顶向下逐层分解，知道找到满足功能要求的左右可实现的软件为止。 面向对象分析模型：由5个层次（主题层，对象类层，结构层，属性层，服务层）和5个活动（标识对象类，标识结构，定义主题，定义属性，定义服务）组成。 编写需求说明：用《需求规格说明书》规范的额形式准确地表达用户的需求 IEEE标准对需求文档提出了以下结构： 引言（需求文档目的，文档约定，预期读者和阅读建议，产品范围，参考文献） 综合描述（产品前景，产品功能与优先级，用户特征，运行环境，设计与实现上的限制，假设与依赖性） 需求描述（功能需求，数据需求，性能需求，外部接口，设计约束，软件质量属性，其他需求） 附录（词汇表，分析模型，特定问题列表） 索引 系统设计 概要设计：描述软件顶层架构和组织，划分不同组件 详细设计：详细描述各组件以便能够编码实现 设计相关概念： 抽象 体系结构 设计模式 模块化 信息隐藏 功能独立 精化 重构 数据设计 架构设计 接口设计 组件设计 面向过程架构设计 变换型软件结构图 事务型软件结构图 混合型软件结构图 面向过程组件设计 面向对象架构设计 面向对象组件设计（类设计和用例设计）","link":"/2020/11/14/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"CSS快速回顾","text":"前端三件套 HTML+CSS+JavaScript 结构+表现+交互 css历史 1.0 2.0 2.1 3.0 怎么学CSS CSS是什么 CSS怎么用 CSS选择器（重难点） 美化网页（文字，阴影，超链接，列表，渐变） 盒子模型（重点） 浮动 定位 网页动画（特效） 什么是CSS 层叠样式表(Cascading Style Sheets)，美化网页（字体，颜色，边距，高度，宽度，背景图片，网页） 发展史： CSS1.0：高耦合内联基础样式 CSS2.0：DIV+CSS，HTML和CSS结构分离的思想，网页变得简单，利于SEO CSS2.1：浮动，定位 CSS3.0：圆角，阴影，动画…..有浏览器兼容性问题（IE6前端之殇） CSS快速入门1234567891011/*规范语法：选择器{ 属性1:属性值; 属性2:属性值; ...}*/h1{ color: red;} CSS优势： 内容和表现分离 网页结构表现统一，可以实现复用 样式十分丰富 建议使用独立于html的css文件 利用seo，容易被搜索引擎收录 三种导入方式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!--1. 行内样式--&gt;&lt;h1 style=&quot;color: red&quot;&gt;中华人民共和国&lt;/h1&gt;&lt;!--2. 内部样式表--&gt;&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;内部样式表&lt;/title&gt; &lt;!--使用内部样式表引入CSS--&gt; &lt;style type=&quot;text/css&quot;&gt; div{ background: green; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是DIV&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--3. 外部样式表--&gt;&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;外部样式表&lt;/title&gt; &lt;!--链接式:推荐使用--&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt; &lt;!--导入式:CSS2.1特有的--&gt; &lt;style type=&quot;text/css&quot;&gt; @import url(&quot;css/style.css&quot;); &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ol&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;/ol&gt;&lt;/html&gt; 三种样式表的优先级：就近原则 选择器作用：选择页面上的某一个或者某一类元素 标签选择器12345678&lt;!--会选择页面上所有的这个标签的元素--&gt;&lt;style&gt; h1{ color: red; }&lt;/style&gt;&lt;h1&gt;The People's Republic Of China&lt;/h1&gt; 类选择器123456789&lt;!--会选择页面上所有该类的元素，即可以复用--&gt;&lt;style&gt; .redClass{ color: red; }&lt;/style&gt;&lt;h1 class=&quot;redClass&quot;&gt;The People's Republic Of China&lt;/h1&gt;&lt;h1 class=&quot;redClass&quot;&gt;中华人民共和国&lt;/h1&gt; ID选择器123456789101112&lt;!--会选择页面上所有该ID的元素,ID全局唯一--&gt;&lt;style&gt; #buleClass{ color: blue; } #redClass{ color: red; }&lt;/style&gt;&lt;h1 id=&quot;blueClass&quot;&gt;美利坚合众国&lt;/h1&gt;&lt;h1 id=&quot;redClass&quot;&gt;中华人民共和国&lt;/h1&gt; 三种基础选择器的优先级：ID选择器 &gt; Class选择器 &gt; 标签选择器 层次选择器123456789101112131415161718192021222324252627282930313233343536373839&lt;!--1. 后代选择器：在某个元素里面的所有2. 子选择器：后一代，子女3. 相邻兄弟选择器：同父母的后面那个兄弟元素4. 通用选择器：当前选中元素的向下所有兄弟元素--&gt;&lt;style&gt; /*后代选择器*/ body p{ background: green; } /*子选择器*/ body&gt;p{ background: red; } /*相邻兄弟选择器*/ .choosed+p{ background: blue; } /*通用选择器*/ .choosed~p{ background: grey; }&lt;/style&gt;&lt;p&gt;p1&lt;/p&gt;&lt;p class=&quot;choosed&quot;&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt;&lt;ul&gt; &lt;li&gt; &lt;p&gt;p4&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p5&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;p6&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 伪类选择器 &amp; 伪元素选择器1234567891011121314151617181920212223242526272829303132&lt;!--伪类选择器是用来选择某个类，或者说，选择的是某个类的状态。--&gt;&lt;style&gt; /*ul的第一个子元素*/ ul li:first-child{ color: red; } /*ul的最后一个子元素*/ ul li:last-child{ color: blue; } /*只选中p1*/ p:nth-child(1){ /*选中当前元素的父级的第一个子元素，如果在p1前加一个非p的标签则选不上p1*/ background: red; } p:nth-of-type(2){ /*选择当前元素中的父级的第一个和当前元素同类型的子元素*/ color: red; }&lt;/style&gt;&lt;p&gt;p1&lt;/p&gt;&lt;p&gt;p2&lt;/p&gt;&lt;p&gt;p3&lt;/p&gt;&lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt;&lt;/ul&gt; 123456789/*a标签伪类选择器*//*鼠标未点击*/a:link {color:blue;}/*鼠标点击后*/a:visited {color:blue;}/*鼠标悬浮*/a:hover {color:red;}/*鼠标摁住未释放*/a:active {color:yellow;} 123456789101112/*伪元素选择器是用来在文档中插入假象的元素。CSS2.1的写法。*//*首字母和首行*/:first-letter:first-line/*之前和之后*/:before:after 属性选择器最好用的一种选择器：相当于把class选择器和id选择器结合了 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .demo a{ float: left; display: block; height: 50px; width: 50px; border-radius: 10px; background: green; text-align: center; color: red; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; } /*存在id属性的元素:属性名 [属性名=属性值(可使用正则)]*/ a[id]{ background: yellow; } a[id=first]{ background: gray; } a[class*=&quot;links&quot;]{ /* =:绝对等于 *=:包含 ^=:以...开头 $=:以...结尾 */ background: pink; }&lt;/style&gt;&lt;p class=&quot;demo&quot;&gt; &lt;a href=&quot;http://www.baidu.com&quot; class=&quot;links item first&quot; id=&quot;frist&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;links item active&quot; id=&quot;second&quot; target=&quot;_blank&quot; title=&quot;test&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;images/123.html&quot; class=&quot;links item&quot; id=&quot;third&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;images/123.png&quot; class=&quot;links item&quot; id=&quot;fourth&quot;&gt;4&lt;/a&gt; &lt;a href=&quot;images/123.jpg&quot; class=&quot;links item&quot; id=&quot;fifth&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;abc&quot; class=&quot;links item&quot; id=&quot;sixth&quot;&gt;6&lt;/a&gt; &lt;a href=&quot;/a.pdf&quot; class=&quot;links item&quot; id=&quot;seventh&quot;&gt;7&lt;/a&gt; &lt;a href=&quot;abc.pdf&quot; class=&quot;links item&quot; id=&quot;eighth&quot;&gt;8&lt;/a&gt; &lt;a href=&quot;abc.doc&quot; class=&quot;links item&quot; id=&quot;ninth&quot;&gt;9&lt;/a&gt; &lt;a href=&quot;abcd.doc&quot; class=&quot;links item last&quot; id=&quot;tenth&quot;&gt;10&lt;/a&gt;&lt;/p&gt; 字体 &amp; 文本 等 美化 有效传递页面信息 美化网页，页面漂亮能吸引用户 凸显网页主题 12&lt;span&gt;重点要突出的字用span标签套起来&lt;/span&gt;欢迎学习&lt;span&gt;Java&lt;/span&gt; 字体样式123456789101112131415161718192021222324252627282930&lt;style&gt; body{ /*字体*/ font-family: 楷体; /*颜色*/ color: red; } h1{ /*大小*/ font-size: 50px; } p{ /*粗细*/ font-weight: bold; /*集合font*/ font: font-style || font-variant || font-weight || font-size || line-height || font-family } &lt;/style&gt;&lt;body&gt; &lt;h1&gt;故事介绍&lt;/h1&gt; &lt;p&gt; 尘世之锁是《原神》中的一件五星法器，只能通过祈愿获得。尘世之锁原属于尘之魔神归终，归终具有超越众多仙神的智慧，她总是与岩之神摩拉克斯一同行动，想要同摩拉克斯一起建设璃月。而最终她未能和摩拉克斯一同见证璃月的安宁与繁华。尘世之锁作为盟约的信物，一直留在岩之神的手中。 &lt;/p&gt; &lt;p&gt; 这是一个表面被71%的海水覆盖着的蓝色星球，人类在这片碧蓝色之中出生、成长、孕育和发展属于自己的文明。然而，伴随着它们的，还有不断膨胀的野心和欲望。表面风平浪静的世界格局之下，历史的暗流涌动。终于，未知的敌人在海洋中出现，面对敌方压倒性的战力，各个阵营却仍然各自为战，最终换来的结果亦是惨痛的：人类失去了90%以上的海域控制权，科技和生活水平急速倒退。人类对于海洋以及未知的敌人产生了深深的阴影，并且将那些将他们拖入深海黑暗之中的怪物称之为『塞壬』 。数十年之后，各大阵营为了夺回曾经的辉煌，终于摒弃前嫌，联合创建了第三方军事组织『碧蓝航线』 。碧蓝航线的宗旨在于：集结并共享来自来自世界各大阵营的科技与资源，建造出能够与塞壬抗衡的新锐部队，夺回海域的控制权。 &lt;/p&gt;&lt;/body&gt; 文本样式 颜色 12345h1{ color: red; color: #FF0000; color: rgb(255,0,0,0.4);/*最后是浓度*/} 文本对齐方式 1234p{ text-align: center; vertical-align: middle;} 首行缩进 123p{ text-indent: 2em;} 行高 123p{ line-height: 10px;/*和height一致就可以单行文本垂直居中*/} 装饰 123456p{ text-decoration: underline;/*下划线*/ text-decoration: overline; text-decoration: line-through; text-decoration: none;} 阴影 1234h1{ /*text-shadow: h-shadow v-shadow blur color*/ text-shadow: 5px 5px 5px #FF0000;} 其他样式 列表美化 12345678910ul li{ height: 30px; /* 可以按顺序设置如下属性： list-style-type:none,disc,circle,square,decimal... list-style-position list-style-image */ list-style: square inside url('/i/arrow.gif'); } 背景 &amp; 渐变 1234567891011121314div{ /* 可以设置如下属性： 背景颜色background-color 背景图像位置background-position 背景图片尺寸background-size 如何重复background-repeat 规定背景图片的定位区域background-origin 规定背景图片的绘制区域background-clip 图像是否固定or随着页面滚动background-attachment 背景图片地址background-attachment */ background: #00FF00 url(bgimage.gif) no-repeat fixed top;} 盒子模型 border： 1234567891011121314151617&lt;style&gt; /*body默认有一个8px的margin,一般先干掉他*/ /*一般开发的时候会专门一个reset.css文件*/ body{ margin: 0; } /*border: 粗细,样式,颜色*/ #app{ width: 300px; border: 1px solid red; }&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;/div&gt; margin &amp; padding： 123456789101112131415&lt;style&gt; /*auto表示自动，&quot;margin： 20px auto；&quot;就会使浏览器根据窗口大小自适应地使定宽块状元素左右居中显示*/ #app{ /*顺序是上右下左*/ margin:10px 5px 15px 20px; /*两个是上下，左右*/ padding:10px 10px; /*三个是上，下，左右*/ padding:10px 5px 10px; }&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 圆角边框 &amp; 阴影 12345678910111213141516171819 &lt;style&gt; #app{ width:100px; height:100px; border:10px solid red; /*四个值：左上角、右上角、右下角、左下角 两个值：左上右下对角线，右上左下对角线*/ border-radius: 50px 20px; /* 向 div 元素添加阴影： box-shadow: h-shadow v-shadow blur spread color inset; */ box-shadow: 10px 10px 5px #888888; }&lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt; 注意：margin和text-align的区别： text-align:center 设置文本或img标签等一些内联对象（或与之类似的元素）的居中。 margin:0 auto 设置块元素（或与之类似的元素）的居中。 margin:0 auto；在不同场景下生效条件如下： ​ 块级元素：给定要居中的块级元素的宽度。 ​ 行内元素：①设置display:block；②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置） ​ 行内块元素：设置display:block。（如input、button、img等元素，自带宽度可以不用设置其宽度） 文档流元素分类块级元素（block-level）块元素会独自占据一整行，或者多行，可以任意设置其大小尺寸，是用于搭建网页布局的必须部分，使网页结构更加紧凑合理。 总是另起一行（特立独行） 可以设置其宽度、高度，内外边距 在不手动设置宽度的情况下，宽度默认为所在容器的100%（即容器宽度） 可以容纳行内元素和其他块元素。 1常见的块级元素有：&lt;div&gt;/&lt;h1&gt;~&lt;h6&gt;/&lt;p&gt;/&lt;ul&gt;/&lt;table&gt;等，其中&lt;div&gt;是最常用最典型的块级元素。 行内元素（inline-level）行内元素也称为内联元素，行内元素不占有独立区域，其大小仅仅被动的依赖于自身内容的大小（例如文字和图片），所以一般不能随意设置其宽高、对齐等属性。常用于控制页面中文本的样式。 总是和相邻的行内元素在同一行上（物以类聚） 设置宽高无效，水平方向的padding和margin属性可以设置，但是垂直方向上的无效。 默认宽度是他自身内容的宽度。 行内元素只能容纳其他行内元素或者文本。 1&lt;a&gt;比较特殊，可以放块级元素，但是链接里面不能再放链接。 行内块元素（inline-block）普遍的规则里总有那么几个不一样的，在行内元素中就有那么几个特殊标签，比如&lt;img&gt;/&lt;input&gt;/&lt;td&gt;,可以给他们设置宽高、对齐属性，我们把这样特殊的一类标签称为行内块元素。行内块元素综合了块元素和行内元素的不同特点。 和相邻行内元素在同一行，但是之间会有空白缝隙。 默认宽度是他本身内容的宽度。 宽度、高度、行高、外边距以及内边距都可以手动设置。 标签显示模式转换：displey 块元素——&gt;行内元素 ： display:inline; 行内元素——&gt;块： display:block; 块、行内元素——&gt;行内块： display: inline-block; 元素不会显示：display:none; 文档流 文档流： 将窗体自上而下分成一行一行，众多盒子模型在每行中按从左至右依次排放元素，称为文档流。 脱离文档流： 元素脱离文档流之后，将不再在文档流中占据空间，而是处于浮动状态。当一个元素脱离文档流后，依然在文档流中的其他元素将忽略该元素并填补其原先的空间。 脱离文档流的三种方法： float:left/right; 使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。 position: absolute; 因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的， 并且这个父类元素的position必须是非static定位的（static是默认定位方式）。 position: fixed; 完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。 浮动： 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;#a{ width:100px; height:100px; background: blue; float:left;}#b{ width:150px; height:150px; background: red; float:left; /*清除其他浮动元素对自己的影响：left针对左浮动，right针对右浮动，both同时针对*/ clear:left;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;&lt;div id=&quot;b&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 父级边框塌陷问题 子元素浮动后脱离文档流导致的父级边框塌陷问题的解决方法： 增加父级元素的高度 父元素中增加一个空div标签，然后清除浮动 12345678&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;style&gt; .clear{ clear:both; margin:0; padding:0; }&lt;/style&gt; 开启BFC 开启元素的BFC后，元素将会有以下特性： 垂直外边距不会和子元素重叠 不会被浮动元素所覆盖 可以包含浮动的子元素 如何开启BFC： 设置元素浮动 设置元素绝对定位 设置元素为inline-block 将overflow设置为一个非visible的值（推荐：将overflow设置为hidden是副作用最小的开启BFC的方法） 父类添加一个伪类： 1234567891011121314151617181920212223/*解决父子元素垂直外边距重叠问题*/.clearfix:before{ content: &quot;&quot;; display: table;}/*解决父元素高度塌陷问题*/.clearfix:after{ content: &quot;&quot;; display: block; clear: both;}/*同时解决父子元素垂直外边距重叠问题和父级高度塌陷问题*/.clearfix:before,.clearfix:after{ content: &quot;&quot;; display: table; clear: both;} 定位 相对定位相对于自己原来的位置进行偏移，原来的位置还是被保留，元素仍然处于文档流中。 123456789div{ background: red; position: relative; /*上下左右：相对自己原来位置*/ top: 5px; bottom: 5px; left: 5px; right: 5px; } 绝对定位绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 只能在相对的那个祖先元素范围内移动，元素绝对定位后已经脱离文档流 12345678910div{ background: red; position: absolute; /*上下左右：相对最近已定位祖先元素*/ top: 5px; bottom: 5px; left: 5px; right: 5px; } 固定定位相对于浏览器窗口进行定位，脱离原来的文档流 123456789div{ background: red; position: fixed; /*上下左右:相对浏览器窗口*/ top: 5px; bottom: 5px; left: 5px; right: 5px; } Z-index &amp; 透明度12345678910111213div{ /*设置图层显示优先级，范围0-999 前提是必须先开启定位，即postion不能是static 父元素层级再高也不会盖过子元素 */ position: relative; z-index: 1; /*两种方式设置透明度*/ opacity: 0.5; /*IE8以及更早版本支持*/ filter: Alpha(opacity=50);} 动画css3动画主要常用的属性有三种 变形（transform） 转换（transition） 动画（animation） 123456789101112/*animation栗子*/div{ width:300px; height:200px; background:red; animation:mymove 5s infinite;}/*背景颜色逐渐地从红色变化到蓝色：*/@keyframes mymove{ from {background-color:red;} to {background-color:blue;}} hackCSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），解决兼容性问题。 条件hack 1234567&lt;!--[if IE 6]--&gt; &lt;p&gt;只在ie6中显示的内容&lt;/p&gt;&lt;!--[endid]--&gt;&lt;!--[if lt IE 9]--&gt; &lt;p&gt;只在小于ie9中显示的内容&lt;/p&gt;&lt;!--[endid]--&gt; 属性hack 123456div{ /*属性前加_只有ie6及以下才认识*/ _background-color: red; /*属性前加*只有ie7及以下才认识*/ *background-color: red;} 还有很多hack，有需求的时候百度就行了。 但是css的hack不到万不得已最好不要使用，因为维护起来很麻烦。","link":"/2021/01/08/CSS%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"},{"title":"JavaScript快速回顾","text":"再次回顾前端三件套 HTML（结构）：超文本标记语言，决定网页的结构和内容 CSS（表现）：层叠样式表，设定网页的表现样式 JavaScript（行为）：一种弱类型的脚本语言，其源代码不需要经过编译，由浏览器解释运行，用于控制网页的行为。 历史 Native原生JS开发：按照【ECMAScript】标准的开发方式，特点是所有浏览器都支持。（目前的主流版本是ES6，但是ES5才是所有浏览器都支持，所以需要用webpack把ES6打包为ES5） TypeScript微软标准：微软开发的语言，是JavaScript的超集。除了具备ES的特性之外还有很多不在范围内的新特性，会导致很多浏览器不能直接支持Typescript语法，需要编译后才能被浏览器正确执行。 Javascript流行库 &amp; 框架 jQuery：简化原生JavaScript操作的JS库 Angular：Goole收购的前端框架 React：Facebook开发的高性能JS前端框架 Vue：渐进式JavaScript框架，特点是综合了Angular(模块化)和React(虚拟DOM)的优点 Axios：前端通信框架 UI框架： Ant-Design：阿里巴巴 ElementUI，iview，ice：饿了么 Boostrap：Twitter AmazeUI：妹子UI JavaScript构建工具 Babel：Typescript编译工具 Webpack：模块打包器 世界上最流行的脚本语言——JavascriptECMAScript是JavaScript的一种规范，目前已经到ES6了。但是大部分浏览器只支持到ES5 作为一名后端程序员，必须要精通Javascript！ 快速入门12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!--第二种外部引入方式--&gt; &lt;script src=&quot;js/a.js&quot;&gt;&lt;/script&gt; &lt;!--第一种方式--&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;hello,world!&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 基本语法基本上按照java语法来写JavaScript一定没有问题： 12345678//定义变量（可带$和_）var num = 1;//条件控制if(2&gt;1){ alert(&quot;true&quot;);}//JavaScript严格大小写console.log(score); var 和 let的区别JavaScript中的变量大致分为局部变量和全局变量 大体上：函数外声明的就是全局变量，函数内声明的就是局部变量 变量是需要用var关键字声明的。但是javascript中也可以隐式的使用变量，就是不用声明，直接使用。但是千万注意，javascript把隐式声明的变量总是当成全局变量来使用的。 let和var的区别体现在作用域上：var的作用域是函数作用域，let作用域则被规定为块作用域，块作用域要比函数作用域小一些，但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。 举个栗子： 12345678&lt;!--有五个按钮--&gt;&lt;div&gt; &lt;button&gt;按钮1&lt;/button&gt; &lt;button&gt;按钮2&lt;/button&gt; &lt;button&gt;按钮3&lt;/button&gt; &lt;button&gt;按钮4&lt;/button&gt; &lt;button&gt;按钮5&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617var btns=document.querySelectorAll('button');for(var i = 0;i&lt;btns.length;i++){ btns[i].οnclick=function(){ alert('点击了第'+i+'个按钮'); }}//点击按钮后弹出的都是第4个，原因是var定义变量i作用域造成的。//通过var关键字声明的变量只有函数作用域，没有块作用域，在块{ }内声明的变量可以从块之外进行访问。//通过let关键字声明的变量拥有块作用域，在块{ }内声明的变量无法从块外访问let btns=document.querySelectorAll('button');for(let i = 0;i&lt;btns.length;i++){ btns[i].οnclick=function(){ alert('点击了第'+i+'个按钮'); }} //JavaScript中，函数查找变量从自身函数开始，从 '内' 向 '外' 查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。（就近原则） 数据类型 number：js不区分小数和整数 123456123//整数123.1//浮点数1.23e3//科学计数法-99//负数NaN//not a numberInfinity//无限大 string： 12'abc'&quot;abc&quot; boolean： 1234truefalse&amp;&amp; || ! = == ===(类型一样且值一样)NaN和所有数值都不相对，包括自己，只能isNaN()来判断 null：空 undefined：未定义 object：对象 Function： 普通object： 12345var person={ name: &quot;qinjiang&quot;, age: 3, tags: ['js','java','web']} Array：数组中可以有各个类型的值 123var arr = {1,2,3,4,5,'hello',true}var arr = new Array(1,2,3,4,5,'hello',true);//数组下标越界会undefined Date： … 严格检查模式123//预防JavaScript的随意性导致的各种问题，必须写在第一行'use strict'let i = 1;//局部变量建议使用let 数据类型字符串 使用单引号或者双引号包裹 注意转义字符 \\ 12345\\'\\n\\t\\u字符 //Unicode字符\\x字符 //AscII字符 多行字符串编写 123var msg = `fasdfdsafsadfasdfdsafasdfsda`;//单反引号 模板字符串 123let name = &quot;jackyang&quot;;let age = 3;let msg = `你好，${name}`; 字符串长度 1234var student = &quot;student&quot;;console.log(studnet.length);console.log(studnet[0]);//字符串不可变，下标只能访问 其他函数 1234student.toUpperCase();student.toLowerCase();student.indexOf('t');studnet.subString(1,3);//[) 数组 长度 1234567var arr = [1,2,3,4,'hello'];arr.length;/*数组长度可变，通过给length赋值赋值过大，多余的元素是undefined赋值过小，元素会丢失*/arr.length = 10; 索引 12//获得下标索引arr.indexOf('hello'); 切割 &amp; 压进 &amp; 弹出 12345slice();//截取Array的一部分，返回一个新数组push();//压入尾部pop();//从尾部弹出unshift();//从头部压入shift();//从头部弹出 排序 &amp; 反转 123//自身会改变arr.sort();arr.reverse(); 拼接 1234var arr = ['C','B','A'];arr.concat([3,4,5]);//没有修改数组，指挥返回一个新的数组['C','B','A',3,4,5]arr.join('-');//把数组中的元素通过指定分隔符链接在一起&quot;C-B-A&quot; 多维数组 12var arr = [[1,2],[3,4],['a','b']];console.log(arr[1][1]); 对象 {…}表示一个对象，内容由若干个键值对组成。JavaScript中所有键都是字符串，值是任意对象 123456var person = { name: &quot;jackyang&quot;, age: 21, email: &quot;yangfanjack1024@qq.com&quot;, score: 100} 对象赋值 1person.name=&quot;samsmith&quot;; 使用一个不存在的对象属性，不会报错：undefined 1person.haer; 动态的删减 &amp; 添加属性 12delete person.name;//deleteperson.haha = &quot;heihei&quot;;//add 判断属性值是否在对象中 1234'email' in person;//true'toString' in person;//继承下来的//判断一个属性是否是这个对象自身独有的person.hasOwnProperty('toString'); 流程控制 判断 12345678910var age = 3;if(age&lt;3){ alert(&quot;小于3&quot;);}else if(age&lt;5){ alert(&quot;大于等于三小于5&quot;);}else{ alert(&quot;大于等于5&quot;);} 循环 1234567891011121314151617181920212223242526272829var age = 3;while(age&lt;100){ age = age +1; console.log(age);}for(let i=0;i&lt;100;i++){ console(i);}do{ age=age+1; console.log(age);}while(age&lt;100);var age = [1,2,3,4,5,6,7];age.forEach(function(value){ console.log(value);})for(const num in age){//num是下标 console.log(age[num]);} for (const num of age) {//num是每个值 console.log(num);}//遍历map和set只能使用of，不能使用in Map &amp; Set集合 ES6的新特性 12345678910111213141516171819202122232425262728293031323334353637//Mapvar map = new Map([['tom',100],['jack',99],['haha',80]]);var name = map.get('tom');//获取console.log(name);//100map.set('jack',22);//新增 &amp; 修改map.delete('jack');//删除//Set:无序不重复集合var set = new Set([1,2,3,1,1,1]);set.add(4);//新增set.delete(2);//删除console.log(set.has(3));//判断是否包含//ES6新增了Sysbol.iterator，可用来遍历String,Array,Map,Set// Arrayvar arr = ['a', 'b', 'c', 'd', 'e'];var eArr = arr[Symbol.iterator]();console.log(eArr.next().value); // aconsole.log(eArr.next().value); // bconsole.log(eArr.next().value); // cconsole.log(eArr.next().value); // dconsole.log(eArr.next().value); // e// Mapconst map1 = new Map();map1.set('0', 'foo');map1.set(1, 'bar');const iterator1 = map1[Symbol.iterator]();for (let item of iterator1) { console.log(item);} 函数 &amp; 面向对象函数定义及变量作用域方法：对象包含（属性，方法），对象中的函数就是方法 定义方式1 1234567891011//绝对值函数function abs(x){ if(x&gt;=0){ return x; } else{ return -x; }}console.log(abs(-10));//如果没有执行return，函数执行完也会返回一个undefined结果 定义方式2 12345678var abs = function(x){ if(x&gt;=0){ return x; } else{ return -x; }} 调用函数 123456789101112abs(-10);abs(10);//JavaScript函数参数可以少传也可以多传，也不会报错//arguments是函数内一个隐含参数，代表传进来的所有参数，是一个数组//rest是ES6新特性，获取除了已经定义的参数之外的所有参数,只能写在最后面，前面加...function aaa(a,b,...rest){ console.log(a); console.log(b); console.log(arguments); console.log(rest);} 提升变量作用域 123456789101112131415function qj(){ var x = &quot;x&quot; + y; console.log(x); var y = 'y';}//结果是undefined//js引擎会自动提升y的声明，但是不会提升y的赋值，上述等价于function aj(){ var y; var x = &quot;x&quot; + y; console.log(x); y = 'y';}//养成规范：所有变量的定义都放在在最上面 12345678910window//全局对象//默认所有全局变量和函数都自动绑定再window对象下//JavaScript一切皆对象，也就是所有全局对象都在window对象下var my_alert = window.alert;my_alert('hello');//弹window.alert = function(){ }alert('hello');//不弹 规范 由于所有全局变量都会绑定在window上，所以不同js文件如果全局变量同名就很麻烦。所以要通过一些规范避免冲突： 1234567//唯一全局变量var jackyang = {};//定义全局变量jackyang.name = &quot;jackyang&quot;;jackyang.add = function(a,b){ return a+b;} 把自己的代码全部放进自定义的唯一空间名字中，从而避免全局命名冲突的问题，jQuery就是这样的 let 和 var 的区别见上面 常量 const（ES6新特性） 常量不能修改，只能一次赋值 方法12345678910111213141516171819//方法就是把函数放在对象中，其实函数实际也可以看作window对象的方法function hi(){ alert(this.name+',hi!');}var person = { name: &quot;jackyang&quot;, birth: 2020, email: &quot;yangfanjack1024@qq.com&quot;, score: 100, getAge: function(){ var now = new Date().getFullYear(); return now-this.birth; }, sayHi: hi}person.sayHi();person.getAge();window.hi();//hi是全局函数，只能用window调用 this默认指向想用这个方法的那个对象 apply 每个方法都有一个apply方法，可以改变this的指向 12hi.apply(person,[]);//this指向person对象，参数为空person.hi();//这样就能通过person直接调用hi了 面向对象编程在JavaScript中，类 &amp; 对象的概念和传统面向对象语言，Java,C#有区别 原型 123456789101112131415var Student = { name: &quot;Sam Smith&quot;, age: 26, run: function(){ console.log(this.name + &quot;run...&quot;); }};var xiaoming = { name: &quot;xiaoming&quot;};//原型对象Student可以理解为父类，一个子类的模板原型xiaoming.__proto__ = Student;xiaoming.run(); class继承（ES6新特性） 123456789101112131415161718192021222324252627282930313233343536373839404142//以前通过构造函数创建对象/*构造函数执行流程： 1. 立刻创建一个新的对象 2. 将新建的对象设置为函数中的this 3. 逐行执行函数中的代码 4. 将新建的对象作为返回值返回*/function Student(a){//构造函数和普通函数的区别主要是首字母大写 &amp; 调用方法 name = &quot;window&quot;;//往全局的window中添加 this.name = a;//往对象中添加}var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);console.log(xiaoming instanceof Student);//使用instanceof判断对象是否是某个构造函数的实例//给Student新增一个方法（可以理解为父类的公共方法）Student.prototype.hello = function(){ alert)('hello');}//所有对象都是object的后代//ES6中class定义一个类(class继承,本质还是原型链)class Student{ constructor(name){ this.name = name; } hello(){ alert('hello'); }}var xiaoming = new Student(&quot;xiaoming&quot;);var xiaohong = new Student(&quot;xiaohong&quot;);class XiaoStudent extends Student{ constructor(name,grade){ super(name); this.grade = grade; } myGrade(){ alert(&quot;I am a xiao student.&quot;); }} 闭包 难点 要理解闭包，首先要理解Javascript的变量作用域。 变量的作用域有两种：全局变量和局部变量。函数内部可以直接读取全局变量。函数外部无法读取函数内的局部变量。 我们有时候需要得到函数内的局部变量。正常情况下是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1(){ var n=999; function f2(){ alert(n); // 999 }} 既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量了 1234567891011function f1(){ var n=999; function f2(){ alert(n); } return f2;} var result=f1(); result(); // 999 闭包就是能够读取其他函数内部变量的函数 在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁 闭包的两中常见应用： 将函数作为另一个函数的返回值 12345678910111213141516function fn1(){ var a = 2; function fn2(){ a++; console.log(a); } function fn3(){ a--; console.log(a); } return fn3;}var f = fn1();f();//3f();//4//如果这个没有闭包的话，调完fn1()后a就消失了，再调用f()就会报错找不到a 将函数作为实参传递给另一个函数调用 123456function showDelay(msg, time){ setTimeout(function(){ alert(msg) },time)}showDelay('trigger',2000); 闭包的作用： 使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期） 让函数外部可以操作（读写）到函数内部的数据 闭包核心函数执行完后，函数内部声明的局部变量一般情况下会释放的。但是存在闭包关系中的变量（如上面fn1函数的a变量）才可能存在。为什么是可能呢？因为必须要还要有引用指向fn1函数的返回值，如上的f变量指向的fn1的返回值fn3，fn3中有a，所以a才存在闭包关系，此时才能保证fn1执行完a变量并不会释放。 箭头函数 ES6新特性 箭头函数也叫lambda表达式，其主要意图是定义轻量级的内联回调函数 12345678var arr = [&quot;wei&quot;,&quot;ze&quot;,&quot;yang&quot;];arr.map(item=&gt;&quot;Mr.&quot;+item); // [&quot;Mr.wei&quot;, &quot;Mr.ze&quot;, &quot;Mr.yang&quot;]//等价于var arr = [&quot;wei&quot;,&quot;ze&quot;,&quot;yang&quot;];arr.map(function(item){ return &quot;Mr.&quot;+item;}); 原型链继承 难点 什么是原型？ 12345678910111213141516//我们所创建的每个函数，解析器都会向函数中添加一个属性prototype//这个属性对应一个原型对象//如果这个函数作为普通函数调用时，prototype没有任何作用//当函数作为构造函数调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象function Student(a){ name = &quot;window&quot;; this.name = a;}var stu = new Student();var stu2 = new Student();console.log(stu.__proto__ == Student.prototype);//trueconsole.log(stu2.__proto__ == Student.prototype);//true//原型对象相当于是一个公共区域，所有同一个类的实例都可以访问这个原型对象//可以把对象中共有的内容放到原型对象中 以后我们创建构造函数时，可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中，这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了 什么是原型链 原型对象也是对象，所以他也有原型 当我们访问对象的一个属性或者方法时，会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到就直接使用，如果没有就去原型对象的原型对象中寻找，直到找到Object对象的原型，Object对象的原型没有原型 常用对象 JavaScript标准对象：number string boolean NaN object function undefined Infinity Date123456789101112131415var now = new Date();now.getFullYear();//年now.getMonth();//月0到11now.getDate();//日now.getDay();//星期几now.getHours();//时now.getMinutes();//分now.getSeconds();//秒now.getTime();//时间戳（全世界统一：1970.01.01 00:00:00开始到现在的毫秒数）console.log(new Date(1610499819016));//时间戳转标准时间格式//几种时间的格式转换now.toLocalString();now.toGMTString();now.toISOString JSON JSON是啥？ JSON（JavaScript Object Notation，JS对象简谱）是一种轻量级的数据交换格式 简介和清晰的层次结构使得JSON成为理想的数据交换语言 易于阅读和编写，易于机器解析和生成，能有效提升网络传输效率 JavaScript中一切皆对象，任何js类型都可以用JSON表示 对象都用{} 数组都用[] 键值对用key:value 1234567891011var user = { name: &quot;Mariah Carey&quot;, age: 50, sex: 'male'}//JavaScript对象转json字符串var jsonUser = JSON.stringify(user);//json字符串转JavaScript对象//里面双引号外面单引号，里面双引号外面单引号JSON.parse('{&quot;name&quot;:&quot;Mariah Carey&quot;,&quot;age&quot;:50,&quot;sex&quot;:&quot;male&quot;}'); 12345{ &quot;name&quot;:&quot;Mariah Carey&quot;, &quot;age&quot;:50, &quot;sex&quot;:&quot;male&quot;} JavaScript对象和JSON字符串的区别 首先，一个是对象，一个是字符串 json字符串的key需要引号，JavaScript不需要 前后端分离传数据一般是配合ajax结合 原生js写法，xhr异步请求 jQuery封装好的方法$(&quot;#name&quot;).ajax() axios请求 操作BOM元素 JavaScript 由三部分构成，ECMAScript，DOM（Document对象模型）和BOM（浏览器对象模型） JavaScript的诞生就是为了能让它能再浏览器中运行 window12345678910111213141516//window代表浏览器窗口//window对象是BOM中所有对象的核心，除了是BOM中所有对象的父对象外，还包含一些窗口控制函数。window.alert('hello');//所有BOM对象的父对象window.navigator;window.screen;window.location;window.document;window.history;//通过调整浏览器窗口大小来改变这些浏览器相关值的大小window.innerHeight;window.innerWidth;window.outerHeight;window.outerWidth; navigator1234567//封装了浏览器的信息navigator.appName;navigator.appversion;navigator.userAgent;navigator.platform;//一般情况不会使用navigator对象，因为会人为篡改，不能把这些数据作为判断浏览器的标准//不建议使用 screen12345//代表屏幕尺寸screen.width;1920pxscreen.height;1080px location1234567891011121314//代表当前页面的URL信息host: &quot;www.bilibili.com&quot;href: &quot;https://www.bilibili.com/video/BV1JJ41177di?p=19&quot;origin: &quot;https://www.bilibili.com&quot;pathname: &quot;/video/BV1JJ41177di&quot;protocol: &quot;https:&quot;reload: ƒ reload()//刷新网页assign: ƒ assign()//设置新的地址//重定向地址有三种方法：location.assign(&quot;https://jack1024.link&quot;);location.href=&quot;https://jack1024.link&quot;;location.replace(&quot;https://jack1024.link&quot;);//replace和上面两种方法的区别是，replace的浏览历史会被清空了（href与assign方法会产生历史记录），所以建议使用repalce，这样就不能点击浏览器左上角的左右按钮回退了，更加安全。 document123//document代表当前页面的HTML DOM文档树，具体的DOM在下面DOM中介绍document;//获取文档树document.cookie;//获取网页cookie history1234//代表浏览器的历史记录history.back();history.forward();//不建议使用 操作DOM元素 浏览器网页就是一个DOM属性结构 获取DOM12345678910111213141516&lt;div id=&quot;div1&quot;&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;段落1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;段落2&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var h1 = document.getElementsByTagName(&quot;h1&quot;); var p1 = document.getElementById(&quot;p1&quot;); var p2 = document.getElementsByClassName(&quot;p2&quot;); var div1 = document.getElementById(&quot;div1&quot;); var children = div1.children;//获取父节点下的所有子节点 var first = div1.fristChild; var last = div1.lastChild;&lt;/script&gt; 更新DOM1234567891011&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); //属性使用字符串包裹 div1.innerText = &quot;hello,world!&quot;; div1.innerHTML = &quot;&lt;strong&gt;hello,world!&lt;/strong&gt;&quot;; div1.style.color = &quot;red&quot;; div1.style.fontSize = &quot;20px&quot;;//css中用“-”连接的属性用驼峰命名 div1.style.padding = &quot;2em&quot;&lt;/script&gt; 删除DOM12345678910111213141516171819//先获取删除目标元素的父节点，然后通过父节点删除自己&lt;div id=&quot;div1&quot;&gt; &lt;h1&gt;标题1&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;段落1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;段落2&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var div1 = document.getElementById(&quot;div1&quot;); var p1 = document.getElementById(&quot;p1&quot;); div1.removeChild(p1); var p2 = document.getElementByClassName(&quot;p2&quot;); var father = p2.parentElement; father.removeChild(p2); //删除是一个动态的过程，删除多个节点时，children是在时刻变化的，删除节点的时候一定要注意 father.removeChild(father.children[0]);//删了第一个，剩下的节点依次往前挪&lt;/script&gt; 插入DOM12345678910111213141516171819202122232425262728&lt;!--我们获得某个DOM节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是如果这个DOM已经有内容了，就追加。--&gt;&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;&lt;div id=&quot;list&quot;&gt; &lt;p id=&quot;se&quot;&gt;JavaSE&lt;/p&gt; &lt;p id=&quot;ee&quot;&gt;JavaEE&lt;/p&gt; &lt;p id=&quot;me&quot;&gt;JavaME&lt;/p&gt;&lt;/div&gt;&lt;script&gt; //把已有标签p放进去 var js = getElementById(&quot;js&quot;); var list = getElementById(&quot;list&quot;); list.appendChild(js); //创建新节点然后加进来 var newP = document.createElement(&quot;p&quot;);//创建一个p标签 newP.id = &quot;newP&quot;; newP.innerText = &quot;hello,i'm newP&quot;; list.appendChild(newP); //创建一个script标签节点 &amp; 放进一个自定义属性节点，放到网页头里 var myScript = document.createElement(&quot;script&quot;); myScript.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); document.getElementByTagName(&quot;head&quot;)[0].appendChild(myScript); //往之前插 var ee = document.getElementById(&quot;ee&quot;); list.insertBefore(js,ee);//ee前插入js&lt;/script&gt; 操作表单 常见表单元素： 文本框：text 下拉框：select 单选框：radio 多选框：checkbox 隐藏域：hidden 密码框：password … 12345678910111213141516171819&lt;form&gt; &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot;/&gt; &lt;input id=&quot;male&quot; type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;/&gt;男 &lt;input id=&quot;female&quot; type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;/&gt;女&lt;/form&gt;&lt;script&gt; var input_text = document.getElementById(&quot;username&quot;); console.log(input_text); input_text.value = 'hello'; //对于单选框，多选框，value只能取到当前的值，要判断是否选中当前节点，可以用checked属性 var male_text = document.getElementById(&quot;male&quot;); var female_text = document.getElementById(&quot;female&quot;); if(male_text.checked){ alert(&quot;male is checked!&quot;); } female_text.checked = true;&lt;/script&gt; 提交表单高级验证12345678910111213141516171819202122232425&lt;form id=&quot;myForm&quot; action=&quot;&quot; method=&quot;post&quot; onsubmit=&quot;return aaa();&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;/&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;/&gt; &lt;button type=&quot;button&quot; onclick=&quot;submitForm();&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;!--MD5加密算法工具包--&gt;&lt;script src=&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //两种通过js提交表单的方式 function aaa(){ var username = document.getElementById(&quot;username&quot;); var password = document.getElementById(&quot;password&quot;); console.log(username.value); //使用md5算法加密 password.value = md5(password.value); console.log(password.value); //这里也可以结合正则表达式做前端校验工作 return true; } function submitForm(){ //做各种判断... document.getElementById(&quot;myForm&quot;).submit(); }&lt;/script&gt; 补充一个小点：钩子函数和回调函数的区别： 12345678910111213141516171819202122232425262728//一般认为，钩子函数就是回调函数的一种，其实还是有差异的，差异地方就是：触发的时机不同。/*特点： 1. 自己定义的 2. 自己没有调用 3. 但它最终执行了*//*常见的回调函数： 1. dom事件回调偶数 2. 定时器回调函数 3. ajax请求回调函数 4. 生命周期回调函数*///钩子函数//钩子（Hook）概念源于Windows的消息处理机制，通过设置钩子，应用程序对所有消息事件进行拦截，然后执行钩子函数。let btn = document.getElementById(&quot;btn&quot;);btn.onclick = () =&gt; { console.log(&quot;i'm a hook&quot;);}//回调函数//给btn绑定了一个监听器，只有消息捕获完成之后才能触发回调函数。btn.addEventListener(&quot;click&quot;,() =&gt;{ console.log(this.onclick);//undefined});//回调函数和钩子函数的一个很明显的差别就是：钩子函数在捕获消息的第一时间就执行，而回调函数是捕获结束时，最后一个被执行的。","link":"/2021/01/08/JavaScript%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"},{"title":"SSM框架-Mybatis","text":"开始原始jdbc操作的分析原始jdbc开发存在的问题如下： 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： 使用数据库连接池初始化连接资源 将sql语句抽取到xml配置文件中 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 什么是Mybatis mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM（对象关系映射）思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 开发步骤MyBatis开发步骤： 添加MyBatis的坐标 创建user数据表 编写User实体类 编写映射文件UserMapper.xml 编写核心文件SqlMapConfig.xml 编写测试类 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 123456public class User { private int id; private String username; private String password; //省略get个set方法} 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 123456789101112//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);//打印结果System.out.println(userList);//释放资源sqlSession.close(); Mybatis的增删改查操作查询操作上面那个例子就是查询操作 插入操作12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#{id},#{username},#{password}) &lt;/insert&gt;&lt;/mapper&gt; 12345678InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务（JDBC事务默认提交，Mybatis事务默认不提交）sqlSession.commit();sqlSession.close(); 需要注意： 插入语句使用insert标签 在映射文件中使用parameterType属性指定要插入的数据类型 Sql语句中使用#{实体属性名}方式引用实体中的属性值 插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); 插入操作涉及数据库数据变化，所以要使用sqlSession对象显式的提交事务，即sqlSession.commit() 修改操作12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#{username},password=#{password} where id=#{id} &lt;/update&gt;&lt;/mapper&gt; 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close(); 需要注意： 修改语句使用update标签 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 删除操作12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#{id} &lt;/delete&gt;&lt;/mapper&gt; 1234567InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 需要注意： 删除语句使用delete标签 Sql语句中使用#{任意字符串}方式引用传递的单个参数 删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); Mybatis核心配置文件 environments标签数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签该标签的作用是加载映射的，加载方式有如下几种： 使用相对于类路径的资源引用，例如： &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; 使用完全限定资源定位符（URL），例如： &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt; 使用映射器接口实现类的完全限定类名，例如： &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; 将包内的映射器接口实现全部注册为映射器，例如： &lt;package name=&quot;org.mybatis.builder&quot;/&gt; Properties标签实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 typeAliases标签类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 注意：Mybatis的核心配置文件的标签是有顺序的，必须按照顺序来书写，否则将报错 Mybatis相应APISqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 123456&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback() Mybatis的Dao层实现传统方式实现123public interface UserDao { List&lt;User&gt; findAll() throws IOException;} 12345678910public class UserDaoImpl implements UserDao { public List&lt;User&gt; findAll() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); sqlSession.close(); return userList; }} 1234567@Testpublic void testTraditionDao() throws IOException { UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);} 接口代理方式实现代理开发方式介绍 采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： Mapper.xml文件中的namespace与mapper接口的全限定名相同 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 编写UserMapper接口 测试代理方式 1234567891011@Testpublic void testProxyDao() throws IOException { InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();} Mybatis映射文件深入动态sql语句动态sql语句概述 Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 动态 SQL 之&lt;if&gt; 我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 123456789101112&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;if test=&quot;id!=0&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#{username} &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 123456//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);condition.setUsername(&quot;lucy&quot;);User user = userMapper.findByCondition(condition); 当查询条件只有id存在时，控制台打印的sql语句如下： 12345//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition); 动态 SQL 之&lt;foreach&gt; 循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 12345//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]{2,5};List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList); foreach标签的属性含义如下： &lt;foreach&gt;标签用于遍历集合，它的属性： collection：代表要遍历的集合元素，注意编写时不要写#{} open：代表语句的开始部分 close：代表结束部分 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectUser&quot;&gt;select * from User&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; where id=#{id}&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; Mybatis核心配置文件深入typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： 定义转换类继承类BaseTypeHandler&lt;T&gt; 覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 在MyBatis核心配置文件中进行注册 测试转换是否正确 1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; { public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) { preparedStatement.setString(i,date.getTime()+&quot;&quot;); } public Date getNullableResult(ResultSet resultSet, String s) throws SQLException { return new Date(resultSet.getLong(s)); } public Date getNullableResult(ResultSet resultSet, int i) throws SQLException { return new Date(resultSet.getLong(i)); } public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException { return callableStatement.getDate(i); }} 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.add2(user); Java数据类型和MySql数据类型对应表 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： 导入通用PageHelper的坐标 在mybatis核心配置文件中配置PageHelper插件 测试分页数据获取 导入通用PageHelper坐标 1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 在mybatis核心配置文件中配置PageHelper插件 12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt; 测试分页代码实现 123456789@Testpublic void testPageHelper(){ //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; userList = userMapper2.select(null); for(User user : userList){ System.out.println(user); }} 获得分页相关的其他参数 12345678910//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(userList);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;上一页:&quot;+pageInfo.getPrePage());System.out.println(&quot;上一页:&quot;+pageInfo.getNextPage());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); Mybatis多表操作xml配置一对一 1234567891011&lt;mapper namespace=&quot;com.itheima.mapper.OrderMapper&quot;&gt; &lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;result column=&quot;uid&quot; property=&quot;user.id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;user.username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;user.password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; select * from orders o,user u where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 或 1234567891011&lt;resultMap id=&quot;orderMap&quot; type=&quot;com.itheima.domain.Order&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/result&gt; &lt;result property=&quot;ordertime&quot; column=&quot;ordertime&quot;&gt;&lt;/result&gt; &lt;result property=&quot;total&quot; column=&quot;total&quot;&gt;&lt;/result&gt; &lt;association property=&quot;user&quot; javaType=&quot;com.itheima.domain.User&quot;&gt; &lt;result column=&quot;uid&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;&gt;&lt;/result&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多 多对多 注解配置这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 基础增删改查1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=&quot;com.itheima.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=&quot;com.itheima.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt; 1234567891011@Insert(&quot;insert into user values(#{id},#{username},#{password},#{birthday})&quot;)public void save(User user);@Update(&quot;update user set username=#{username},password=#{password} where id=#{id}&quot;)public void update(User user);@Delete(&quot;delete from user where id=#{id}&quot;)public void delete(int id);@Select(&quot;select * from user where id=#{id}&quot;)public User findById(int id); 复杂关系查询实现复杂关系映射之前我们可以在映射文件中通过配置&lt;resultMap&gt;来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 一对一 一对多 多对多","link":"/2021/01/22/SSM%E6%A1%86%E6%9E%B6-Mybatis/"},{"title":"SSM框架整合","text":"​ Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 ​ Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC 分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 SSM整合总体思路12345678910111213141516171819202122232425262728//Spring配置文件## spring-dao.xml * &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;引入propeties配置文件 * datasource数据库连接池对象注入 * sqlSessionFactory对象注入 * 扫描dao配置对象注入## spring-mvc.xml * 扫描web相关包中注解&lt;context:component-scan base-package=&quot;com.jack.controller&quot; /&gt; * &lt;mvc:default-servlet-handler/&gt;静态资源放行 * &lt;mvc:annotation-driven /&gt;json返回体时，直接return对象 * 视图解析器对象注入## spring-service.xml * 扫描service相关包中注解&lt;context:component-scan base-package=&quot;com.jack.service&quot; /&gt; * 事务管理器对象注入## applicationContext.xml * import三个spring配置文件## jdbc.properties * 数据库相关数据：driver，url，username，password## log4j.properties * 百度抄## mybatis-config.xml * configuration中标签（setttings,typeAliases,mappers）## web.xml * DispatcherServlet前段控制器 * spring的监听器配置(括一个全局的applicationContext地址初始化参数) * 中文字符乱码字符过滤的filter * session的配置(期时间)session-config * 默认首页设置welcome-file-list SSM整合需要导入的maven依赖包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Personnel&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 导入ssm框架的pom依赖jar包--&gt; &lt;dependencies&gt; &lt;!--Junit测试框架--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.14&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--log4j日志--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--邮件服务--&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--定时任务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--json转化--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- maven的静态资源导出问题--&gt; &lt;build&gt; &lt;finalName&gt;personnel&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定web.xml的路径 --&gt; &lt;webXml&gt;web\\WEB-INF\\web.xml&lt;/webXml&gt; &lt;!-- 指定jsp、js、css的路劲 --&gt; &lt;warSourceDirectory&gt;web&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.12.4&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; SSM框架整合流程建立项目基本框架 com.jack.pojo com.jack.dao com.jack.service com.jack.controller database.properties mybatis-config.xml applicationContext.xml spring spring-dao.xml spring-mvc.xml spring-service.xml 数据库配置文件：database.properties1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/pdb?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=falsejdbc.username=rootjdbc.password=root Mybatis的核心配置文件：mybatis-config.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 设置：懒加载，日志实现，缓存开启关闭--&gt; &lt;settings&gt; &lt;!-- STDOUT_LOGGING是mybatis标准的日志，如果用第三方日志log4j需要导入包--&gt; &lt;!-- &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;log4j&quot;/&gt; &lt;!-- 开启驼峰命名映射规则--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启全局缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 开启mapper.xml文件的resultMap自动映射:注意等级PARTIAL&amp;FULL--&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;FULL&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.jack.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;!-- &lt;mappers&gt;--&gt;&lt;!-- &lt;package name=&quot;com.jack.dao&quot;/&gt;--&gt;&lt;!-- &lt;/mappers&gt;--&gt;&lt;/configuration&gt; Mapper接口对应的Mapper.xml文件12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.kuang.dao.BookMapper&quot;&gt; &lt;!--增加一个Book--&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName,bookCounts,detail) values (#{bookName}, #{bookCounts}, #{detail}) &lt;/insert&gt; &lt;!--根据id删除一个Book--&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID=#{bookID} &lt;/delete&gt; &lt;!--更新Book--&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName = #{bookName},bookCounts = #{bookCounts},detail = #{detail} where bookID = #{bookID} &lt;/update&gt; &lt;!--根据id查询,返回一个Book--&gt; &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID = #{bookID} &lt;/select&gt; &lt;!--查询全部Book--&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; SELECT * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; Spring整合Mybatis的配置文件：spring-dao.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:log4j.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt; &lt;context:property-placeholder location=&quot;classpath:mail.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--扫描dao配置对象注入:用于替代mybatis文件的扫描包--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.jack.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Spring整合service层：spring-service.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!-- &lt;context:property-placeholder location=&quot;classpath:*.properties&quot;/&gt;--&gt; &lt;!-- 扫描service相关的bean --&gt;&lt;!-- 如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类，则把这些类注册为bean--&gt; &lt;context:component-scan base-package=&quot;com.jack.service&quot; /&gt;&lt;!-- 发送邮件--&gt; &lt;!--邮件配置--&gt; &lt;!--配置邮件接口--&gt; &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt; &lt;property name=&quot;host&quot; value=&quot;${mail.smtp.host}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${mail.smtp.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${mail.smtp.password}&quot;/&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;${mail.smtp.defaultEncoding}&quot;/&gt; &lt;property name=&quot;javaMailProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;mail.smtp.auth&quot;&gt;${mail.smtp.auth}&lt;/prop&gt; &lt;prop key=&quot;mail.smtp.timeout&quot;&gt;${mail.smtp.timeout}&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 平台事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!--事务增强--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--事务的aop增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.jack.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt;&lt;/beans&gt; 配置web.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet：springmvc的核心配置--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--全局的初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--encodingFilter:乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;pages/admin-login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; spring整合controller层：spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt;&lt;!-- &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;--&gt;&lt;!-- &lt;mvc:resources location=&quot;/img/&quot; mapping=&quot;/img/**&quot; /&gt;--&gt;&lt;!-- &lt;mvc:resources location=&quot;/plugins/&quot; mapping=&quot;/plugins/**&quot; /&gt;--&gt;&lt;!-- &lt;mvc:resources location=&quot;/pages/&quot; mapping=&quot;/pages/**&quot; /&gt;--&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.jack.controller&quot; /&gt;&lt;/beans&gt; Spring整合文件，applicationContext.xml1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring/spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring/spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring/spring-mvc.xml&quot;/&gt;&lt;/beans&gt; 分模块Maven工程整合SSM框架Maven工程的继承 继承的目的是为了消除 maven坐标重复 Maven工程的聚合","link":"/2020/10/19/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"},{"title":"git基础","text":"git的安装​ 官网下载后，在cmd中输入git验证是否安装完成 git的基本配置12git config --global user.name &quot;name&quot;git config --global user.email &quot;email&quot; ​ 需要注意的是可以有三种参数，local、global和system，优先级依次降低。global是全局配置，local可以为本地项目添加单独配置 ​ 查看配置命令： 1git config -l --global(或其他两个) git配置文件位置 本地项目配置文件：当前项目/.git/config 1git config --local XXX 全局配置文件：~/.gitconfig 1git config --global XXX 系统配置文件：/etc/.gitconfig（需要root权限） 1git config --system XXX 三种免密登录方式 URL中体现： 12345原来：https://github.com/YangFanJack/DesignPattern.git免密：https://用户名:密码@github.com/YangFanJack/DesignPattern.gitgit remote add origin https://用户名:密码@github.com/YangFanJack/DesignPattern.gitgit push origin master SSH实现： 12345//生成公钥和私钥，在用户的.ssh文件夹里面把公钥添加到远程仓库github里面ssh-keygen -t rsa -C &quot;youremail&quot; //生成两把钥匙ssh -T git@github.com //验证ssh配置是否配置好//注意：如果提示找不到ssh-keygen命令的错误，说明你执行这条命令的位置错了，应该在本地的git仓库根目录下执行 git自动管理凭证 1//基于操作系统的功能，不同操作系统的实现方式不一样 git基本操作 ​ 第一步 12345git init //初始化，让git帮助管理文件夹git status //检测当前目录下文件状态git add //工作区到暂存区git commit -m &quot;注释&quot; //暂存区到版本库，生成版本/快照git diff //查看修改内容 ​ 从现在回溯到历史，和从历史回溯到将来 123456789git log //查看提交历史git log --pretty=oneline --graph --abbrev-commit //以图线的方式精简显示版本历史//git中使用HEAD表示当前版本git reset --hard 版本号(HEAD^,HEAD^^,HEAD~n) //回滚//如果想从前面回到后面，使用git reflog查看你的每一次操作，然后使用git reset --hardgit reflog //查看命令历史git reset --hard 版本号 ​ git reset 三种模式 12345git reset --hard 版本号：重置stage区和工作目录git reset --soft 版本号：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区git reset --mixed(默认) 版本号：保留工作目录，并清空暂存区 ​ 与版本库内容进行比较 12345//显示暂存区和工作区的差异git diff 文件名//显示暂存区和上一次提交(commit)的差异git diff --cached 文件名git diff --staged 文件名 ​ 暂存区文件撤销 123456git reset HEAD 文件名git rm --cached 文件名git restore --staged 文件名//如果暂存区有该文件，工作区和暂存区统一，如果没有，工作区和版本库统一git checkout -- 文件名 ​ git的分支操作 12345678git branch //显示本地所有分支git branch -r //显示远程所有分支git branch -a //显示本地和远程所有分支git branch 分支名 //创建分支git checkout 分支名 //切换分支git checkout -b 分支名 //创建并切换分支git branch -d 分支名 //删除分支git merge 其他分支名 //合并其他分支到当前分支，可能产生冲突，手动修改冲突文件 ​ git的删除操作 12345678910//手动删除工作区的文件后可以恢复//git restore指令使得在工作空间但是不在暂存区的文件撤销更改(内容恢复到没修改之前的状态)git restore 文件名git rm (-r -f) XXgit commit -m &quot;直接同步删除操作到本地仓库&quot;rm (-r -f) XXgit add XXgit commit -m &quot;需要先add，再同步删除操作到本地仓库&quot; 问题：远程已经修改，然后你没pull就修改了本地，push时发生了错误解决：错误发生后，先pull，在本地中的冲突文件中按照需求修改文件，最后再push 经过上述步骤已经能实现本地多分支开发，假设目前开发进度如下图所示： ​ 远程仓库操作（以github为例） 1234567891011121314151617181920212223242526272829303132333435363738//查看关联的远程仓库git remotegit remote -vgit remote show origin//连接可以是http，也可以是sshgit remote add origin http://github.com/YangFanJack/xxxxx.gitgit remote rm origin//-u表示以后默认都是origin这个地址git push -u origin master//git clone已经包含了remote add origin操作git clone http://github.com/YangFanJack/xxxxx.git//接上图继续开发git checkout dev //切换到需要拉取并合并的分支git merge master //将dev更新为最新版本[仅1次]（上次开发结束时最新版本在master主分支上）（继续开发...）git add .git commit -m XXXgit push origin dev//异地拉取代码继续开发git checkout devgit pull origin dev（继续开发...）git add .git commit -m XXXgit push origin dev//某一个阶段代码开发完后，合并dev到mastergit checkout mastergit merge devgit push origin mastergit checkout devgit merge mastergit push origin dev ​ pull=fetch+merge 1234git pull origin devgit fetch origin devgit merge origin/dev rebase(变基)​ 应用场景一：多版本记录合并为一个版本记录 1234git rebase -i HEAD~2 //HEAD和之前的1个合并git rebase -i 版本号 //HEAD到该版本之前合并//注意：合并版本的时候不要包含已经push到远程仓库的版本 ​ 应用场景二：将另一个分支(dev)的版本强插到当前版本(master)中 1234git checkout devgit rebase mastergit checkout mastergit merge dev ​ 应用场景三：pull后产生冲突（公司上次开发没提交，在家继续开发，去公司pull代码时） 123456789101112131415//会产生分支git pull origin dev = git fetch origin dev + git merge origin/dev//不会产生分支git fetchgit fetch origin dev + git rebase origin/dev//git fetch这个命令会把远程的commits拉取到本地的repo中，但是，它不是直接把commits接在分支的最后面，而是从你最后一次push的那个commit节点，再拉取一个新的分支出来，类似这样： * git fetch拉下来的节点，建立在一个新的分支上* / 你还没push的节点|/* 你最后一次push的节点|* 注意：git rebase可能有冲突，解决后 git add，然后 git rebase –continue 就可以 beyond compare冲突解决软件 安装bcompare软件 在git中配置 123git config --local merge.tool bc3git config --local mergetool.path 'usr/bin/bcompare'git config --local mergetool.keepBackup false 调用beyond compare解决冲突 1git mergetool 多人协同开发gitflow工作流 ​ 协同开发的两种方式： 自己账户下创建仓库，然后在setting里邀请其他github用户参与项目 建立组织，在组织下创建仓库，再邀请其他github用户参与项目 ​ 建立tag标签： 123456789101112git tag -a v1 -m &quot;第一版&quot; //默认是HEAD处创建taggit tag -a v1.2 9fceb02 -m &quot;my tag&quot;git tag -d v1 //删除版本git tag //列出本地所有taggit push origin --tagsgit show v1.0 //显示标签处的commitgit tag -d &lt;tagname&gt; //删除一个本地标签；git push origin :refs/tags/&lt;tagname&gt; //删除一个远程标签。 协同开发第一步：master分支建立12345678910111213141516git initgit touch TestClass.javavim TestClass.javajavac TestClass.javajava TestClassgit add .git commit -m &quot;Hello,world!&quot;git remote add origin git@github.com:queer-coder/test.gitgit push -u origin mastergit tag -a v1 -m &quot;第一版&quot;git taggit push origin v1.0git push origin --tags 协同开发第二步：dev分支，ddz分支建立1234567891011121314151617181920212223git branchgit checkout -b dev//邀请另外用户进组织//组织中setting可设置成员权限，默认是只读//项目中setting可以单独设置成员拥有写权限//另一个用户clone代码到本地开发斗地主分支git checkout -b ddztouch Doudizhu.javavim Doudizhu.javajavac Doudizhu.javajava Doudizhugit add .git commit -m &quot;斗地主&quot;git push origin ddzvim Doudizhu.javajavac Doudizhu.javajava Doudizhugit add .git commit -m &quot;斗地主开发完毕&quot;git push origin ddz 协同开发第三步：dev管理者review ddz开发者代码 注意： release——》master分支具体是需要线上代码review还是直接本地merge要看项目需求 开发分支——》dev分支必须要线上代码review，不能本地merge 通过github的pull request来实现代码review ​ dev成员(owner)：打开项目的setting——》branches——》add rule（跟dev合并必须要经过review）——》(开发成员pull request后)在pull request中add your review，然后merge pull request就实现了review后的同意合并，最后可删除ddz开发分支 ​ 斗地主开发成员(member)：new pull request——》compare to base 123//在线上github中同意merge后，线上dev已经最新了//dev管理者owner本地再pull一下，本地就也就最新了git pull origin dev 协同开发第四步：测试12345678910111213//代码测试分支由owner创建push到githubgit checkout devgit checkout -b releasegit push origin release//代码测试人员从github拉取release分支来进行代码测试//测试完后，将release版本merge到master分支和dev分支（同样采用review的方式来pull request）//删除release分支//本地的master拉取线上master，打上第二版标签git pull origin mastergit tag -a v2 -m &quot;第二版&quot; 如何给开源项目贡献代码 fork + pull request fork源代码 git clone 自己仓库的源代码到本地 做二次开发，bug修复 给开源项目作者提交 修复bug 的申请（pull request），把自己仓库的某个分支提交给原作者 等待源代码作者审核通过 实际开发中一些约定的分支名： master: 主分支，主要用来版本发布。 develop：日常开发分支，该分支正常保存了开发的最新代码。 feature：具体的功能开发分支，只与 develop 分支交互。 release：release 分支可以认为是 master 分支的未测试版。比如说某一期的功能全部开发完成，那么就将 develop 分支合并到 release 分支，测试没有问题并且到了发布日期就合并到 master 分支，进行发布。 hotfix：线上 bug 修复分支 再探： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！ 提示：changes not staged for commit 解决：应该先git add 提示：changes to be commit 解决：表示可以git commit了 提示：nothing to commit，working tree clean 解决：没有需要提交的修改，且工作目录是干净的 git diff 比较的是工作区文件与暂存区文件（上次git add 的内容）的区别 当暂存区中没有文件时，git diff比较的是，工作区中的文件与上次提交到版本库中的文件。 当暂存区中有文件时，git diff则比较的是，当前工作区中的文件与暂存区中的文件。 git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别 git diff HEAD 比较的是工作区中的文件与版本库中文件的差异 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 12#因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去git merge --no-ff -m &quot;merge with no-ff&quot; dev 你正在开发一个新功能，突然接到一个bug，必须优先解决bug，此时可以使用stash把当前工作区现场“储藏”起来，然后新建分支改bug再合并后，恢复之前”储藏“的工作现场就行了 123456789git stash //储藏工作现场... //改buggit stash list //查看工作现场列表//有两种方法恢复//1. 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除git stash applygit stash drop//2. 另一种方式是用git stash pop，恢复的同时把stash内容也删了git stash pop 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支 多人协作开发： 1234567891011git clone git@github.com:michaelliao/learngit.gitgit checkout -b dev origin/devgit add env.txtgit commit -m &quot;add env&quot;git push origin dev#push发现有冲突git pull#pull也失败，因为没有建立远程和本地的关闭git branch --set-upstream-to=origin/dev devgit pull#解决冲突后最后push成功 标签是指向commit的死指针，分支是指向commit的活指针 自定义Git 让Git显示颜色：git config –global color.ui true 忽略特殊文件：.gitignore文件 忽略原则： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 检验.gitignore的标准是git status命令是不是说working directory clean 使用命令git check-ignore -v App.class检查文件是否被忽略 把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。 12345678# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class# 不排除.gitignore和App.class:!.gitignore!App.class 配置别名 git config –global alias.st status 1234git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch rebase 致命问题：两个分支合并后为什么还存在不同？ 答：首先需要明确的是：git的merge以来的不是不同分支文件内容的对比，而是不同分支的commit的对比 举个例子： 123git merge test //在dev上合并test，此时dev包含test... //然后在dev上新建一个分支hotfix，把刚刚从test合并来的内容中，删除一些新增文件，增加一些删除文件，增删改一些修改行，然后将hotfix合并到devgit merge test //再进行一次第一步操作，此时发现虽然merge了，但是dev并不包含test中修改的内容了，因为此时dev包含了test的所有commit，此足矣。 如何改进工作中对git使用来避免此类问题的发生？ 工作中的产生原因：公司中项目分为test、dev、release、master分支，pull到本地新建xx-test、xx-dev分支进行修改，然后合并到对应的test、dev分支。经常还在线上的test、dev、release之间相互merge，导致问题出现的原因就是这个”相互“。 要避免这样的问题就要强制要求提交顺序，应该按照功能新建分支来完成","link":"/2020/03/03/git%E5%9F%BA%E7%A1%80/"},{"title":"javaWeb核心:servlet细节","text":"HTTP协议： 概念：Hyper Text Transfer Protocol 特点： 基于TCP/IP的应用层协议 默认端口是80 基于请求响应模型，一次请求一次响应 无状态的；每次请求之间相互独立，不能交互数据 历史版本： 1.0版本：每次请求都会建立新的连接 1.1版本：每次连接建立后会等一会儿，如果有新的请求会复用 请求消息数据格式 请求行 12请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1 HTTP协议有7中请求方式，常用的就是GET和POST GET：请求参数在请求行中；请求url长度有限制；相对不安全 POST：请求参数在请求体中；请求url长度没有限制；相对安全 请求头 1请求头名称: 请求头值 常见请求头： User-Agent：浏览器告诉服务器浏览器的版本信息 Accept：浏览器告诉服务器可以给我响应什么格式的信息 Referer：浏览器告诉服务器我从哪里来（防盗链 &amp; 统计） Connection：这个请求连接此时的状态（1.0和1.1有区别） 请求空行 用来分隔请求头和请求体 请求体 只有POST请求方式有请求体， 12请求参数=请求参数值username=zhangsan 响应消息数据格式 响应行 12协议/版本 响应状态码 状态码描述HTTP/1.1 200 OK 响应状态码：服务器告诉客户端本次请求和响应的一个状态 1xx：服务端正在接收客户端信息，没有接收完全，等待一段时间后，发送1xx状态码 2xx：成功 3xx：302重定向，304访问本地缓存 4xx：404客户端错误（请求路径没有对应的资源）；405请求方式没有对应的doXXX方法 5xx：500服务器端错误（服务器内部出现异常，控制台和网页一般都会报错） 响应头 1响应头名: 响应头值 常见的响应头： Content-type：服务器告诉浏览器本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 默认：in-line attachment;filename=xxx：以附件形式打开响应体（文件下载） 响应空行 用来分隔响应头和响应体 响应体 网页文件 &amp; 其他打回浏览器的数据（图片，视频等） 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello,world! &lt;/body&gt;&lt;/html&gt; HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 Request对象 request &amp; response 原理图 request对象继承体系结构 12345ServletRequest --接口 |HttpServletRequest --接口 |org.apache.catalina.connector.RequestFacade 类（tomcat） request功能 获取请求行数据 12请求方式 请求url 请求协议/版本GET /bbs/login.html?username=jack HTTP/1.1 12345678String getMethod();//请求方式GETString getContextPath();//虚拟目录/bbsString getServletPath();//srevlet资源路径 /login.htmlString getQueryString();//获得请求参数 username=jackString getRequestURI();//获取请求uri /bbs/login.htmlString getRequestURL();//获取请求url http://localhost:8080/bbs/login.htmlString getProtocol();//获取协议，版本 HTTP/1.1String getRemoteAddr();//获取客户端ip地址 获取请求头数据 12String getHeader(String name);//根据请求头名称获得请求头值Enumeration&lt;String&gt; getHeaderName();//获取所有请求头名称 获取请求体数据 12BufferedReader getReader();//获取字符输入流，只能操作字符数据ServletInputStream getInputStream();//获取字节输入流，可以操作所有类型数据 其他功能 123456789101112131415161718 //获取请求参数通用方式（get和post通用） String getParameter(String name);//根据参数名获得参数值 String[] getParameterValues(String name);//根据参数名称获得参数值的数组 String getParameterNames();//获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap();//获取所有参数的map集合，使用BeanUtils工具类的populate方法能把map直接转化为javabean对象 //BeanUtils工具类操作的是属性，不是成员变量 //请求转发：服务器内部的资源跳转方式 RequestDispatcher getRequestDispatcher(String path);//获得请求转发器对象 void forward(ServletRequest request, ServletResponse response);//请求转发,dispatcher类的方法 //共享数据：request域代表一次请求的范围，一般用于请求转发的多个资源共享数据void setAttribute(String name,Object obj); Object getAttribute(String name); void removeAttribute(String name); //获取servletContext ServletContext getServletContext();//返回servletContext对象 请求转发的特点： 浏览器地址栏不发生变化 转发是在web服务器内部进行的，不能跨域访问 转发只有一次请求 Response对象1234567//设置响应行void setStatus(int sc);//设置响应头void setHeader(String name,String value);//设置响应体PrintWriter getWriter();//字符输出流ServletOutputStream getOutputStream();//字节输出流 12345//重定向1response.setStatus(302);response.setHeader(&quot;location&quot;,&quot;/jack/responseDemo2&quot;);//重定向简单方式response.sendRedirect(&quot;jack/responseDemo2&quot;); 重定向的特点： 浏览器地址栏会发生变化 重定向可以访问其他站点的资源 重定向有两次请求 什么时候用重定向,什么时候用请求转发？ 需要使用了request域的时候,必须用请求转发。 访问站外资源的时候用重定向。 其他随意 相对路径和绝对路径区别？ 相对路径：不以/开头，以./..开头 绝对路径：以http://localhost/虚拟路径/资源路径或者简写为/虚拟路径/资源路径的形式 路径从客户端浏览器发出请求，需要加虚拟目录 从服务器发出，不需要加虚拟目录 动态获得虚拟目录：request.getContextPath(); web整个过程的中文编码问题解析 1234567//post请求参数通过getParameter方式乱码，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);//写会数据到浏览器的汉字编码问题解决response.setCharacterEncoding(&quot;utf-8&quot;);response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);//简单形式设置ContentTyperesponse.setContentType(&quot;text/html;charset=utf-8&quot;); ServletContext对象 代表整个web应用，可以和程序的容器（tomcat）来通信 功能： 获得MIME类型： 域对象：共享数据 获取文件的真实路径 123456789101112131415161718//通过request对象获取request.getServletContext();//通过HttpServlet实现类中方法获取this.getServletContext();//获得MIME类型：互联网通信中一种定义的文件数据类型（text/html,text/css,text/jpeg...）,所有文件后缀和mime的对应关系都存在tomcat服务器的web.xml中String getMimeType(String file);//域对象：共享所有用户所有请求的数据void setAttribute(String name,Object obj);Object getAttribute(String name);void removeAttribute(String name);//获取文件的真实路径String getRealPath(String path);context.getRealPath(&quot;/a.html&quot;);//web目录下context.getRealPath(&quot;/WEB-INF/b.html&quot;);//WEB-INF目录下context.getRealPath(&quot;/WEB-INF/classes/c.java&quot;);//src目录下 会话技术 会话：浏览器第一次给服务器发送请求会话建立，直到一方断开连接会话结束。 一次会话包含到了多次请求&amp;响应 功能：在一次会话范围内共享数据，弥补http协议无状态特点的不足。 Cookie：客户端会话技术 作用：将数据保存在客户端 123456//创建cookie对象，绑定数据new Cookie(String name,String value);//发送cookie对象response.addCookie(Cookie cookie);//获取cookie，拿到数据Cookie[] cookies = request.getCookies(); Cookie原理： Cookie的细节 一次能否发送多个cookie？ 能，创建多个Cookie对象，然后调用response.addCookie函数即可 cookie在浏览器中保存多长时间？ 默认情况下，浏览器关闭就没了 持久化存储：setMaxAge(int seconds)：正数代表存储秒数且放进了硬盘，负数默认，零删除cookie cookie能否存中文？ tomcat8之后开始支持中文存储，tomcat8之前需要URL编码解码（URLEncoder.encode(String s,”utf-8”) &amp; URLDecoder.decode(String s,”utf-8”)） cookie获取范围多大？ 同一个服务器的多个web项目能否共享cookie？ 默认情况下cookie不能共享 通过setPath(String path)设置cookie获取范围，如果需要共享，可以设置为setPath(“/“) 不同tomcat服务器间怎么共享cookie？ setDomain(String path)：如果设置一级域名相同，那么多个服务器间就可以共享了，例如setDomain(“.baidu.com”)则tieba.baidu.com和news.baidu.com间就可以共享cookie了 Cookie特点和作用？ 特点： cookie存在客户端浏览器 浏览器对单个cookie的大小有限制 以及 对统一域名下的总cookie的数量也有限制 作用： 一般用于少量不太敏感的数据 在不登录的情况下，完成服务端对客户端身份的识别 Session：服务器端会话技术 作用：将数据保存在服务器端 123456//获得sessionHttpSession session = request.getSession();//操作共享数据void setAttribute(String name,Object obj);Object getAttribute(String name);void removeAttribute(String name); 原理：（Session的实现依赖于Cookie） 细节： 客户端关闭重启后，再次获取session是否是同一个？ 默认不是 ```java//手动设置session cookie可以延长session cookie存活时间，持久化Cookie c = new Cookie(“JSESSIONID”,session.getId());c.setMaxAge(60*60);reponse.addCookie(c); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 2. 服务器关闭重启后，再次获取session是否是同一个？ * 肯定不一样，session都是重新创建的 * 但是需要确保session不丢失 1. session钝化：在服务器正常关闭后，将session对象序列化到硬盘上 2. session活化：在服务器重启后，将session从硬盘转化为内存中您的session对象 3. session钝化和sessoin活化：tomcat会自动帮我们做好，但是idea为每个项目创建的catalina_base地址不会活化。 3. session什么时候被销毁： 1. 服务器关闭 2. session对象调用invalidate() 3. session默认失效时间30min，可以再tomcat的web.xml和项目的web.xml的`&lt;session-config&gt;&lt;session-timeout&gt;&lt;/session-timeout&gt;&lt;/session-config&gt;`中修改默认失效时间* 特点： 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据* 和cookie区别： 1. session存在服务器端，cookie存在客户端 2. session没有数据大小限制，cookie有 3. session数据相对安全，cookie相对不安全## JSP* Java Server Pages：java服务器端页面。* jsp本质就是一个servlet，可以查看IDEA每次运行都会生成的work目录，里面会有代码每次运行是生成的文件，就有jsp文件对应的java和class文件![image-20210316075647096](https://jack-blog-img.obs.cn-north-4.myhuaweicloud.com/github-page/img20220521224129.png)### 脚本* `&lt;% 代码%&gt;`：定义的java代码在service方法中，service方法中定义什么，该脚本就定义什么* `&lt;%! 代码%&gt;`：定义的java代码在jsp转化为serlvet后的成员变量位置* `&lt;%= 代码%&gt;`：定义的java代码，会输出到页面上，输出语句定义什么，该脚本就定义什么。其实在serlvet中就是out.print()### 指令* 用于配置jsp页面 &amp; 导入资源文件* 格式：`&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2%&gt;````jsp&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt;&lt;%@ include file=&quot;test.jsp&quot;%&gt; 分类： page：配置jsp页面 contentType：设置响应体的mime类型以及字符集 pageEncoding：当前jsp文件编码 language：目前只有java improt：导入java的jar包 buffer：out对象输出到页面的缓冲区 errorPage：页面出错后自动跳转的页面 isErrorPage：标识当前页面是否是错误界面（当前jsp页面能使用exception对象） include：页面包含，导入页面的资源文件 taglib：导入标签库 JSP中include指令和include动作区别 ＜%@ include file=” .jsp”%＞引入静态文本(html,jsp),在JSP页面被转化成servlet之前和它融和到一起 ＜jsp:include page=” .jsp” flush=”true” /＞只是在运行时引入了要添加的jsp页面执行后所产生的应答 注释 html注释：&lt;!--html标签--&gt;（浏览器看得到） jsp注释：&lt;%--Java代码/html标签--%&gt;（浏览器看不到） 在jsp页面中建议都使用jsp注释 EL表达式 Expression Language：表达式语言 作用：替换jsp页面中java代码的编写 语法：${表达式} 注意： JSP中默认支持el表达式 1&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isELIgnored=&quot;false&quot; %&gt; 使用： 运算：算数/比较/逻辑运算，empty运算符(判断字符串、集合、数组对象是否为null 或者 长度是否为0) 获取值：只能从域对象中获取值${域名称.键名}： pageScope——&gt;pageContext requestScope——&gt;request sessionScope——&gt;session applicationScope——&gt;application 如果只写键名，表示依次从最小的域中查找是否有该建对应的值，直到找到为止 如果域对象是对象，那么通过${域名称.键名.属性名}(Getter &amp; Setter)获取 如果域对象是List集合，那么通过${域名称.键名[n]}获取 如果域对象是Map集合，那么通过${域名称.键名.key名称}或者${域名称.键名[&quot;key名称&quot;]}获取 ${empty list},${not empty list} EL表达式中有11个隐式对象 很重要：${pageContext.request.contextPath}：动态获取虚拟目录 JSTL标签 JavaServer Pages Tag Library：JSP标准标签库 作用：简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入taglib 使用&lt;c:XX&gt;内容&lt;/c:XX&gt; 12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot;%&gt; if123&lt;c:if test=&quot;表达式&quot;&gt; 标签体内容&lt;/c:if&gt; 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用，test后的表达式一般用的是el表达式接收域对象动态数据做判断 choose12345678910&lt;c:choose&gt; &lt;c:when test=&quot;${number==1}&quot;&gt;星期一&lt;/c:when&gt; &lt;c:when test=&quot;${number==2}&quot;&gt;星期二&lt;/c:when&gt; &lt;c:when test=&quot;${number==3}&quot;&gt;星期三&lt;/c:when&gt; &lt;c:when test=&quot;${number==4}&quot;&gt;星期四&lt;/c:when&gt; &lt;c:when test=&quot;${number==5}&quot;&gt;星期五&lt;/c:when&gt; &lt;c:when test=&quot;${number==6}&quot;&gt;星期六&lt;/c:when&gt; &lt;c:when test=&quot;${number==7}&quot;&gt;星期日&lt;/c:when&gt; &lt;c:otherwise&gt;数字数据有误&lt;/c:otherwise&gt;&lt;/c:choose&gt; 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach123&lt;c:forEach items=&quot;${departmentPageBean.list}&quot; var=&quot;keyword&quot; varStatus=&quot;id&quot;&gt; for循环体&lt;/c:forEach&gt; begin：开始值 end：结束值 var：临时变量 step：步长 1234&lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot;&gt; ${i}&lt;br&gt;&lt;/c:forEach&gt; items：容器对象 var：容器中元素的临时变量 varStatus：循环状态对象，属性index和count index：从0开始（遍历容器的索引） count：遍历次数 12345&lt;c:forEach items=&quot;${departmentPageBean.list}&quot; var=&quot;keyword&quot; varStatus=&quot;id&quot;&gt; &lt;td&gt;${keyword.id}&lt;/td&gt; &lt;td&gt;${keyword.name}&lt;/td&gt; &lt;td&gt;${keyword.phone}&lt;/td&gt;&lt;/c:forEach&gt; JSP中9大内置对象 jsp页面中不需要获取和创建，可以直接使用的对象 内置对象 说明 request(域) 对应HttpServletRequest/ServletRequest对象 response 对应HttpServletRespons/ServletResponse对 session(域) 对应HttpSession对象 application(域) 对应ServletContext对象 out 对应JspWriter对象，其内部关联一个PrintWriter对象 page 后对应this config 对应ServletConfig对象 exception 对应Throwable对象，代表由其他JSP页面抛出的异常对象，只会出现于JSP错误页面(isErrorPage设置为true的JSP页面) pageContext(域) 对应PageContext对象，它提供了JSP页面资源的封装，并可设置页面范围，可以用来获取其他8个内置对象 response.getWriter()和out对象区别：response.getWriter()输出内容永远都会在out输出内容之前 MVC开发模式jsp历史 servlet：response输出标签 jsp：简化了servlet开发，大项目难以维护 java的web开发借鉴了MVC开发模式，程序设计更加合理（model1—&gt;model2） MVC： M：模型Model V：视图View（jsp中禁止写java代码了,利用el和jstl做展示工作） C：控制器Controller MVC优缺点： 优点： 耦合低，利于分工、维护 代码重用性高（C和M层代码） 缺点： 使得项目架构变得复杂，对开发人员要求高 三层架构 一种软件设计架构 分层 view表现层： 用于显示数据和接收用户输入的数据，为用户提供一种交互式操作的界面 service业务逻辑层：实现业务的主要逻辑，是系统架构中体现核心价值的部分。 Dao数据访问层：有时候也称为是持久层，其功能主要是负责数据库的访问。可以访问数据库、二进制文件、文本文件等。简单的说法就是实现对数据表的Select，Insert，Update，Delete的操作。如果要加入ORM的元素，那么就会包括对象和数据表之间的mapping，以及对象实体的持久化。","link":"/2020/03/25/javaWeb%E6%A0%B8%E5%BF%83-servlet%E7%BB%86%E8%8A%82/"},{"title":"java基础快速回顾-中","text":"Java某些类Object类 java的根类 toString() Object类的toString()方法默认返回该对象实现类的“类名+@+hashcode”值 看一个类是否重写了toString方法，可以通过直接打印对象名字，没有重写的显示对象地址值，重写的按照toString重写内容自定义打印 equals() Object类的equals()方法默认就是用==来进行比较 1234567891011121314151617181920public class Person{ public String name; public int age; @Override public boolean equals(Object obj){ Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age==p.age; }}public class Test{ public static void main(String[] args){ Person p1 = new Person(); p1.name = &quot;jack&quot;; p1.age = 10; Person p2 = new Person(); p2.name = &quot;sam&quot;; p2.age = 14; p1.equals(p2); }} Objects类 Objectsq工具类提供了一些静态方法来操作对象，这些方法是空指针安全，容忍空指针的 1234String s1 = null;String s2 = &quot;jack&quot;;System.out.println(s1.equals(s2));//会报空指针异常System.out.println(Objects.equals(s1,s2));//一切正常 Date类 毫秒是日期计算的最小单位 0毫秒点：1970年1月1日00:00:00（中国属于东八区，会+8小时） 日期转化为时间戳，就是距离0毫秒点经过了多少毫秒 1234import java.util.Date;Date date = new Date();//获取系统当前日期时间Date date = new Date(long ms);//时间戳转化为日期时间long ms = date.getTime();//把日期转化为毫秒时间戳 DateFormat类 根据自定义格式相互转化Date &amp; String 1234567891011//是抽象类，无法直接使用import java.text.DateFormat;//使用SimpleDateFormatimport java.text.SimpleDateFormat;//参数是格式(y年，M月，d日，H时，m分，s秒)DateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//两个方法：format(Date d)和parse(String s)DateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);Date date = new Date();String text = sdf.format(date);//Date——&gt;StringDate date2 = sdf.parse(text);//String——&gt;Date，这是一个抛异常的方 Calendar类12345678910111213141516//是抽象类，无法直接使用import java.util.Calendar;//获得Calendar类的子类对象Calendar c = Calendar.getInstance();int y = c.get(Calendar.YEAR);int m = c.get(Calendar.MONTH);//0——11int d = c.get(Calendar.Date);int h = c.get(Calendar.HOUR);int m = c.get(Calendar.MINUTE);int s = c.get(Calendar.SECOND);c.set(Calendar.YEAR,1999);c.add(Calendar.YEAR,2);//2001c.add(Calendar.YEAR,-4);//1997Date date = c.getTime();//Calendar——&gt;Date System类12345long s = System.currentTimeMillis();//一般用来测试程序执行时间//arraycopy(源数组，源数组中的起始位置，目标数组，目标数组中的起始位置，要复制的数组元素数量);int[] src = {1,2,3,4,5};int[] dest = {6,7,8,9,10};System.arraycopy(src,0,dest,0,3);//复制后dest={1,2,3,9,10} StringBuilder类 字符串底层是一个final常亮，每次对String修改后都需要新建一个String类型的对象，效率很低，为了应对这种情况，StringBuilder应运而生。 StringBuiler是字符串缓冲区，可以提高字符串操作效率，可以看做是长度可以变化的字符串，底层是一个不被final修饰的byte数组，初始容量16，在修改过程中如果不够会自动扩容 1234567StringBuilder sb = new StringBuilder(&quot;ab&quot;);StringBuilder sb2 = sb.append(&quot;cde&quot;);//返回sb自己，内部return thisSystem.out.println(sb == sb2);//true//String——&gt;StringBuilderStringBuilder sb = new StringBuilder(&quot;ab&quot;);//StringBuilder——&gt;StringString s = sb.toString(); 基本数据类型的包装类 目的是提供一些方法来操作数据类型 Byte Short Integer Long Float Double Character Boolean byte short int long float double character boolean 装箱：基本类型——&gt;包装类： 12Integer i = new Integer(1);Integer i = Interger.valueOf(1); 拆箱：包装类——&gt;基本类型： 1int ii = i.intValue(); 自动装拆箱 123ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);//自动装箱int a = list.get(0);//自动拆箱 基本类型和字符串之间转换： 基本类型——&gt;字符串 +&quot;&quot; 包装类中的静态方法toString String类中的静态方法valueOf 字符串——&gt;基本类型 包装类中的静态方法parseXX Java集合 会使用集合存储数据 会遍历集合，把数据取出来 掌握每种集合的特性 所有集合的父类：Collection Collection集合（单列集合） Collection&lt; T &gt; 公共方法： boolean add(E e) boolean remove(E e) void clear() boolean contains(E e) boolean isEmpty() int size() Object[] toArray() Iterator迭代器 boolean hasNext() E next() 123456789//通过Collection中的iterator()方法获得Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();coll.add(&quot;jack&quot;);coll.add(&quot;sam&quot;);Iterator&lt;String&gt; it = coll.iterator();while(it.hasNext()){ String s = it.next(); System.out.println(s);} 增强for123456Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();coll.add(&quot;jack&quot;);coll.add(&quot;sam&quot;);for(String s : coll){ System.out.println(s)} 泛型12345//含有泛型的类public class ArrayList&lt;E&gt;{ public boolean add(E e){} public E get(int index){}} 集合如果不使用泛型，默认就是Object类型 123456//含有泛型的方法//修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表){方法体}public static &lt;M&gt; void method(M m){ System.out.println(m);}//调用的时候传递什么参数就调用什么类型的方法 12345678910111213141516//含有泛型的接口public interface GenericInterface&lt;I&gt;{ public abstract void method(I i);}//第一种用法：实现的时候确定泛型public class GenericInterfaceImpl implements GenericInterface&lt;String&gt;{ public abstract void method(String s){ System.out.println(s); }}//第二种用法：创建对象的时候确定泛型public class GenericInterfaceImpl&lt;I&gt; implements GenericInterface&lt;I&gt;{ public abstract void method(I i){ System.out.println(i); }} 123456789//传值的时候：泛型通配符public static void printArray(ArrayList&lt;?&gt; list){ Iterator&lt;?&gt; it = list.iterator(); while(it.hasNext){ System.out.println(it.next()); }}//上限限定：? extends E：?只能是E的子类或本身//下限限定：? super E：?只能是E的父类或本身 List接口：Collection的第一个子类 有序的集合 允许存储重复的元素 有索引index，可以使用普通的for遍历 特有方法：(带索引) public void add(int index,E element) public E get(int index) public E remove(int index) public E set(int index,E element) Vector 底层是数组，查询快，增删慢 单线程（所以被ArrayList取代） ArrayList 底层是数组，查询快，增删慢 多线程 LinkedList 底层是双向链表，查询慢，增删快 多线程 特有方法： public void addFirst(E e) == public void push(E e) public void addLast(E e) == public void add(E e) public E getFirst() public E getLast() public E removeFirst() == public E pop() public E removeLast() Set接口：Collection的第二个子类 无序的集合 不允许存储重复元素（原理上来看，必须保证元素类重写hashcode和equals方法） 没有索引index，不能使用普通的for遍历，只能用迭代器遍历 TreeSet 底层是二叉树，一般用于排序 HashSet 底层是哈希表(数组+红黑树)实现的，查询速度极快 LinkedHashSet（有序） 底层是哈希表(数组+红黑树)+链表实现的，可以保证存取顺序 Collections工具类12345678Collections.addAll(list,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);//同时加多个Collections.shuffle(list);//打乱顺序Collections.sort(list);//按照默认顺序排序；要排序自定义类型，元素类必须实现Comparable接口，重写compareto方法Collections.sort(list,new Comparator&lt;String&gt;{ public int compare(Student o1, Student o2){ return o1.getAge()-o2.getAge();//升序 }}) Map集合（双列集合） Map&lt; K,V &gt; 双列集合，一个元素包含两个值 key不能重复，value不能重复，且一一对应 公共方法： public V put(K key,V value)：key存在返回null，key不存在返回被替代的value public V get(Object key)：key存在返回对应value，key不存在返回nul public V remove(Object key)：key存在返回被删除value，key不存在返回null public boolean containsKey(Object key)：判断是否包含指定key public boolean containsValue(Object value)：判断是否包含指定value keySet：Map集合的第一种遍历方式 1234567891011Set&lt;String&gt; set = map.keySet();//获得map集合的所有key，存在set集合中Iterator&lt;String&gt; it = set.iterator();while(it.hasNext()){ String key = it.next(); Integer value = map.get(key); System.out.println(value);}for(String key : set){ Integer value = map.get(key); System.out.println(value);} entryset：Map集合的第二种遍历方式 12345Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();for(Map.Entry&lt;String,Integer&gt; e : set){ System.out.println(e.getKey()); System.out.println(e.getValue());} 如果要存储自定义元素，对于key的元素，必须重写hashCode和equals方法来保证key唯一 HashMap 底层是哈希表(数组+红黑树) 无序 LinkedHashMap 底层是哈希表(数组+红黑树)+链表 有序(存储顺序==取出顺序) Hashtable 不能存储null键，null值，已经被hashmap取代 Hashtable的子类Properties依然在IO流中使用 JDK9中集合添加的优化 只适用于List，Set，Map接口 of返回值是一个不能改变的集合，之后不能再使用add，put等方法 Set和Map在调用of方法时，不能有重复的元素，否则会报错 123List&lt;String&gt; list = List.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);Set&lt;String&gt; set = Set.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;);Map&lt;String,Integer&gt; map = Map.of(&quot;张三&quot;,14,&quot;赵四&quot;,12,&quot;刘能&quot;,20); 可变参数 当参数列表数据类型确定，但是参数个数不确定，就可以使用可变参数 底层会根据传递参数的不同创建不同长度的数组（0到多个） 一个方法中最多有一个可变参数 如果参数有多个，可变参数必须写在参数列表最后 12345//实际上传递的是数组public static void add(int...arr){ System.out.println(arr); System.out.println(arr.length);} 异常 语法错误——&gt;编译失败 异常——&gt;编译/运行失败 Throwable的两个子类：Error 和 Exception Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 异常分类Exception：编译期异常 在方法名后 throws Exception：虚拟机中断程序打印处理 try catch处理异常：无需中断，程序正常执行 RuntimException：运行期异常 try catch处理异常 Error：错误 程序无法治愈，必须修改源码 异常产生过程 异常的处理 5个关键字：try、catch、finally、throw、throws throw 只能用在方法内部 后边的对象只能是Exception或者Exception子类对象 必须处理throw的异常对象 如果throw RuntimeException或者RuntimeException子类对象，可以自动交给JVM处理，自己不做手动处理 如果throw 编译期异常，必须手动处理，要么连续throws到jvm处理，要么try…catch… 1234567891011121314常见的编译期异常和运行期异常a)编译期异常： 1.ClassNotFoundException(类找不到异常) 2.FileNotFoundException（编译文件夹中找不到，就是发布到tomcat中的，不是工程中） 3.SQLException ：提供有关数据库访问错误或其他错误的信息的异常。（ 比如SQL语句写错，访问的表不存在，连接数据库失败等等） 4.IOexception：IO流异常。一般在读写数据的时候会出现这种问题。 5.EOFException:当输入过程中意外到达文件或流的末尾时，抛出此异常。b)运行期异常： 1.NullPointerException(空指针异常) 2.ArithmeticException（运算非法异常） 3.IndexOutOfBoundsException(数组越界异常) 4.ClassCastException(类转换异常) 5.ArrayStoreException(数据存储异常，操作数组时类型不一致) 6.BufferOverflowException(字节溢出异常—IO流操作) throws 一步一步往上抛 如果同时throw多个异常且含有父子关系，throws后面只需写 父类 try…catch… try中如果产生了异常，会直接执行catch中内容，之后执行try…catch后代码 try中如果没有异常，不会执行catch中内容，直接执行try…catch后代码 Throwable中的3个异常处理的方法 getMessage() toString() printStackTrace()：默认 finally 解决try语句块中异常后的代码无法执行的问题 不能单独使用，只能和try一起使用 一般用于资源释放 避免在finally语句中写return语句 异常处理时注意： 多异常分别处理，多异常一次捕获多次处理，多异常一次捕获一次处理 父类方法抛出多个异常，子类重写时只能抛出同样异常 or 异常子类 or 不抛 父类方法没有抛出异常，子类重写时也不能抛异常，如果子类有异常只能捕获 自定义异常类 继承Exception：编译时异常 继承RuntimeException：运行时异常 123456789101112131415161718public class MyException extends Exception { //异常信息 private String message; //构造函数 public MyException(){ super(); } public MyException(String message){ super(message); this.message = message; } //获取异常信息,由于构造函数调用了super(message),不用重写此方法 //public String getMessage(){ // return message; //}} 多线程 进程是操作系统资源分配的基本单位，负责为程序分配内存空间 而线程是任务调度和执行的基本单位，负责程序实际的执行 一个进程中至少有一个线程 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。 每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。 Thread类 java程序属于抢占式调度，哪个线程优先级高就会优先执行哪个线程；同一优先级会随机选择一个执行 12345678910111213141516class PrimeThread extends Thread{ public void run(){//重写Thread类的run方法 for (int i=0;i&lt;20;i++){ System.out.println(&quot;prime-----&gt;&quot;+i); } }}class MainTest{ public static void main(String[] args){ PrimeThread p = new PrimeThread(); p.start();//会调用线程的run方法，只能调用一次 for (int i=0;i&lt;20;i++){ System.out.println(&quot;main-----&gt;&quot;+i); } }} 多线程内存图 12345678910111213141516//获得指定线程名称PrimeThread primeThread = new PrimeThread();System.out.println(primeThread.getName());//获得当前线程名称System.out.println(Thread.currentThread().getName());//修改线程名称primeThread.setName(&quot;线程0&quot;);//也可以修改PrimeThread构造函数直接修改名字class PrimeThread extends Thread{ public PrimeThread(){ } public PrimeThread(String name){ super(name);//让父类Thread构造方法给子线程起名字 }} sleep方法 是当前正在执行的线程暂停 12345678class PrimeThread extends Thread{ public void run(){//重写Thread类的run方法 for (int i=0;i&lt;20;i++){ System.out.println(&quot;prime-----&gt;&quot;+i); Thread.sleep(1000);//1000毫秒==1秒 } }} Runnable类：创建多线程的第二种方式123456789101112131415public class RunnableImpl implements Runnable{ public void run(){ System.out.println(&quot;prime-----&gt;&quot;+i); }}class MainTest{ public static void main(String[] args){ RunnableImpl ri = new RunnableImpl(); Thread t = new Thread(ri) t.start();//会调用线程的run方法，只能调用一次 for (int i=0;i&lt;20;i++){ System.out.println(&quot;main-----&gt;&quot;+i); } }} 好处： Runnable方式避免了单继承的局限性 Runnable方式降低了耦合性：RunnableImpl设置线程 &amp; Thread开启线程 解耦 使用匿名内部类的方式创建线程 Thread和Runnable两种方式都可以 线程安全问题 多线程访问了共享的数据，会出现线程安全问题 这种线程安全问题是不能发生的，我们要确保某个时刻只能由一个线程访问共享资源 解决线程安全问题 同步代码块 123synchronized(同步锁){ //多线程访问共享数据的代码} 同步方法 方法修饰符：synchronized 123456789public synchronized void method(){ //多线程访问共享数据的代码 //锁对象是this对象}//静态同步方法public static synchronized void method(){ //多线程访问共享数据的代码 //锁对象是本类的class属性对象} Lock锁机制 Lock接口中的两个方法： void lock()：获取锁 void unlock()：释放锁 1234567Lock l = new ReentrantLock();//创建类的成员变量l//在某个方法中l.lock();//多线程访问共享数据的代码l.unlock(); 线程状态1Thread.State：Thread类的内部类State 一共6种状态 sleep(参数) 和 wait(参数) 其实都是一样的 notify() 是唤醒一个等待的线程，notifyAll()是唤醒所有等待的线程 线程间通信（等待唤醒机制） 多个线程处理同一个资源，一个生产，一个消费 wait和notify方法必须要使用同一个锁对象调用 wait和notify方法属于Object类的方法 wait方法和notify方法必须在同步代码块或者同步函数中使用 生产者&amp;消费者问题 以包子铺为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//包子类（锁对象）public class BaoZi { String pi; String xian; boolean flag = false;}//包子铺类（生产者）public class BaoZiPu extends Thread{ private BaoZi bz; public BaoZiPu(BaoZi bz) { this.bz = bz; } @Override public void run() { while (true){ synchronized (bz){ if(bz.flag == true){ try { bz.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } bz.pi = &quot;薄皮&quot;; bz.xian = &quot;三鲜馅&quot;; System.out.println(&quot;包子铺正在生产&quot;+bz.pi+bz.xian+&quot;的包子&quot;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } bz.flag = true; bz.notify(); System.out.println(&quot;包子铺已经生产好了包子&quot;); } } }}//吃货类（消费者类）public class ChiHuo extends Thread{ private BaoZi bz; public ChiHuo(BaoZi bz) { this.bz = bz; } @Override public void run() { while (true){ synchronized (bz){ if(bz.flag == false){ try { bz.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(&quot;吃货正在吃&quot;+bz.pi+bz.xian+&quot;的包子&quot;); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } bz.flag = false; bz.notify(); System.out.println(&quot;吃货已经吃完了包子&quot;); System.out.println(&quot;*************************************&quot;); } } }}//测试类public class MainTest { public static void main(String[] args) { BaoZi bz = new BaoZi(); new BaoZiPu(bz).start(); new ChiHuo(bz).start(); }} 线程池 线程池就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建对象的操作，无需反复创建线程而消耗过多资源 123456789//java.util.concurrent.Executors:线程池的工厂类//生产一个指定线程数量的线程池ExecutorService es = Executors.newFixedThreadPool();//实现一个Runnable实现类//调用ExecutorService中的方法submit，执行线程es.submit(new RunnableImpl());es.submit(new RunnableImpl());es.submit(new RunnableImpl());//调用ExecutorService中的方法shutdown销毁线程池","link":"/2021/03/06/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%AD/"},{"title":"java基础快速回顾-下","text":"Lambda表达式 匿名内部类可以省去定义实现类，但是语法太复杂 lambda表达式不关注面向对象，返璞归真，仅仅关注内容本身。 12//一些参数，一个箭头，一段重写代码() -&gt; System.out.println(&quot;lambda&quot;); 将Runnable接口作为参数进行传递，可以使用两种方法： 使用lambda必须满足接口中有且仅有一个抽象方法 有且仅有一个抽象方法的接口称为 “函数式接口” Lambda的省略写法有如下要求： 括号中参数列表的数据类型可以省略 括号中的参数只有一个，那么类型和（）都可以省略 如果{}的代码只有一行，都可以省略{} return 分号，且必须要一起省略，不能只省略部分 FIle类 文件和目录的抽象表示，用于文件&amp;目录的创建、查找和删除等操作 12345678//File类的4个成员变量//路径分隔符(windows分号,linux冒号)static String pathSeparator;static char pathSeparatorChar;//默认名称分隔符(windows反斜杠，linux正斜杠)static String separator;static char separator;//注意：操作路径的时候，路径不能写死了，根据不同系统更换 File构造函数 12345678910111213/** File(String pathname); File(String parent,String child); File(File parent,String child) 路径可以是文件名，也可以是文件夹名 可以相对路径，也可以绝对路径 路径可以是存在的，也可以是不存在的 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况**/public static void main(){ File f1 = new File(&quot;/home/jack1024/桌面/a.txt&quot;); File f2 = new File(&quot;/home/jack1024/桌面/a&quot;);} File类常用方法： 1234public String getAbsolutePath();//文件/目录绝对路径名字符串（无论构造方法中传递相对还是绝对，都返回绝对路径）public String getPath();//文件/目录路径名字符串（构造方法中传递的字符串）public String getName();//文件/目录名字public long length();//文件字节大小(目录没有大小概念) 判断功能： 123public boolean exists();//该文件/目录是否存在public boolean isDirectory();//是否为目录public boolean isFile();//是否为文件 创建 &amp; 删除 1234public boolean createNewFile();//当该名字的文件不存在时，创建一个新的空文件public boolean delete();//删除由此File表示的文件或目录，不走回收站public boolean mkdir();//创建由此File表示的目录public boolean mkdirs();//创建由此File表示的目录，包括任何必须但不存在的父目录 目录遍历 包含隐藏文件/文件夹 12public String[] list();//返回一个String数组，表示该File目录中所有子文件或目录public File[] listFiles();//返回一个File数组，表示该File目录中所有子文件或目录 递归 直接递归 &amp; 间接递归 递归一定要有停止的条件约束，否则会出现栈内存溢出StackOverFlowError 递归的次数也不能太多，否则也可能发生栈内存溢出 构造方法中禁止递归 递归图示： 文件过滤器12public File[] listFiles(FileFilter filter);public File[] listFiles(FilenameFilter filter); 通过重写accept()方法来实现 IO流 字节流字节输出流 OutputStream：所有输出字节流的超类，接下来主要探讨其子类FileOutputStream： close()：释放资源 flush()：刷新此输出流并强制写出所有缓冲的输出字节 void write(byte[] b)：往文件写入多个字节 void write(int b)：往文件写入一个字节 void write(byte[] b,int off,int len)：往文件写入指定位置指定长度的放入的数组中的字节 FileOutputStream构造方法： FileOutputStream(File file) FileOutputStream(String name) FileOutputStream(File file, boolean append) FileOutputStream(String name, boolean append) 字节输入流 InputStream：表示字节输入流的所有子类超类。接下来主要探讨其子类FileInputStream： close()：释放资源 int read(byte[] b)：从文件读取一定数量的字节，并将其存在缓冲区数组b中 int read()：从文件读取一个字节 FileInputStream构造方法： FileInputStream(File file) FileInputStream(String name) 123456789int len = 0;while((len=fis.read())!=-1){ System.out.println((char)len);} byte[] bytes = new byte[1024];while((len = bis.read(bytes)) != -1){ bos.write(bytes,0,len);} 字符流字符输入流 Reader：是一个抽象类 int read() int read(char[] cbuf) void close() FileReader：文件字符输入流 构造方法： FileReader(File file) FileReader(String name) 字符输出流 Writer：是一个抽象类 void write(int c)：写入单个字符 void write(char[] cbuf)：写入字符数组 abstract void write(char[] cbuf,int off,int len)：写入字符数组的某一部分，off表示开始索引，len表示写的字符个数 void write(String str)：写入字符串 void write(String str, int off, int len)：写入字符串的某一部分 void flush()：刷新流的缓冲 void close()：刷新缓冲后关闭此流 字符输出流和字节输出流的最大的区别就是字符输出流要将内容先写到内存缓冲区中（进行 字符——&gt;字节 过程），所以之后必须进行flush或者close。 FileWriter构造方法： FileWriter(File file) FileWriter(String name) FileWriter(File file, boolean append) FileWriter(String name, boolean append) jdk1.7之前进行异常处理的过程 123456789try{ //可能产生异常的代码}catch(异常类参数对象){ //异常的处理逻辑}finally{ //资源释放} jdk1.7后中进行流异常处理的过程 123456try(定义流对象){//流对象使用完毕自动释放 //可能产生异常的代码}catch(){ //异常的处理逻辑} 属性集Properties 唯一一个和io流结合的集合 store：集合中数据持久化到硬盘存储 load：硬盘中的键值对读取到集合使用 Properties是一个双列集合，key和value都默认是字符串 setProperty方法相当于map中的put方法 getProperty方法相当于map中的set方法 stringPropertyNames方法相当于map中的keySet方法 12345678910111213FileWriter fw = new FileWriter(&quot;/home/jack1024/a.txt&quot;);Proterties prop = new Properties();prop.setProperty(&quot;aa&quot;,&quot;11&quot;);prop.setProperty(&quot;bb&quot;,&quot;22&quot;);prop.store(fw,&quot;save data&quot;);fw.close;prop.load(fw);Set&lt;String&gt; set = prop.stringPropertyNames();for(String key : set){ String value = prop.getProperty(key+&quot;=&quot;+value); System.out.println(key);} properties文件中可以使用等号或者空格来分隔键值对 对中文进行处理的时候必须使用字符输入/出流 缓冲流 增强基本流（普通流都是一个一个地传，效率低下） 给基本字节输入输出流增加一个缓冲区，提高传输速率 BufferedInputStream(InputStream fis) BufferedInputStream(InputStream fis, int size) BufferedOutputStream(OutputStream fos) BufferedOutputStream(OutputStream fos, int size) BufferedWriter(Writer fw) BufferedWriter(Writer fw, int size) BufferedReader(Reader fr) BufferedReader(Reader fr, int size) 写和读的方法和基本流一致 BufferedWriter有一个特有的成员方法void newLine：写入一个行分隔符(不同操作系统统一一个方法) BufferReader有一个特有的成员方法String readLine：读取一行数据(不同操作系统统一一个方法) 测试复制文件的效率： 123456789101112131415161718192021222324252627public class Test { public static void main(String[] args) throws IOException { Scanner scanner = new Scanner(System.in); System.out.println(&quot;请输入需要复制的文件路径:&quot;); String sourcePath = scanner.next(); System.out.println(&quot;请输入粘贴的路径:&quot;); String targetPath = scanner.next(); long t1 = System.currentTimeMillis(); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(sourcePath)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(targetPath)); int len = 0; while((len = bis.read()) != -1){ bos.write(len); }// byte[] bytes = new byte[1024];// while((len = bis.read(bytes)) != -1){// bos.write(bytes,0,len);// } bis.close(); bos.close(); long t2 = System.currentTimeMillis(); long sumT = t2-t1; System.out.println(&quot;复制过程总共耗时:&quot;+sumT+&quot;毫秒&quot;); } 转换流 编码：字符——&gt;字节 解码：字节——&gt;字符 制定了编码，字节文件对应的字符集也就确定了，每个软件也就能根据软件功能转化字节为对应的字符供我们查看了 常见的字符集有ASCII字符集，GBK字符集，Unicode字符集 FileReader只能读取系统默认编码utf-8格式的文件，如果读取GBK格式的文件，就会产生乱码 引入转换流来解决：InputStreamReader和OutputStreamWriter是字节流和字符流的桥梁，可以指定编码表 InputStreamReader(InputStream fis) //默认编码 InputStreamReader(InputStream fis, String charsetName) //指定编码 OutputStreamWriter(OutputStream fos) OutputStreamWriter(OutputStream fos, String charsetName) 12345678910OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;/home/jack1024/a.txt&quot;,&quot;GBK&quot;));osw.write(&quot;你好&quot;);osw.close();InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;/home/jack1024/a.txt&quot;,&quot;GBK&quot;));int len = 0;while((len = isr.read())!=-1){ System.out.print((char)len);}isr.close(); 序列化 &amp; 反序列化流把对象以字节的形式写入到文件中存储 并 从文件中读取对象到内存中继续使用，即是对象持久化 ObjectOutputStream(OutputStream os)：对象的序列化流 void writeObject(Object obj) ObjectInputStream(IutputStream is)：对象的反序列化流 Object readObject() 要对对象进行序列化 or 反序列化，必须在类中实现Serializable接口 序列化的内容都是对象的内容，所以static的变量不能被序列化。如果想让一个成员变量不被序列化但是又没有static的含义，可以使用transient关键字声明变量 如果一个类实现了Serializable接口，编译后的.class文件中会带有一个序列号。序列化时，会将这个序号一同写入文件；当反序列化时，会将文件的序列号和.class文件中的序列号作对比，如果不同会抛InvalidClassException异常。（每次对类修改后都会重新生成一个序列号，为了避免异常，我们可以手动给Serializable实现类加上一个序列号） 1static final long serivalVersionUID = 42L; 打印流 PrintStream：为其他输出流添加功能，使他们能方便打印各种数据值的表示形式 print() pringln() 继承自OutputStream的方法（如果使用write方法会查询编码表97-&gt;a；如果使用println or print方法会原样输出） 构造方法： PrintStream(File file) PrintStream(OutputStream out) PrintStream(String fileName) 1234PrintStream ps = new PrintStream(&quot;/home/jack1024/a.txt&quot;);ps.write(97);//转化为字节ps.println(97);//原样打印到文件ps.close; 123System.setOut(ps);//改变输出语句的目的地为ps的目的地System.out.println(&quot;haha&quot;);//会将haha字符串写到/home/jack1024/a.txt中 Java网络编程TCP/IP协议是Internet中最基本，最广泛的协议，他定义了计算机计算机如何进因特网，数据如何在计算机间传输数据。它的内部包含一系列用于处理数据通信的协议 UDP协议：无连接，效率更高，不安全 TCP协议：三次握手建立连接，四次挥手解除连接，效率较低，安全 网络编程三要素： 协议 IP地址：ipv4(32位：84)，ipv6(128位：168)，连接两台主机 端口：两个字节(0—1024—65535)，连接两台主机的两个进程 TCP通信程序 客户端主动请求服务端建立连接，连接中包含一个IO对象，这个对象只能是字节流对象 代码实现： 客户端 服务器 123456789101112131415161718192021222324252627282930313233//客户端public class TcpClient { public static void main(String[] args) throws IOException { Socket socket = new Socket(&quot;127.0.0.1&quot;, 8888); //往服务器写 OutputStream os = socket.getOutputStream(); os.write(&quot;你好&quot;.getBytes()); //从服务端拿 InputStream is = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); }}//服务端public class TcpServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(8888); Socket accept = serverSocket.accept(); InputStream is = accept.getInputStream(); OutputStream os = accept.getOutputStream(); byte[] bytes = new byte[1024]; int len = is.read(bytes); System.out.println(new String(bytes,0,len)); os.write(&quot;收到了&quot;.getBytes()); accept.close(); serverSocket.close(); }} TCP文件上传案例 模拟B/S通信案例函数式编程 函数式接口：有且仅有一个抽象方法的接口，但是可以包含其他方法（默认，静态，私有） 123456@FunctionalInterface修饰符 interface 接口名称{ public abstract 返回值类型 方法名称(可选参数信息){ }} lambda是延迟加载的，可以提升部分代码的性能。也就是说只有满足执行lambda中方法的条件，才会执行方法中的内容，否则不会执行。 函数式接口作为方法的参数，我们可以用lambda表达式 或者 匿名内部类 作为实参 函数式接口作为方法的返回值，我们可以返回这个接口的匿名内部类 或者 lambda表达式 常用的函数式接口12345678910//java.util.funciton.Supplier&lt;T&gt;public static getString(Supplier&lt;String&gt; sup){ return sup.get();//用来返回一个指定类型的数据对象}public static void main(String[] args){ String s = getString(()-&gt;{ return &quot;Sam Smith&quot;; });} 123456789101112//java.util.function.Consumer&lt;T&gt;public static void method(String name,Consumer&lt;String&gt; con){ con.accept(name);//用来消费name字符串}public static void main(String[] args){ method(&quot;Mariah Carey&quot;,(String name)-&gt;{ //对传递的字符串进行处理消费 System.out.println(name); })}//andThen()默认方法，连续组合多个Consumer的accept方法 12345678910111213//java.util.function.Predicate&lt;T&gt;public static boolean checkString(String s,Predicate&lt;String&gt; pre){ return pre.test(s);//对传入的参数进行判断，返回真假}public static void main(String[] args){ String s = &quot;abcde&quot;; boolean b = checkString(s,()-&gt;{ return s.length()&gt;5; });}//Predicate的and()，or()默认方法可以用来连接两个判断条件//negate()默认方法可以对一个判断条件取反 123456789101112//java.util.function.Function&lt;T,R&gt;public static void change(String s,Function&lt;String,Integer&gt; fun){ Integer in = fun.apply(s);}public staic void main(String[] args){ String s = &quot;123&quot;; change(s,(String s)-&gt;{//将一个值从原类型转化为另一个类型 return Ingeter.parseInt(s); });}//andThen()默认方法，连续组合多个Function的apply方法 Stream流式编程 Stream和io流不能说差不多，只能说是毫无关系 极大地简化了对集合进行过滤 &amp; 遍历的操作 1234list.stream() .filter(name-&gt;name.startWith(&quot;杨&quot;)) .filter(name-&gt;name.length==3) .foreach(name-&gt;System.out.println(name)); 流式操作过程： 获取数据源(集合,数组) 数据转换(把数据源转化为Stream流) 执行操作获取想要的结果 获得Stream流对象 所有collection集合可通过stream()方法获得 Stream接口有一个static方法of()，可以把数组转化为stream流 Stream对象的方法 stream属于管道流，只能使用一次，第一个Stream流调用完毕，数据会流到下一个Stream流身上，此时第一个Stream流就不能再调用方法了 延迟方法 返回值类型仍然是Stream接口自身类型的方法，支持链式调用 每个流 流到下一步，上一步的流就关闭了，这个要注意，这也是为什么叫流，它是一个动态的过程 filter方法 12345//Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)Stream&lt;String&gt; stream = Stream.of(&quot;Jack&quot;,&quot;Sam&quot;,&quot;Tom&quot;);Stream&lt;String&gt; stream2 = stream.filter(name-&gt;{ reuturn name.startWith(&quot;J&quot;);}); map方法 12345//Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)Stream&lt;String&gt; stream = Stream.of(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);Stream&lt;Integer&gt; stream2 = stream.map(String s-&gt;{ reuturn Integer.parse(s);}); limit方法 1234//Stream&lt;T&gt; limit(long maxSize)Stream&lt;String&gt; stream = Stream.of(&quot;哈哈&quot;,&quot;嘿嘿&quot;,&quot;咚咚&quot;);//只取前两个元素stream.limit(2).forEach(name-&gt;System.out.println(name)); skip方法 1234//Stream&lt;T&gt; skip(long n)：跳过前n个元素Stream&lt;String&gt; stream = Stream.of(&quot;哈哈&quot;,&quot;嘿嘿&quot;,&quot;咚咚&quot;);//只取前两个元素stream.skip(2).forEach(name-&gt;System.out.println(name)); concat方法 123456//static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)//两个流合并为一个新的流Stream&lt;String&gt; stream1 = Stream.of(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);Stream&lt;String&gt; stream2 = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);Stream&lt;String&gt; concat = Stream.concat(stream1,stream2);concat.forEach(name-&gt;System.out.println(name)); 终结方法 返回值类型不再是Stream接口自身类型的方法，不再支持链式调用 count方法 123456789//long count():统计个数ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(3);list.add(4);Stream&lt;Ingeter&gt; stream = list.stream();long count = stream.count();System.out.println(count); forEach方法 123//void forEach(Consumer&lt;? super T&gt; con)Stream&lt;String&gt; stream = Stream.of(&quot;Jack&quot;,&quot;Sam&quot;,&quot;Tom&quot;);stream.forEach(name-&gt;System.out.println(name)); 方法引用 虽然lambda已经很简单了，但是方法引用还可以堆lambda表达式继续简化 12name-&gt;System.out.println(name);//lambda表达式System.out::println;//方法引用 几种情况： 通过对象名引用成员方法 通过类名引用静态方法 通过super引用父类成员方法 通过this引用本类成员方法 构造方法的方法引用 数组的构造器引用 Junit单元测试 黑盒测试：不需要关注代码，只需要看输入是否能得到输出 白盒测试：通过代码来测试程序的流程正确性（Junit属于白盒测试） 12345678//定义测试类/**几个建议 1.类名：被测试类名Test 2.包名：XXX.XXX.test 3.方法名：test被测试的方法名 4.返回值：void 5.参数列表：空参**/ 1234567//之前需要导入junit依赖public CaculateTest{ public void testAdd(){ int result = 1+2; Assert.assertEquals(3,result) }} @Before和@After注解 123456789//所有测试方法前和后都会执行的两个注解@Before和@After@Beforepublic void init(){ }@Afterpublic void close(){ } 反射 查看之前写的一片博客《java-反射》 注解 查看之前写的一片博客《java-注解》","link":"/2021/03/09/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8B/"},{"title":"玩儿转MySQL","text":"数据库的特点： 持久化存储数据，数据库就是一个文件系统 方便存储并管理数据 提供了方式统一操作数据 常见的数据库软件： 数据库软件是对数据库的不同实现 常见的有： Oracle MySQL Microsoft SQL Server DB2 MongoDB SQLite Redis MySQL准备安装：推荐5.7版本 Windows直接官网下载安装包，然后根据提示选择并下一步，如果要删除除了在控制面板卸载，还需要在C盘的ProgramData的目录下的mysql目录卸载 Linux下的安装/卸载参考博客另一篇博文《我的linux工作平台搭建》 启动123456789#本地启动mysql -uroot -proot#远程连接mysql -h127.0.0.1 -uroot -proot#详细写mysql --host=127.0.0.1 --user=root --password=root#退出exit or quit SQL语句 SQL：Structured Qurey Language，结构化查询语言实际上就是定义了操作所有关系型数据库的规则 1234567891011-- SQL语句注意事项：# SQL语句特有的注释/** SQL语句可以单行或者多行书写，以分号结尾 SQL语句不区分大小写，关键字建议使用大写**/-- 查看该操作系统下的mysql各文件的存储位置show variables like '%dir%';-- 查看该操作系统下的编码情况show variables like '%character%'; SQL语句分类DDL（操作数据库、表） 数据定义语言 drop，create，alter Create 数据库: 12create database if not exists db1;create database db2 character set gbk; 数据库类型： int(位数)：整数类型 double(位数)：小数类型 date：日期（yyyy-MM-dd） datetime：日期（yyyy-MM-dd HH:mm:ss） timestamp：时间戳类型，默认是当前系统的时间 varchar(位数)：字符串类型 表: 12345678create table 表名{ 列名1 数据类型1, 列名2 数据类型2, ...... 列名n 数据类型n}# 复制表create table 表名1 like 表名2; Retrieve 数据库: 1234# 查询mysql目前所有数据库show databases;# 查看数据库字符集show create database mysql; 表: 1234# 查询当前数据库中所有表show tables;# 查询表结构desc 表名; Update 数据库 12# 修改数据库字符集alter database db2 character set utf8; 表 123456789101112# 修改表名 alter table 表名 rename to 新表名;# 修改字符集show create table 表名;alter table 表名 character set utf8;# 添加一列alter table 表名 add 列名 数据类型;# 修改列名 类型alter table 表名 change 列名 新列名 数据类型;#列名数据类型一起改alter table 表名 modify 列名 数据类型;#只改类型# 删除列alter table 表名 drop 列名; Delete 数据库 1drop database if exists db2 ; 表 12drop table 表名;drop table if exists 表名; 使用数据库 1234# 查询当前正在使用您的数据库select database();# 使用数据库use db1; DML（增删改表中的数据） 数据操作语言 insert，delete，update 基础查询 1234567891011121314151617select [distintct结果去重] 字段列表[可四则运算，如果有null则结果都为null，用IFNULL解决] [as 别名]from 表名列表where 条件列表[比较运算符，and or，between and，in(x,x...)] [null只能用is null来判断] [like 占位符：_，%]group by 分组字段having 分组后条件order by 排序字段 ASC/DESClimit 分页限定 add 如果不写表名，表示所有字段 12insert into 表名(列名1,列名2...列名n) values(值1,值2...值n);select * from 表名; delete 1234delete form 表名 where 条件;# 删除所有记录delete from 表名; #多少记录删除多少下truncate table 表名; #先删除表，然后创建一张一样的表，效率更高 modify 1update 表名 set 列名1=值1,列名2=值2 where 条件; DQL（查询表中的数据） 数据查询语言 select，where 排序查询 1select * from 表名 order by 排序字段1 DESC,排序字段2 ASC; 聚合函数 将一列数据作为一个整体进行纵向计算 count，max，min，sum，avg 聚合函数的计算会排除null值 解决方案1：选择非空列（主键 or *） 解决方案2：IFNULL函数 1select count(列名) from 表名; 分组查询 查询显示列只能是当前分组字段 或者 纵向处理后的聚合函数 where是分组之前的条件限制，having是分组之后的条件限制 where后筛选出条目—&gt;group分组—&gt;having分组后筛选 where后不能跟聚合函数，having后可以跟聚合函数，因为聚合函数是对where后的结果进行计算的 1select 分组字段/聚合函数 from 表名 where 条件 group by 分组字段 having 条件; 分页查询 当前索引 = (当前页码 - 1) * 每页条数 limit语句是mysql的“方言” 1select 列名 from 表名 limit 开始的索引,每页查询的条数; DCL（授权） 数据控制语言 GRANT，REVOKE 123456789101112131415161718192021222324# 添加用户CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';# 删除用户DROP USER '用户名'@'主机名';# 修改用户UPDATE USER SET PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');# 查询用户-- 1. 切换到mysql数据库USE myql;-- 2. 查询user表SELECT * FROM USER;# 忘记root密码？1. 停止mysql服务2. 使用无验证方式启动mysql服务：mysqld --skip-grant-tables3. 直接输入:use mysql4. update user set password = password('你的新密码') where user = 'root';5. 结束mysqld进程6. 使用新密码登录 12345678910111213141. 查询权限： -- 查询权限 SHOW GRANTS FOR '用户名'@'主机名';2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO 'zhangsan'@'localhost'; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; REVOKE UPDATE ON db3.`account` FROM 'lisi'@'%'; 约束 对表中的数据进行限定，保证数据的正确性，有效性和完整性 mysql中约束分类： 主键约束：primary key 主键：非空 且 唯一 一张表只能有一个字段是主键 主键是表中每条记录的唯一标识 自增长：如果某一列是数值类型，使用auto_increment可以来完成自动增长，一般配合主键一起使用 非空约束：not null 唯一约束：unique mysql中多个null不算重复 外键约束：foreign key 如果关系模式R1中的某属性集不是自己的主键，而是关系模式R2的主键，则该属性集称为是关系模式R1的外键 123456789101112131415161718192021222324252627282930313233343536# 1. 主键约束：primary keycreate table stu( id int primary key auto_increment; name vachar(30););alter table stu drop primary key;#删主键约束alter table stu modify id int;#删自动增长（删不掉主键）alter table stu modify name varchar(30) primary key auto_increment#添加主键约束 &amp; 自动增长# 2. 非空约束：not nullcreate table stu( id int; name vachar(30) not null;);alter table stu modify id varchar(30);#删非空约束alter table stu modify id varchar(30) not null;#添加非空约束# 3. 唯一约束：uniquecreate table stu( id int unique; name vachar(30););alter table stu drop index id;#删唯一约束alter table stu modify id int unique;#添加唯一约束# 4. 外键约束：foreign keycreate table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表唯一约束列名));ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; #删除外键ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); #添加外键# 外键级联操作（谨慎使用）1. 级联更新：ON UPDATE CASCADE2. 级联删除：ON DELETE CASCADE 多表之间的关系一对一 人和身份证 可以在任意一方添加外键指向另一方的主键，然后将外键设置为unique 一对多 部门和员工 在多的一方建立外键，指向一的一方的主键 多对多 学生和课程 需要借助第三张中间表，中间表中的两个字段作为中间表两个外键，分别指向两个表的主键 范式 设计关系型数据库时需要遵循的一些规范 各种范式成递次规范，越高的范式数据库冗余越小 目前关系型数据库有6中范式： 第一范式（1NF）：每一列都是不可分割的原子项 第二范式（2NF）：在1NF的基础上消除了非主属性对主码的部分函数依赖 函数依赖：通过A可以 确定唯一B，则B依赖于A 完全函数依赖：如果A是一个属性组，则B的确定需要依赖于A属性组中所有属性，此时B完全依赖于A属性组 部分函数依赖：B属性的确定只需要依赖于A属性组中某一些值，则B部分依赖于A属性组 传递函数依赖：A—&gt;B，B—&gt;C，C传递函数依赖于A 码：一个表中，如果一个属性或属性组被其他所有属性所完全依赖，则这个属性或属性组为该表的码。（也称为候选码，同一张表中可以有多个候选码） 主属性：候选码中的所有属性 非主属性：一张表中，除了主属性以外的其他所有属性 第三范式（3NF）：在2NF的基础上消除了传递依赖 巴斯-科德范式（BCNF）：需要消除“表中的主属性部分依赖于某个候选码“这种情况，也就是主属性内部不能有部分或传递依赖 第四范式（4NF） 第五范式（5NF） 数据库备份和还原 也就是把目前的数据库所有状态写进sql文件中持久化保存 命令行： 语法： 备份： 1mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行备份文件 1source 文件路径 图形化工具备份 多表查询123456select 列名列表from 表名列表where 表1,表2... 不同where加条件就会得到笛卡尔积，多表查询要做的就是消除笛卡尔积的无用内容 内连接查询隐式内连接12345678910111213141516-- 查询所有员工信息和对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表的名称，性别。部门表的名称SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 加上别名SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接12SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 外连接查询左外连接 查询的左表所有信息以及和右表的交集部分 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接 查询的右表所有信息以及和左表的交集部分 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 子查询 查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息-- 1 查询最高的工资是多少 9000SELECT MAX(salary) FROM emp;-- 2 查询员工信息，并且工资等于9000的SELECT * FROM emp WHERE emp.`salary` = 9000;-- 一条sql就完成这个操作。子查询SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询结果的几种情况： 单行单列：子查询结果可以作为条件（用比较运算符） 多行单列：子查询结果可以作为集合条件（用 in） 多行多列：子查询结果集可以作为一张虚拟表继续进行查询 事务事务的基本介绍 如果一个包含多个步骤的业务操作，被食物管理，那么这些操作要么同时成功，要么同事失效 操作： 开启事务：start transactoin 回滚：rollback 提交：commit mysql数据库中事务默认自动提交 123#查看默认事务提交方式select @@autocommit; #1自动，0手动set @@autocommit = 0; 事务的四大特征 原子性：不可分割最小操作单位 持久性：当事务提交或回滚后，数据库会持久化保存数据 隔离性：多个事务之间应该相互独立 一致性：事务 操作前后，数据总量保持不变 事务的隔离级别 概念：多个事务之间是隔离的，相互隔离的。但是如果多个事务（线程）操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 脏读：读取到另一个事务没有提交的数据 不可重复读（虚读）：同一个事务中，两次读到的数据不一样 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改 4中隔离级别：级别从小到大安全性越高，效率越低 read uncommitted：读未提交 产生的问题：脏读，虚读，幻读 read committed：读已提交（Oracle默认） 产生的问题：虚读，幻读 repeatable read：可重复读（MySQL默认） 产生的问题：幻读 Serializable：串行化 产生的问题：无 1234#查询隔离级别select @@tx_isolation#数据库设置级别set global transaction isolation level 级别字符串; 接下来是MySQL高级部分 索引 索引是帮助MySQL高效获取数据的数据结构 优势： 快速查询 降低数据排序成本，降低CPU消耗 劣势 索引占用磁盘控件 降低了更新表速率 索引结构 MySQL目前有以下4种索引 BTREE索引 HASH索引 R-tree索引 Full-text索引 MySQL默认支持的InnoDB引擎主要就是支持BTREE索引，主要也是介绍BTREE引擎 BTREE索引 MySQL中的BTREE索引默认是用的B+树","link":"/2021/02/11/%E7%8E%A9%E5%84%BF%E8%BD%ACMySQL/"},{"title":"计网-网络层","text":"网络层提供的两种服务争论的焦点是可靠交付应当有谁来负责？运输过程中只由运输层来决定，网络层不负责可靠传输，可靠传输应该由端系统决定。 网络层应该向运输层提供怎样的服务？分组交换网提供两种传输服务: 虚电路服务：面向连接的，虚电路表示这只是一条逻辑上的连接，和电路交换的一真正的连接只是类似，但并不完全一样。是一种使所有分组顺序到达目的端的可靠性数据传输服务。 数据报服务：无连接的，网络在发送分组时不需要先建立连接，每一个分组独立发送，与其前后的分组无关。是一种使分组按照独立路由到达目的端的数据传输服务，比虚电路更加灵活。 网际协议IP虚拟互连网 网络互联的中间设备 物理层中继系统：转发器，集线器 数据链路层终极系统：网桥，交换机 网络层中中继系统：路由器 网络层以上的中继系统：网关 虚拟互连网也就是逻辑互联网络，就是互连起来的各种物理网络的异构性本来就是客观存在的，但是我们利用IP协议就可以使这些性能各异的网络从用户看起来就好像是一个统一的网络。 网络层4个协议 IP协议： ARP/RARP协议： ICMP协议： IGMP协议： IP地址 分层：分网络部分和主机部分 分类：A类（8+24），B类（16+16），C类（24+8），D类（组播），E类（研究） 二进制，十进制 1 1 10 2 100 4 1000 8 10000 16 100000 32 1000000 64 10000000 128 11000000 192 11100000 224 11110000 240 11111000 248 11111100 252 11111110 254 11111111 255 A类 从1.0.0.0 到126.255.255.255B类 从128.0.0.0到191.255.255.255C类 从192.0.0.0到223.255.255.255 在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下： A类地址：10.0.0.0～10.255.255.255 B类地址：172.16.0.0～172.31.255.255 C类地址：192.168.0.0～192.168.255.255 注意：网段中主机部分不全为1，不全为0；全0代表这个网段，全1代表网段中的广播 几个特殊ip地址： 0.0.0.0：不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。 255.255.255.255：限制广播地址 244.0.0.1：组播地址 127.0.0.1：本地回环地址 169.254.0.0：一般开启了dhcp服务的设备但又无法获取到dhcp的会随机使用这个网段的ip 划分子网和构建超网 子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在广域网上。用来判断自己和目标地址是否在一个网段、 子网划分：解决IPV4不够用的情况 C类地址分成四个子网： 点到点网络的子网掩码是X.X.X.252 变长子网划分：允许把子网继续划分为更小的网络 超网： 将多个子网合并为一个网 IP地址和硬件mac地址 ip地址决定了数据包最终要到哪一个计算机，mac地址决定了下一跳给谁 同一子网和同一网段可以看作一个意思 代理服务器控制那些计算机能上网：同一网段可以用mac地址控制，但是不同网段只能通过ip地址控制。 ARP协议： ARP欺骗： 同一局域网里面的两台主机之间相互通信是通过Mac地址寻址的，而如果两台主机若不是处于同一子网里面，则在通信的时候会相互将数据发送给各自的路由器网关，通过网关的IP寻址以达到通信目的。但是网关和自己局域网里面的主机通信的时候还是依靠Mac地址寻址的，所以如果我们要把自己攻击机伪造成网关达到欺骗作用，就应该把目标主机上的网关Mac地址缓存改为攻击机的Mac地址（这就可以通过伪造ARP报文来实现） 逆向ARP：计算机请求ip地址的过程 IP数据报格式 由首部和数据两部分组成 IP转发分组的流程 数据路由：路由器在不同网段转发数据包 网络畅通的条件：能去能回 沿途路由器必须知道到目标网络下一跳给哪个接口 沿途路由器必须知道到源网络下一跳给哪个接口 网际控制报文协议ICMP协议 为了提高IP数据包交付成功的机会，在网络层使用了网际控制报文协议ICMP 报告的错误：终点不可达；原点抑制；时间超过；参数问题；改变路由（重定向） ping和pathping命令 路由协议IGP(内部网关协议)静态路由协议：管理员手工配置路由信息动态路由协议RIP：距离向量路由算法，是应用层协议 周期性广播(30s)，可以根据路由器状态变化动态的改变路由表 路由器只掌握物理相连的邻居及链路费用 动态地选择最佳路径 依据路由器跳数选择最佳路径 最大跳数16跳 网关就是默认路由 用命令来配置动态路由协议RIP： router rip network （注意这里的ip地址要看该路由器所连接的几个网段具体属于ABC哪类网，来决定要配置几次） 动态路由协议OSPF：链路状态路由算法，是传输层协议 所有路由器掌握完整的网路拓扑和链路费用信息 依据带宽来选择最佳路径 支持多区域，触发式更新 三个表：邻居表，链路状态表，计算路由表 用命令来配置动态路由协议OSPF： router rip network （注意这里的ip地址要看该路由器所连接的几个网段具体属于ABC哪类网，来决定要配置几次） EGP(外部网关协议)和IGP(外部网关协议) IGP：一个自治系统AS内使用的路由选择协议 BGP协议 ：发言人机制 EGP：在自治系统AS之间使用的路由选择协议 RIP协议 OSPF协议 主机A（135.24.25.23）第一次和不同网段的主机B（135.24.52.123）通信完整过程（数据链路层和网络层） A封装好要发送的数据，在要写目的地址时 A会用子网掩码将自己和目的的ip地址做与运算，判断A和B是否在一个网段，如果不在一个网段，A就知道该用网关把自己的数据传递给B，所以A会广播一个ARP包（连带A自己的ip和mac地址）来获取网关的mac地址 网关收到ARP包后，先把A的ip和mac地址记录下来，然后把自己的ip和mac地址封装在ARP包中，发送给A A封装报文，源mac地址写A自己的mac地址，目标mac地址写网关mac地址，源ip地址写A自己的ip地址，目标ip地址写B的ip地址。 网关收到报文后，发现是给我自己发的，就开始解包，解开后，通过目标ip地址发现是给另一个网段的主机发送的 此时如果网关本身就是路由器就直接把数据报把送给吓一跳路由器，如果网关是普通的PC，那么就发送给路由器，由路由器发送给下一跳路由器，目标mac地址写下一跳路由器的mac地址。 （注意：在公网环境中，从源主机向目标主机请求发送数据时，源ip地址和目的ip地址在传输过程中是不需要改变的，但是由于大部分的情况是源主机是位于局域网环境中，所以，考虑NAT的因素，需要在从保留地址到公网ip的变化中同时也要改变源ip的地址。此时，对于目标ip地址，肯定是公网ip，因为不可能用局域网ip去访问另一个网段中的局域网ip） 历经千辛万苦，报文段终于到达了B的主机的路由器，路由器发送报文到B所在的网段的网关 C网段的网关解包后发现不是给自己的，而是给自己网段内的B主机（这里再次用arp协议来实现同一个网段内的通信，先用arp发送一个广播，得到主机B的ip和mac地址，然后就可以在数据链路层中完成同一个网段的通信），就发送给了C主机 另一个个差不多的过程说明，差不多： 广播只有2层的。跨网段访问是寻址。给你举一个例子，详细说一下数据包的转发流程，环境是三层交换机有两个网段，10.0.0.1/24和192.168.0.1/24，pc1是10段的，pc2是192段的。pc1要与pc2通信。过程如下1.pc1将要与pc2通信，首先根据网卡的ip地址与掩码算出pc2是否与pc1是同网段，如果是同网段直接二层转发，如果不是将跨网段转发2.pc1算出pc2和自己不是同网段，所以要将数据包发送到网关由网关进行三层寻址转发。3.pc1到网关为二层转发，也就是数据帧转发，数据帧转发需要知道对方mac地址，首先pc1会读电脑的arp缓存，看是否有网关ip与mac地址的对应关系，如果有将直接封装帧转发；如果没有将使用arp协议也就是广播，携带自己的ip地址与mac地址，目的地址为网关ip，mac地址为ffff-ffff-ffff。网关收到此arp广播后，将回复pc1自己的mac地址，数据包为源网关ip和mac地址目的为pc1ip和mac地址。4.pc1收到数据包后会将此ip和mac地址写入到电脑的arp缓存表里，并直接封装数据包，三层ip头为源pc1-ip，目的为pc2-ip，二层帧格式为源pc1-mac，目的为网关mac地址（记住此包头）。5.网关将收到pc1发来的数据包，进行拆包，根据其目的ip地址进行寻址（路由表），找到对应的路径（也就是192段vlan）。6.三层交换机会根据其目的ip地址进行本机的arp缓存查找，如果查找到ip和mac地址的对应关系将直接封装转发，如果没有交换机将发送arp广播包获取目的ip地址的mac地址（广播包将只发送192段vlan，其他vlan不广播）。7.三层交换机得知pc2-mac地址后将转发数据，三层包头为源pc1-ip，目的为pc2-i，二层帧包头为源192段网关mac，目的为pc2-mac。8.pc2将收到三层交换发来的数据包，进行拆封即可获取数据，并回复pc1过程同上。 三层交换机等同于路由器。也就是说源ip和目的ip在数据包里一直不变（不经过nat的情况），mac地址将时刻改变。广播只存在二层。三层情况下是路由寻址。 IP组播 IGMP协议：是TCP/IP 协议族中负责IP组播成员管理的协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。 虚拟专用网VPN VPN：Virtual Private Network，目的是建立更加安全私密的远程连接 形象解释就是在巨大的错综复杂的互联网环境中建立一条两个路由器之间的直通隧道 网络地址转换NAT 从局域网地址到公网地址的转化，可以大大缓解ipv4不够用的情况 NAT分为静态NAT，动态NAT和PAT，前两种NAT都是针对ip而言的对应，只不过一个是一对一，一个是多对多，现在所说的NAT实际上是PAT（Port Address Translation：端口地址转换）： NAT的地址转换是指每个内网地址都被转换成ip地址+源端口的方式，这需要公网ip地址为多个。 而PAT由于ip地址不足够，就会出现内网地址被转换成ip地址+端口段的形式，这样的公网ip地址通常只是一个。 举个例子： NAT 192.168.0.2：4444 —-〉202.116.100.5：4444 192.168.0.3：5555 —-〉202.116.100.6：5555 192.168.0.10：1233 —〉202.116.100.5：1233 PAT 192.168.0.2：4444 —-〉202.116.100.5：50003 192.168.0.3：5555—-〉202.116.100.5：50004 192.168.0.10：1233 —〉202.116.100.5：50005 简单来说，PAT是多对1，NAT是多对多. NAT原理图 端口映射： 内网穿透 可见，端口映射和内网穿透技术都可以实现非同网段访问局域网ip，但是因为国内的网络环境是如图所示的套娃情况。NAT的实现往往不是一层，而是多层，所以基本不可能用端口映射的方式实现本地局域网PC的外雇访问。有什么解决方法呢？一.让ISP给你的第一层路由器分配一个公网ip，很难，几乎不可能。二.花钱买内网穿透服务，很贵且限流。","link":"/2020/11/21/%E8%AE%A1%E7%BD%91-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"title":"SSM框架-Spring","text":"Spring简介 Spring前身：EJB框架 Spring优点 方便解耦，简化开发：IOC容器使对象的依赖关系由Spring控制，编程者更专注于上层的应用 AOP编程的支持：方便面向切面编程 声明式事务的控制：配置的方式简化开发 Junit：方便程序测试 方便集成各种优秀的框架：Mybatis等 降低JavaEE API的使用难度：提供了一些工具的封装类 开源：方便学习 Spring程序大致步骤 导入Spring开发的maven依赖 编写Dao接口和实现类 创建Spring核心配置文件applicationContext.xml 在Spring配置文件中配置实现类 使用Spring的API获得Bean实例 Spring核心配置文件bean标签 id：唯一性标识，通过其获得对象 class：bean的全限定名称 scope：singleton(默认)，prototype等5个 scope：bean对象在核心配置文件加载时就创建，只有一个，spring容器销毁时才会销毁bean prototype：bean对象在每次getBean时创建一个，对象长时间不用会被GC垃圾回收机制回收 init-method：指定类中初始化方法名称，对象创建后执行 destory-method：指定类中销毁方法名称，对象销毁前执行 bean实例化的三种方式： 无参构造实例化：默认 工厂静态方法实例化：factory-method=“工厂方法”，class中写工厂类 工厂实例方法实例化：需要先bean一个工厂对象，然后factory-bean=“工厂实例”，factory-method=“工厂方法” 依赖注入 依赖注入是Spring框架核心IOC的具体体现 通过控制反转，把对象的控制权交给Spring容器。IOC解耦可以降低Service业务层和Dao持久层之间的关系，此时依赖关系就由Spring来维护了，Spring容器会自己把持久层对象传入业务层。 如何把UserDao依赖注入到UserService中？ 123456789101112131415161718192021/**构造方法**/public class UserServiceImpl implements UserService{ private UserDao userDao; public UserServiceImpl(UserDao userDao){ this.userDao = userDao; } public userServiceImpl(){ } public void save(){ usreDao.save(); }}//name指的构造函数的参数名&lt;bean id=&quot;userDao&quot; class=&quot;link.jack1024.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;link.jack1024.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123456789101112131415161718192021/**set方法**/public class UserServiceImpl implements UserService{ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } public void save(){ usreDao.save(); }}//name指的set的方法除去set后首字母小写后的&lt;bean id=&quot;userDao&quot; class=&quot;link.jack1024.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;link.jack1024.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt;//也可以使用p命名空间注入: xmlns=&quot;http://www.springframework.org/schema/p&quot;&lt;bean id=&quot;userService&quot; class=&quot;link.jack1024.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;&gt;&lt;/bean&gt; 依赖注入的数据类型： 普通数据类型 集合数据类型 引用数据类型 1234567891011121314151617181920212223242526272829303132333435363738public class User{ private String name; private String email; //Getter &amp; Setter 省略}public class UserDaoImpl implements UserDao{ private String username; private int age; private List&lt;String&gt; list; private Map&lt;String,User&gt; userMap; //Setter 省略}&lt;bean id=&quot;userDao&quot; class=&quot;link.jack1024.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;Sam Smith&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;/&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;firstUser&quot; value-ref=&quot;user1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;secondUser&quot; value-ref=&quot;user2&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;user1&quot; class=&quot;link.jack1024.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Jobs&quot;/&gt; &lt;property name=&quot;email&quot; value=&quot;112233@qq.com&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;user2&quot; class=&quot;link.jack1024.domain.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Marks&quot;/&gt; &lt;property name=&quot;email&quot; value=&quot;445566@qq.com&quot;/&gt;&lt;/bean&gt; Sprng配置文件拆解合并 如果所有Spring容器的配置文件都放在applicationContext.xml核心配置文件中，那将会十分庞大，所以可以按照程序分层Controller，Service，Dao将配置文件也拆分为几个xml文件，最后在applicationContext.xml核心配置文件中import即可 123&lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;import resource=&quot;spring-sevice.xml&quot;/&gt;&lt;import resource=&quot;spring-dao.xml&quot;/&gt; Spring相关API12ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserDao userDao1 = (UserDao) ac.getBean(&quot;userDao&quot;); ApplicationContext继承体系 ApplicationContext的3个常用实现类 ClassPathXmlApplicationContext：从类的根路径下加载配置文件 FileSystemXmlApplicationContext：从磁盘路径下加载配置文件 AnnotationConfigApplicationContext：当使用你注解配置容器对象时，需要使用此类创建spring容器。它用来读取注解 getBean方法 getBean(bean的id)：配置文件中可以有多个同类型的bean getBean(bean对应类.class)：配置文件中一个类型只能有一个bean，否则无法识别 Spring配置数据源（连接池）常见数据源：DBCP，C3P0，BnoeCP，Druid 12345678910111213141516171819202122232425262728293031&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.12.RELEASE&lt;/version&gt;&lt;/dependency&gt; 之前创建数据库连接池都是通过代码手动创建的，通过Spring完全可以将数据库连接池的控制反转给Spring容器，将数据库信息注入给数据库连接池对象。 1234567&lt;!--applicationContext.xml--&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt; 12345ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;);Connection connection = dataSource.getConnection();System.out.println(connection); 继续解耦，把数据库信息解到properties文件中 123456789101112131415161718&lt;!--applicationContext.xml加载jdbc.properties配置文件获得连接信息。首先，需要引入context命名空间和约束路径：命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot;约束路径：http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd--&gt;&lt;context:property-placeholder location=&quot;classpath:c3p0.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;&lt;/bean&gt; Spring注解开发 Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 原始注解 Spring原始注解主要是替代&lt;Bean&gt;的配置 12345&lt;!--使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。--&gt;&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.jack1024&quot;&gt;&lt;/context:component-scan&gt; 1234567891011121314151617181920//@Component(&quot;userDao&quot;)@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao { @Override public void save() { System.out.println(&quot;save running... ...&quot;); }}//@Component(&quot;userService&quot;)@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService { /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() { userDao.save(); }} 注意： @Autowired默认按照数据类型匹配注入 @Autowired结合@Qualifier会按照id匹配注入 @Resource相当于@Autowired+@resource 注解方式@Autowired、@Qualifier，@resource来依赖注入，不需要写set方法了 1234567891011121314151617181920212223242526272829303132//@Value注入普通数据类型@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao { @Value(&quot;注入普通数据&quot;)//没多大意义 private String str; @Value(&quot;${jdbc.driver}&quot;)//很有意义：Spring配置类中会用 private String driver; @Override public void save() { System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); }}//Bean的创建形式//@Scope(&quot;prototype&quot;)@Scope(&quot;singleton&quot;)public class UserDaoImpl implements UserDao { //此处省略代码}//使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法@PostConstructpublic void init(){ System.out.println(&quot;初始化方法....&quot;);}@PreDestroypublic void destroy(){ System.out.println(&quot;销毁方法.....&quot;);} 新注解 使用原始注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下 非自定义的Bean的配置：&lt;bean&gt;（例如Datasource） 加载properties文件的配置：&lt;context:property-placeholder&gt; 组件扫描的配置：&lt;context:component-scan&gt; 引入其他文件：&lt;import&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041//Spring的配置类，使用class电梯xml，使用注解代替标签@Configuration@ComponentScan(&quot;com.jack1024&quot;)@Import({DataSourceConfiguration.class})public class SpringConfiguration { }@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration { @Value(&quot;${jdbc.driver}&quot;) private String driver; @Value(&quot;${jdbc.url}&quot;) private String url; @Value(&quot;${jdbc.username}&quot;) private String username; @Value(&quot;${jdbc.password}&quot;) private String password; //Spring将当前方法的返回值以指定名称存在Spring容器 @Bean(name=&quot;dataSource&quot;) public DataSource getDataSource() throws PropertyVetoException { ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource; } }//测试加载核心配置类创建Spring容器@Testpublic void testAnnoConfiguration() throws Exception { //加载核心配置类 ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService)applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource)applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection);} 注意：这种全注解配置的方法在SSM不强制使用，但是在SpringBoot中很常用 Spring整合Junit1234//测试类中很繁琐ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 改进： 让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 Spring继承Junit步骤： 导入spring集成Junit的maven依赖 使用@Runwith注解替换原来的运行期 使用@ContextConfiguration指定配置文件或配置类 使用@Autowired注入需要测试的对象 创建测试方法进行测试 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 12345678910111213@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = {&quot;classpath:applicationContext.xml&quot;})//加载spring核心配置类@ContextConfiguration(classes = {SpringConfiguration.class})public class SpringJunitTest { @Autowired private UserService userService; @Test public void testUserService(){ userService.save(); }} AOP什么是AOP？AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。（举个栗子：A和B需要结合，但是是通过程序运行时的动态结合，可以很好地解耦） AOP作用一句话总结：程序运行时在不修改源码情况下动态对代码增强功能 AOP优势：减少重复代码，提高开发效率，便于维护 AOP底层原理：动态代理 实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强。 JDK代理：基于接口的动态代理 cglib代理：基于父类的动态代理 基于JDK的动态代理1234567891011121314151617181920212223242526272829303132public interface TargetInterface { public void method();}public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); }}Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance( target.getClass().getClassLoader(),//目标对象的类加载器 target.getClass().getInterfaces(),//目标对象相同的接口字节码对象数组 new InvocationHandler() {//调用代理对象任何方法，实质都是执行invoke方法 @Override public Object invoke( Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;前置增强代码...&quot;); Object obj = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return obj; } });// 测试,当调用接口的任何方法时，代理对象的代码都无需修改proxy.method(); 基于cglib的动态代理 虽然是第三方的实现，但是现在spring-core包已经将cglib拿进来了，无需手动导入 1234567891011121314151617181920212223242526public class Target { public void method() { System.out.println(&quot;Target running....&quot;); }}Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer(); //创建增强器enhancer.setSuperclass(Target.class); //设置父类enhancer.setCallback(new MethodInterceptor() { //设置回调 @Override public Object intercept( Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(&quot;前置代码增强....&quot;); Object obj = method.invoke(target, args); System.out.println(&quot;后置代码增强....&quot;); return obj; }});Target proxy = (Target) enhancer.create(); //创建代理对象//测试,当调用接口的任何方法时，代理对象的代码都无需修改proxy.method(); AOP相关概念： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 注意：连接点是可以被增强的方法，切入点是真正被增强的方法。切入点是连接点的一部分。 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 AOP开发需要明确的事项 需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些Advice与哪些Pointcut进行结合 AOP 技术实现的内容 Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 AOP 底层使用哪种代理方式 在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 XML 配置 AOP 详解 导入 AOP 相关坐标 创建目标接口和目标类（内部有切点） 创建切面类（内部有增强方法） 将目标类和切面类的对象创建权交给 spring 在 applicationContext.xml 中配置织入关系 测试代码 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718//目标接口和目标类public interface TargetInterface { public void method();}public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); }}//创建切面类public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); }} 123456789101112131415161718192021222324252627&lt;!--在 applicationContext.xml 中配置织入关系--&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--将目标类和切面类的对象创建权交给 spring--&gt; &lt;!--配置目标类--&gt; &lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;!--声明myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 1234567891011//测试代码@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); }} 切点表达式的写法表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 通知的类型通知的配置语法： 1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 注解配置 AOP 详解 创建目标接口和目标类（内部有切点） 创建切面类（内部有增强方法） 将目标类和切面类的对象创建权交给 spring 在切面类中使用注解配置织入关系 在配置文件中开启组件扫描和 AOP 的自动代理 测试 12345678910111213141516171819202122232425262728293031323334353637383940public interface TargetInterface { public void method();}public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); }}public class MyAspect { //前置增强方法 public void before(){ System.out.println(&quot;前置代码增强.....&quot;); }}@Component(&quot;target&quot;)public class Target implements TargetInterface { @Override public void method() { System.out.println(&quot;Target running....&quot;); }}@Component(&quot;myAspect&quot;)public class MyAspect { public void before(){ System.out.println(&quot;前置代码增强.....&quot;); }}@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect { @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); }} 1234&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt;&lt;!--aop的自动代理，用于识别aop专属注解--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 1234567891011//测试代码@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest { @Autowired private TargetInterface target; @Test public void test1(){ target.method(); }} 切点表达式的抽取注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 12345678910@@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect { @Before(&quot;MyAspect.myPoint()&quot;) public void before(){ System.out.println(&quot;前置代码增强.....&quot;); } @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint(){}} Spring JDBCTemplate 导入spring-jdbc和spring-tx坐标 创建数据库表和实体 创建JdbcTemplate对象 执行数据库操作 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; JDBCTemplate的基本使用参考博客《JDBC》 我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 123456789101112131415161718192021222324252627282930313233&lt;!--jdbc.properties--&gt;jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root&lt;!--applicationContext.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678@Test//测试Spring产生jdbcTemplate对象public void test2() throws PropertyVetoException { ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;lisi&quot;, 5000); System.out.println(row);} Spring事务编程式事务控制 基于XML的声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 代码 引入tx命名空间 12345678910111213141516&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置事务 AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);} 切点方法的事务参数的配置1234567&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--设置事务的属性信息--&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 基于注解的声明式事务控制 编写 AccoutDao 1234567891011@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao { @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) { jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); } public void in(String inMan, double money) { jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); }} 编写 AccoutService 123456789101112@Service(&quot;accountService&quot;)@Transactionalpublic class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) { accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); }} 编写 applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven/&gt; 注解配置声明式事务控制解析 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 使用在方法上，不同的方法可以采用不同的事务参数配置。 要使用使用 @Transactional ，Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; Spring集成web环境ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 通过工具获得应用上下文对象12ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);Object obj = applicationContext.getBean(&quot;id&quot;);","link":"/2021/01/20/SSM%E6%A1%86%E6%9E%B6-Spring/"},{"title":"SSM框架-SpringMVC","text":"SpringMVC的简介SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 导入SpringMVC相关坐标 配置SpringMVC核心控制器DispathcerServlet 创建Controller类和视图页面 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件 spring-mvc.xml 客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ③创建Controller和业务方法 123456public class QuickController { public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; }} ③创建视图页面index.jsp 12345&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ④配置注解 12345678@Controllerpublic class QuickController { @RequestMapping(&quot;/quick&quot;) public String quickMethod(){ System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; }} ⑤创建spring-mvc.xml 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;/beans&gt; ⑥访问测试地址 1http://localhost:8080/itheima_springmvc1/quick SpringMVC的组件解析SpringMVC的执行流程 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter处理器适配器。 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView。 HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 SpringMVC注解解析@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： value：用于指定请求的URL。它和path属性的作用是一样的 method：用于指定请求的方式 params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： params = {“accountName”}，表示请求参数必须有accountName params = {“moeny!100”}，表示请求参数中money不能是100 1.mvc命名空间引入 123456命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 SpringMVC的XML配置解析注意：SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： 1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值）prefix = &quot;&quot;; --视图名称前缀suffix = &quot;&quot;; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀 12345&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 重点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”; SpringMVC的请求和响应SpringMVC的数据响应SpringMVC的数据响应-数据响应方式(理解) 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 返回对象或集合 SpringMVC的数据响应-页面跳转-返回字符串形式（应用） SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用) 在Controller中方法返回ModelAndView对象，并且设置视图名称 1234567891011121314@RequestMapping(value=&quot;/quick2&quot;)public ModelAndView save2(){ /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据(放进request域中) modelAndView.addObject(&quot;username&quot;,&quot;itcast&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView;} SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用) n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 1234567891011 @RequestMapping(value=&quot;/quick3&quot;)public ModelAndView save3(ModelAndView modelAndView){ modelAndView.addObject(&quot;username&quot;,&quot;itheima&quot;); modelAndView.setViewName(&quot;success&quot;); return modelAndView;}@RequestMapping(value=&quot;/quick4&quot;)public String save4(Model model){ model.addAttribute(&quot;username&quot;,&quot;博学谷&quot;); return &quot;success&quot;;} SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用) 在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 12345@RequestMapping(value=&quot;/quick5&quot;)public String save5(HttpServletRequest request){ request.setAttribute(&quot;username&quot;,&quot;酷丁鱼&quot;); return &quot;success&quot;;} SpringMVC的数据响应-回写数据-直接回写字符串(应用) 通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 12345678910@RequestMapping(value=&quot;/quick7&quot;)@ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应public String save7() throws IOException { return &quot;hello itheima&quot;;}@RequestMapping(value=&quot;/quick6&quot;)public void save6(HttpServletResponse response) throws IOException { response.getWriter().print(&quot;hello itcast&quot;);} SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用) 12345@RequestMapping(value=&quot;/quick8&quot;)@ResponseBodypublic String save8() throws IOException { return &quot;{\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18}&quot;;} 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 123456789101112@RequestMapping(value=&quot;/quick9&quot;)@ResponseBodypublic String save9() throws IOException { User user = new User(); user.setUsername(&quot;lisi&quot;); user.setAge(30); //使用json的转换工具将对象转换成json格式字符串在返回 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json;} SpringMVC的数据响应-回写数据-返回对象或集合(应用) 通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 1234567&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 123456789@RequestMapping(value=&quot;/quick10&quot;)@ResponseBody//期望SpringMVC自动将User转换成json格式的字符串public User save10() throws IOException { User user = new User(); user.setUsername(&quot;lisi2&quot;); user.setAge(32); return user;} SpringMVC的数据响应-回写数据-返回对象或集合2(应用) 在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置 1&lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt;默认底层就会集成jackson进行对象或集合的json格式字符串的转换 SpringMVC的请求SpringMVC的请求-获得请求参数-请求参数类型(理解) 客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 SpringMVC的请求-获得请求参数-获得基本类型参数(应用) Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 123456@RequestMapping(value=&quot;/quick11&quot;)@ResponseBodypublic void save11(String username,int age) throws IOException { System.out.println(username); System.out.println(age);} SpringMVC的请求-获得请求参数-获得POJO类型参数(应用) Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 1234567891011121314151617181920212223242526272829303132package com.itheima.domain;public class User { private String username; private int age; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User{&quot; + &quot;username='&quot; + username + '\\'' + &quot;, age=&quot; + age + '}'; }} 12345@RequestMapping(value=&quot;/quick12&quot;)@ResponseBodypublic void save12(User user) throws IOException { System.out.println(user);} SpringMVC的请求-获得请求参数-获得数组类型参数(应用) Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 12345@RequestMapping(value=&quot;/quick13&quot;)@ResponseBodypublic void save13(String[] strs) throws IOException { System.out.println(Arrays.asList(strs));} SpringMVC的请求-获得请求参数-获得集合类型参数1(应用) 获得集合参数时，要将集合参数包装到一个POJO中才可以。 12345678&lt;form action=&quot;${pageContext.request.contextPath}/user/quick14&quot; method=&quot;post&quot;&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 123456789101112131415161718192021222324package com.itheima.domain;import java.util.List;public class VO { private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() { return userList; } public void setUserList(List&lt;User&gt; userList) { this.userList = userList; } @Override public String toString() { return &quot;VO{&quot; + &quot;userList=&quot; + userList + '}'; }} 12345@RequestMapping(value=&quot;/quick14&quot;)@ResponseBodypublic void save14(VO vo) throws IOException { System.out.println(vo);} SpringMVC的请求-获得请求参数-获得集合类型参数2(应用) 当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 1234567891011121314&lt;script src=&quot;${pageContext.request.contextPath}/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var userList = new Array(); userList.push({username:&quot;zhangsan&quot;,age:18}); userList.push({username:&quot;lisi&quot;,age:28}); $.ajax({ type:&quot;POST&quot;, url:&quot;${pageContext.request.contextPath}/user/quick15&quot;, data:JSON.stringify(userList), contentType:&quot;application/json;charset=utf-8&quot; });&lt;/script&gt; 12345@RequestMapping(value=&quot;/quick15&quot;)@ResponseBodypublic void save15(@RequestBody List&lt;User&gt; userList) throws IOException { System.out.println(userList);} SpringMVC的请求-获得请求参数-静态资源访问的开启(应用) 当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 1234567&lt;!--开发资源的访问--&gt;&lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt;&lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt;&lt;mvc:default-servlet-handler/&gt; SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用) 当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 12345678910111213&lt;!--配置全局过滤的filter--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 其中/和/的区别：&lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp，即：*.jsp不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配*.jsp，会出现返回jsp视图时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用) 当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 12345&lt;form action=&quot;${pageContext.request.contextPath}/quick16&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping(value=&quot;/quick16&quot;) @ResponseBody public void save16(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException { System.out.println(username); } SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用) Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick17/zhangsan 12345@RequestMapping(value=&quot;/quick17/{name}&quot;)@ResponseBody public void save17(@PathVariable(value=&quot;name&quot;) String username) throws IOException { System.out.println(username); } SpringMVC的请求-获得请求参数-自定义类型转换器(应用) SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 12345678910&lt;!--注册类型转换器GoodsConverter--&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.jack1024.converter.DateConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; { public Date convert(String dateStr) { //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try { date = format.parse(dateStr); } catch (ParseException e) { e.printStackTrace(); } return date; }} 12345@RequestMapping(value=&quot;/quick18&quot;) @ResponseBody public void save18(Date date) throws IOException { System.out.println(date); } SpringMVC的请求-获得请求参数-获得Servlet相关API(应用) SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(value=&quot;/quick19&quot;)@ResponseBodypublic void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException { System.out.println(request); System.out.println(response); System.out.println(session);} SpringMVC的请求-获得请求参数-获得请求头信息(应用) 使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(value=&quot;/quick20&quot;) @ResponseBody public void save20(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String user_agent) throws IOException { System.out.println(user_agent); } 使用@CookieValue可以获得指定Cookie的值@CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(value=&quot;/quick21&quot;) @ResponseBody public void save21(@CookieValue(value = &quot;JSESSIONID&quot;) String jsessionId) throws IOException { System.out.println(jsessionId); } SpringMVC的特殊请求：文件上传SpringMVC的请求-文件上传-客户端表单实现(应用) 文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=&quot;${pageContext.request.contextPath}/user/quick22&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; SpringMVC的请求-文件上传-文件上传的原理(理解) SpringMVC的请求-文件上传-单文件上传的代码实现1(应用) 添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt; 配置多媒体解析器 12345&lt;!--配置文件上传解析器--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;500000&quot;/&gt;&lt;/bean&gt; 后台程序 123456@RequestMapping(value=&quot;/quick22&quot;)@ResponseBodypublic void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); System.out.println(uploadFile);} SpringMVC的请求-文件上传-单文件上传的代码实现2(应用) 完成上传文件的服务器保存 12345678@RequestMapping(value=&quot;/quick22&quot;)@ResponseBodypublic void save22(String username, MultipartFile uploadFile) throws IOException { System.out.println(username); //获得上传文件的名称 String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename));} SpringMVC的请求-文件上传-多文件上传的代码实现(应用) 多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456&lt;form action=&quot;${pageContext.request.contextPath}/user/quick23&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; 文件2&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 123456789@RequestMapping(value=&quot;/quick23&quot;)@ResponseBodypublic void save23(String username, MultipartFile[] uploadFile) throws IOException { System.out.println(username); for (MultipartFile multipartFile : uploadFile) { String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); }} SpringMVC拦截器SpringMVC拦截器-拦截器的作用(理解) Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 SpringMVC拦截器-interceptor和filter区别(理解，记忆) 关于interceptor和filter的区别，如图所示： SpringMVC拦截器-快速入门(应用) 自定义拦截器很简单，只有如下三步： 创建拦截器类实现HandlerInterceptor接口 配置拦截器 测试拦截器的拦截效果 编写拦截器： 12345678910111213141516public class MyInterceptor1 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle.....&quot;); retrun true;//true表示放行，false表示不放行} //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) {System.out.println(&quot;postHandle...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion....&quot;); }} 配置：在SpringMVC的配置文件中配置 123456789&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 12345678910111213@Controllerpublic class TargetController { @RequestMapping(&quot;/target&quot;) public ModelAndView show(){ System.out.println(&quot;目标资源执行......&quot;); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView; }} 页面 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World! ${name}&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; SpringMVC拦截器-快速入门详解(应用) 拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， 1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor { //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException { System.out.println(&quot;preHandle22222.....&quot;); return true; } //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { System.out.println(&quot;postHandle2222...&quot;); } //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { System.out.println(&quot;afterCompletion2222....&quot;); }} 配置拦截器2 12345678910111213&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion SpringMVC拦截器-知识小结(记忆) 拦截器中的方法说明如下 SpringMVC拦截器-用户登录权限控制分析(理解) 在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： SpringMVC拦截器-用户登录权限控制代码实现1(应用) 判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： 1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException { //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if(user==null){ //没有登录 response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;); return false; } //放行 访问目标资源 return true; }} 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： 12345678&lt;!--配置权限拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; SpringMVC拦截器-用户登录权限控制代码实现2(应用) 在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 1234567891011@RequestMapping(&quot;/login&quot;)public String login(String username,String password,HttpSession session){ User user = userService.login(username,password); if(user!=null){ //登录成功 将user存储到session session.setAttribute(&quot;user&quot;,user); return &quot;redirect:/index.jsp&quot;; } return &quot;redirect:/login.jsp&quot;;} service层代码如下： 123456//service层public User login(String username, String password) { User user = userDao.findByUsernameAndPassword(username,password); return user;} dao层代码如下： 123456//dao层public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException{ User user = jdbcTemplate.queryForObject(&quot;select * from sys_user where username=? and password=?&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user;} 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 12345678910&lt;!--配置权限拦截器--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; SpringMVC拦截器-用户登录权限控制代码实现3(应用) JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 123456789public User login(String username, String password) { try { User user = userDao.findByUsernameAndPassword(username,password); return user; }catch (EmptyResultDataAccessException e){ return null; }} 异常处理异常处理的思路 系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 异常处理两种方式 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 简单异常处理器SimpleMappingExceptionResolver SpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 12345678910&lt;!--配置简单映射异常处理器--&gt;&lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error1&quot;/&gt; &lt;property name=“exceptionMappings”&gt; &lt;map&gt; &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error2&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error3&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 自定义异常处理步骤 创建异常处理器类实现HandlerExceptionResolver 1234567891011public class MyExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;exceptionPage&quot;); return modelAndView; }} 配置异常处理器 1&lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; 编写异常页面 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456@RequestMapping(&quot;/quick22&quot;)@ResponseBodypublic void quickMethod22() throws IOException, ParseException { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;);}","link":"/2021/01/21/SSM%E6%A1%86%E6%9E%B6-SpringMVC/"},{"title":"java基础快速回顾-上","text":"java语言开发环境搭建java虚拟机——JVM 实质就是翻译，把.class文件翻译成计算机能认识的机器语言 java所谓的跨平台指的是java程序跨平台。JVM不是跨平台的，各个平台（Windows，Linux，mac）的JVM是不同的。 Java这个语言很非凡。一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 JRE和JDK JRE：java Runtime Environment，包含JVM和运行时需要的核心类库 JDK：java Development Kit，是java程序开发工具包，包含JRE和开发人员使用的工具 想要运行一个已有的java程序，那么只需安装JRE即可；想要开发一个全新的java程序，那么必须安装JDK 配置JDK环境变量 在全局系统变量中2个操作 新建JAVA_HOME变量：（jdk的安装路径） 修改Path：添加%JAVA_HOME%\\bin HelloWorld入门程序程序开发步骤 java程序开发三步骤：编写——》.java——》编译（编译器javac.exe）——》.class——》运行（JVM解释执行：java.exe） 新建文件名为HelloWorld的java文件，编辑： 12345public class HelloWorld{//public的类名必须和文件名完全一致 public static void main(String[] args){ System.out.println(&quot;Hello,world!&quot;); }} 1234//编译javac HelloWorld.java//JVM解释执行java HelloWorld HelloWorld程序说明 单行注释，多行注释： 12//单行注释/*多行注释*/ public static void main(String[] args)是程序入口 关键字说明：java中有特殊含义的保留字 标识符： 指的是在程序中，我们自定义的内容中，如类的名字，方法的名字，变量的名字等都是标识符， 命名规则（硬性要求） 标识符可以包含：英文字符，数字，$符，_下划线 标识符不能以数字开头 标识符不能是关键字 命名规范（软性要求） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式） 变量名规范：首字符小写，后面每个单词首字母小写（小驼峰式） 方法名规范：同变量名 常量 概念：在程序运行期间固定不变的量 分类： 字符串常量：双引号引起来的 整数常量：直接写上的数字，没有小数点 浮点数常量：直接写上的数字，有小数点 字符常量：单引号引起来的单个字符，有且仅有一个字符 布尔常量：true或者false 空常量：null，代表没有任何数据 数据类型引用数据类型 字符串，数组，类，接口，Lambda等 基本数据类型 整数型：byte，short，int，long 浮点型：float，double 字符型：char 布尔型：boolean 注意事项： 字符串不是基本类型，是引用类型 浮点型可能只是一个近似值 数据范围与字节数不一定相关 浮点数默认是double，float需要加后缀F 整数默认是int，long需要加上后缀L 变量 程序运行期间，内容可以发生改变的量 格式： 123数据类型 变量名称; //创建一个变量变量名称 = 数据值; //赋值数据类型 变量名称 = 数据值; //一步到位 局部变量没有默认值，没有进行赋值不能直接使用 变量使用不能超过作用域（从定义变量开始，一直到直接所属的大括号结束为止）的范围 数据类型转换 当等号两边的数据类型不一致时，将会发生数据类型转化，分为自动类型转换（隐式）&amp;强制类型转换（显式） 自动转换（隐式） 规则：数据范围小的转化为大的。与字节数不一定相关。 强制转换（显式） 规则：范围小的类型 范围小的变量名 = （范围小的类型）范围大的数据 整形强制转换可能发生数据溢出：long——》int 浮点型强制转换可能精度损失：double——》int byte/short/char三种类型都可以发生数学运算，在运算时首先会提升为int，再进行运算 boolean类型不能发生任何数据类型转换 ASCII&amp;Unicode 48代表’0’，65代表’A’，97代表’a’ 数字和字符的对照关系表：是ASCII码表（American Standard Code for Information Interchange） Unicode码表（万国码）：也是数字和符号的对照关系，开头0-127部分和ASCII完全一样，但是从128开始含有更多字符，包含中文字符。 运算符 运算符：运算特定操作的符号 表达式：用运算符连起来的式子叫做表达式 运算符分类： 算数运算符：+，-，*，/，%，++，– 如果运算中有不同类型的数据，那么结果将会是数据类型范围大的那种（类型自动转换） 加法：对于数值来说，就是数学加法；对于char来说，先按照ascii或unicode提升为int，然后再计算；对于String来说，是字符串的连接操作。 任何数据类型和字符串进行加法操作时，结果都会连接变成字符串。 常量不能使用自增or自减 赋值运算符： =，+=，-=，*=，/=，%= 只有变量才能写在赋值运算符左边 复合赋值运算符隐含了一个强制类型转换 12byte num = 30;num += 5;//num = (byte) (int + int) 比较运算符： ==，&lt;，&gt;，&lt;=，&gt;=，!= 比较运算符的结果一定是一个boolean值 多次判断不能连着写 逻辑运算符： &amp;&amp;，||，！ &amp;&amp;和||具有短路效果，从而节省一定的性能 逻辑运算符只能用于boolean值 &amp;&amp;和||可以连续写 对于1&lt;x&lt;3的连续情况，应该拆分为两个部分，然后使用运算符连接起来1&lt;x&amp;&amp;x&lt;3 三元运算符： 格式：数据类型 变量名称 = 条件判断？表达式A：表达式B 条件判断true，表达式A的值赋给变量；条件判断false，表达式B的值赋给变量 方法 引入：先把握整体，再把握局部 方法的定义 方法定义的先后顺序无所谓 方法定义必须是挨着的，不能在一个方法的内部定义另一个方法 格式： 1234修饰符 返回值类型 方法名称(参数类型 参数名称,...){ 方法体; return 返回值;} 方法的调用 方法定义后要执行需要在另一个方法中调用 三种调用格式 123456//单独调用方法名称(参数);//打印调用System.out.println(方法名称(参数));//赋值调用数据类型 变量名称 = 方法名称(参数); 方法三要素：返回值，方法名称，参数列表 return两个作用：结束方法执行；返回一个返回值。 方法注意事项： 方法应该定义在类当中，不能在方法中定义方法。 如果方法有返回值，必须写上return 返回值; 如果方法返回值类型为void，可以不写return语句，或者写return;（此时return是结束方法的作用） return 后面的值类型必须和方法的返回值类型对应 一个方法中可以有多个return语句，但是必须保证一次执行只有一个会被执行到 Jshell Java Shell工具（JShell）是一个用于学习Java编程语言和Java代码原型的交互式工具。JShell是一个Read-Evaluate-Print循环（REPL），它在输入时评估声明，语句和表达式，并立即显示结果。该工具从命令行运行。 编译器的两点优化 对于byte/short/char三种类型来说，如果右侧赋值数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)/(short)/(char)；如果右侧超过了左侧范围，那么会直接编译器报错 在给变量赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果 流程顺序结构选择结构 单if if ；else if ；else if；else if；else switch ；case break；default [break] 最后一个break语句可以省略，但是一般不省略 switch后面的小括号中之只能是byte/short/char/int/String/enum枚举 switch语句格式可以很灵活，前后顺序可以颠倒。匹配哪一个case就从哪一个位置向下执行，直到遇到break或者整体结束为止。 如果执行到某个case且该case没有break，会穿透它下面的那个case 循环结构 循环结构一般分为四部分： 初始化语句：在循环开始最初执行，而且只执行一次 条件判断：如果成立循环继续，否则循环退出 循环体：重复要做的内容，若干语句 步进语句：每次循环后的扫尾工作 for语句： 结构 123for(初始化表达式;条件判断布尔表达式;步进表达式){ 循环体} while语句 结构： 12345初始化语句;while(条件判断){ 循环体; 步进语句;} do-while语句 结构：无条件执行第一次 12345初始化语句;do{ 循环体; 步进语句;}while(条件判断); 三种循环区别 如果条件判断从来没有满足过，那么for和while执行0次，但是do-while至少会执行1次 for循环的变量定义在小括号中，那么循环内部才能使用 次数确定用for循环，否则多用while循环 break关键字和continue关键字 break用在switch中：一旦执行，整个switch立刻结束 break用在循环中：一旦执行，break的外第一层循环语句立刻结束 continue用在循环中：一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环 IDEA快捷键 方法重载 对于功能类似的方法来说，因为参数列表不同却需要不同的方法名，太麻烦，所以引入了方法的重载。 方法的重载（override），多个方法的方法名一样，但是参数列表不一样。只需一个方法名，就可以实现多个功能 所谓的参数列表不一样，指的是： 参数个数不同 参数类型不同 参数的多类型顺序不同 但是和“参数名称，返回值类型，方法修饰符”无关 Java中的典型重载：System.out.println()方法 数组 概念：一种容器，可以同时存放多个同类型数据 特定： 是一种引用类型 数组中的多个数据，类型必须统一 数组的长度在程序运行中不可改变 数组的初始化：在内存中创建一个数组，并且向其中赋予一位默认值 动态初始化：指定长度 123数据类型[] 数组名称 = new 数据类型[数组长度];int[] arrayA = new int[300];String[] stringA = new String[10]; 静态初始化：指定内容 1234567数据类型[] 数组名称 = new 数据类型[]{元素1,元素2...};int[] arrayB = new int[]{1,2,3,4,5};String[] stringA = new String[]{&quot;Hello&quot;,&quot;World&quot;};//静态初始化的省略格式数据类型[] 数组名称 = {元素1,元素2...};String[] stringA = {&quot;Hello&quot;,&quot;World&quot;}; 注意： 静态初始化没有直接指定长度，但是可以根据大括号里的元素的具体内容直接推算出长度 静态初始化&amp;动态初始化的标准格式可以差分为两个步骤，但是静态初始化的省略格式不能拆分。 12345int[] array1;array1 = new int[]{1,2,3};int[] array1;array1 = new int[5]; 直接打印数组名，得到的是数组对应的内存地址哈希值 访问数组元素： 12int[] arrayA = {1,3,2};System.out.println(arrayA[1]); 如果动态初始化数组的时候，元素会自动拥有默认值，规则如下： 整数类型：0 浮点类型：0.0 字符类型：’\\u0000’ 布尔类型：false 引用类型：null 静态初始化也有默认值，只是系统自动马上将默认值的替换成为了大括号当中的具体数值 数组经常遇到的问题： 数组索引越界异常：ArrayIndexOutOfBoundsException ```java//未初始化int[] array1;System.out.println(array1[0]); //空指针异常NullPointerExcetionint[] array2 = null;System.out.println(array2[0]); 1234567* 获取数组长度：`数组名称.length`；数组一旦创建，程序运行期间+长度不可改变 ```java for(int i=0;i&lt;array.length;i++){ System.out.println(array[i]); } 遍历数组：就是对数组中每一个元素进行逐一处理。 数组作为方法参数和方法返回值： 当调用方法的时候，向方法小括号传递的参数实际上是数组的地址值 任何数据类型都能作为方法的参数类型和返回值类型，数组作为参数 1234567891011121314151617181920212223public static void main(String[] args){ int[] array = {10,20,30,40}; printArray(array);//传进去的就是一个地址 int[] result = calculator(10,20,30); System.out.println(result[0]); System.out.println(result[1]);}public static void printArray(int[] array){ for(int i = 0;i&lt;array.length;i++){ System.out.println(array[i]);//地址值[i]使用 }}public static int[] calculate(int a,int b,int c){ int sum = a + b; int avg = sum / 3; int[] array = new int[2]; array[0] = sum; array[1] = avg; return array;} Java内存模型 java类的成员变量new的时候会有初始值，但是方法中的局部变量不会有初始值。这条性质能用java的内存模型来解释。 栈：存放的是方法中的局部变量 局部变量：方法的参数，方法内部的变量，局部变量有作用域，一旦超出作用域，立刻从栈内存中消失 堆：凡是new出来的东西，都在堆中 堆内存中的数据都有默认值：整数类型：0；浮点类型：0.0；字符类型：’\\u0000’；布尔类型：false；引用类型：null 方法区：存储.class相关信息，包含方法的信息，包括static方法&amp;变量，类加载器classloader。 注意：方法区只是包含了方法固定的相关信息，但是方法真正运行的数据都在栈中 本地方法栈：：与操作系统相关 寄存器：与CPU相关 数组内存图： 使用对象类型作为方法的参数&amp;返回值 当一个对象or数组作为参数，传递到方法中时，实际上传递的是对象or数组的地址值 当一个对象or数组作为返回值时，实际上返回的是对象or数组的地址值 局部变量 and 成员变量 定义位置 作用域 默认值 位置 生命周期 局部变量 方法内 方法内 没有 栈 同方法栈的诞生&amp;消失 成员变量 方法外 类中 有(同数组) 堆 同对象的诞生&amp;消失 面向对象思想 面向过程：当需要实现一个功能时，每一个具体的步骤都要亲力亲为，详细处理每一个细节 面向对象：当需要实现一个功能时，不关心具体步骤，而是找一个能实现该功能的人帮我做事，帮你做事的这个人就是对象。 1234567891011121314int[] array = {10,20,30,40,50};//希望能把数组打印为[10,20,30,40,50]//面向过程System.out.println(&quot;[&quot;);for(int i = 0;i&lt;array.length;i++){ if(i == array.length-1){ System.out.println(array[i]+&quot;]&quot;); } else{ System.out.println(array[i]+&quot;,&quot;); }}//面向对象System.out.println(Arrays.toString(array)); 类是对象的模板，对象是类的实例 类： 成员变量（属性）：直接定义在类中方法之外 成员方法（行为）：普通方法有static，成员方法灭有static 通常类不能直接使用，需要根据类创建一个对象 导包：import 包名.类名，如果两个类同属一个包，可以不import 创建：类名称 对象名 = new 类名称() 使用：对象名.成员变量名，成员方法名() new一个对象时，如果成员变量没有赋值会有一个默认值，规则和数组一样 一个对象的内存区： 对于堆中的一个对象来说，他的成员方法保存的实际上是一个地址值，指向方法区中的成员方法内容 一个对象的内存图： 两个对象使用同一个方法的内存图：自己思考 两个引用指向同一个对象的内存图：自己思考 面向对象三大特征 封装 继承 多态 封装性 方法就是一种封装：将不同功能模块提取出来单独成一个方法，可以说成面向方法编程 关键字private也是一种封装：使用private修饰成员变量和方法。本类中可以随意访问，但是超出了本类无法直接访问。可通过public方法访问（例如setter和getter） 含义：将一些细节信息隐藏起来，对外界不可见。 this关键字方法中的局部变量和类中的成员变量从名的时候，根据“就近原则”，优先局部变量。如果方法中重名了，并且需要本类中的成员变量，需要加this关键字。 重点：通过谁调用的方法，谁就是this 构造方法专门用来创建对象的方法，我们通过关键字new来创建对象的时候，其实就是调用了构造方法。 构造方法名称需要和类的名称一模一样 构造方法没有返回值，不能return，方法前连void都不要写 如果没有编写任何构造方法，编译器会默认一个什么都不做的构造方法。如果自己写了一个有参构造函数，最好加一个无参构造函数，因为编译器不会赠送。 一旦编写了至少一个构造方法，编译器不会赠送构造方法了 构造方法可以进行重载 重载：方法名相同，参数不同 标准的类（JavaBean） 所有成员变量都使用private关键字修饰 为每一个成员变量编写一对 Getter和Setter 方法 编写一个无参构造方法 编写一个全参构造方法 几个重要的Java API 导包：import 包路径.类名称（同包可不导，java.lang下可不导） 创建：类名称 对象名 = new 类名称(); 使用：对象名.成员方法名(); Scanner1234import java.util.Scanner;Scanner sc = new Scanner(System.in);//从键盘输入int a = sc.nextInt();//获取从键盘输入的int变量String str = sc.next();//获取从键盘输入的字符串变量 Random12345import java.util.Random; Random r = new Random();//随机数种子int num1 = r.nextInt();int num2 = r.nextInt(3);//范围：左闭右开[0,3) ArrayList1234567891011121314//泛型只能是引用类型，不能是基本类型ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//常用方法boolean isAdd = list.add(&quot;Sam Smith&quot;);list.add(&quot;Mariah Carey&quot;);list.add(&quot;Colbie Caillat&quot;);String name = list.get(0);String delName = list.remove(1);//返回值是删除的元素int size = list.size();//ArrayList保存基本类型包装类//Byte,Short,Integer,Long,Float,Double,Character,BooleanArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);//从jdk1.5后，支持自动装箱/自动拆箱int i0 = list.get(0); String：字符串 字符串内容不可变 存在字符串常量池中的字符串可共享 字符串效果上相当于char[]字符数组 12345//创建字符串String s1 = new String();String s2 = new String(char[] array);String s3 = new String(byte[] array);String s4 = &quot;hahahahaha&quot;;//在字符串常量池中 12345678910111213141516171819202122232425262728//常用方法//equals() &amp; equalsIgnoreCase()String s1 = &quot;hello&quot;;String s2 = new String(&quot;hello&quot;);System.out.println(s1==s2);System.out.println(s1.equals(s2));System.out.pringln(s1.equalsIgnoreCase(&quot;Hello&quot;));//length()int l = s1.length();//concat()String s3 = s1.concat(&quot;,world!&quot;);//返回新的字符串，字符串是常量不变//charAt()char ch = s1.charAt(1);//indexOf()int index = s1.indexOf(&quot;ll&quot;);//subString():截取String s4 = s3.subString(6);//worldString s5 = s3.subString(0,5);//hello//toCharArray():转换为char数组char[] chars = &quot;Hello&quot;.toCharArray();//getBytes():转换为byte数组byte[] bytes = &quot;Hello&quot;.getBytes();//replace():替代String str1 = &quot;What's the matter with you,fuck U!&quot;;String str2 = str1.replace(&quot;fuck&quot;,&quot;***&quot;);//split():分割String str3 = &quot;aaa,bbb,ccc&quot;;String[] array1 = str3.split(&quot;,&quot;);//参数是正则表达式 注意：String的getBytes()方法将String转化为字节使用的编码是当前.java文件的编码。 工具类Arrays，Math1234567//Arraysimport java.util.Arrays;//toString():以字符串的形式打印数组int[] intArray = {2,3,1,4,5};String intStr = Arrays.toString(intArray);//sort():如果排序自定义类型数组，该自定义类必须实现Comparable or Comparator接口Arrays.sort(intArray);//会直接修改intArray数组 1234567891011//Mathimport java.util.Math;//abs()System.out.println(Math.abs(-3.14));//ceil():向上取整System.out.println(Math.ceil(3.14));//floor():向下取整System.out.println(Math.floor(3.14));//round():四舍五入System.out.println(Math.round(3.14));//Math.PI:近似圆周率 其他知识点：匿名对象 格式：new 类名称(); 确定某个对象只需用使用一次，那么可以使用匿名对象，之后会被自动回收。 匿名对象可以作为 参数 &amp; 返回值 ```javanew Person().name = “Mariah Carey”; 12345678910111213141516171819#### static关键字* 一个成员变量 or 成员方法 有了static关键字，就是属于类的，本类所有对象共享同一份* 静态成员方法只能访问静态成员变量（因为静态方法是class初始化就建立在了内存的方法区，此时对象中的普通成员变量可能还没有在内存的堆中建立）* 静态方法中不能用 this 关键字，**static和类相关，和对象无关*** 静态代码块 比构造方法先执行，并且只执行一次 用来一次性对静态成员变量进行赋值 ```java static{ //内容 } 继承性 子类和父类关系是 “子类 is a 父类” 的关系 ```javapublic class Employee{ private int name; private int age; }public class Teacher extends Employee{ private int level; } 123456789101112131415161718192021222324252627282930313233343536373839* 父子类继承关系中，如果成员变量重名，创建子类对象时，有两种方式 1. 直接通过**子类对象**访问成员变量：等号左边是谁，就优先用谁，没有就向上找 2. 间接通过**成员方法**访问成员变量：方法属于谁就优先用谁的，没有就向上找* **重写特点：**（方法重写/覆盖：方法名，参数相同） 1. 父子类的方法重名，访问成员变量的规则：new创建的对象是谁，就优先用谁，没有就往上找 2. `@override`注解用来检测是否覆盖正确 3. 子类方法的返回值类 必须 低于等于 父类方法的返回值类 4. 子类方法的权限修饰符 必须 大于等于 父类方法的权限修饰符 * public &gt; protected &gt; (default) &gt; private 5. 设计原则：对于已经投入使用的类，不要改动它。定义一个新类继承老类重复利用父类共性并添加新的改动 ```java public class Phone{ public void call(){ System.out.println(&quot;打电话&quot;); } public void send(){ System.out.println(&quot;发短信&quot;); } public void show(){ System.out.println(&quot;显示号码&quot;); } } public class NewPhone extends Phone{ public void snow(){ super.show(); System.out.println(&quot;显示姓名&quot;); System.out.println(&quot;显示头像&quot;); } } 子类构造方法中的第一个语句是一个赠送的super()，但是不会赠送有参父类构造，需要自己显式声明super(参数)来调用父类重载构造 super关键字三种用法： 子类成员方法中，访问父类成员变量 子类成员方法中，访问父类成员方法 子类构造方法中，访问父类构造方法 this关键字三种用法： 本类成员方法中，访问本类成员变量 本类成员方法中，访问本类成员方法 本类构造方法中，访问本类另一个构造方法 **this 和 super **不能同时存在于一个构造方法中 Java语言是单继承，多级继承的 抽象类 &amp; 抽象方法123456public abstract class Animal{ //抽象方法所在的类必须是抽象类 public abstract void eat();//抽象方法 public void normalMethod(){//普通方法 }} 不能直接new抽象类对象。但是抽象类中可以有构造函数，用来供子类对象创建时初始化父类成员变量 必须用子类继承抽象类 并 覆盖重写所有的抽象方法 12345public class Cat extends Animal{ public void eat(){ System.out.println(&quot;cat eat fish.&quot;); }} 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类 抽象类的子类必须重写父类中的抽象方法，除非子类也是抽象类 接口类 接口类中，不同jdk版本能包含的内容不同 jdk7：常量，抽象方法 123456789101112public interface MyInterface{ //常量：public,static,final是固定的,可以省略 public static final int NUM_OF_MY_CLASS = 10;//必须赋值 //public和abstract是固定的,可以省略 public abstract void methodAbs();}public class MyInterfaceImpl implements MyInterface{ @Override public void methodAbs(){ System.out.println(&quot;first method&quot;); }} jdk8：默认方法，静态方法 12345678910//默认方法：实现类不必实现，因为接口中的默认方法有实现public interface MyInterface{ public default void methodAbs(){ System.out.println(&quot;默认方法&quot;); } //不能通过接口实现类对象来调用静态方法：因为一个类可以实现多个接口。应该通过接口名调用 public static void methodAbs2(){ System.out.println(&quot;静态方法&quot;); }} jdk9：私有方法 需要解决的问题：需要一个共有方法来解决两个默认方法之间的重复代码问题，但是这个共有方法不该让实现类实现，应该是私有化的。 普通私有方法：解决多个默认方法之间的重复代码问题 静态私有方法：解决多个静态方法之间的重复代码问题 接口-接口：多继承 类-类：单继承 类-接口：多实现 多态性 继承是多态的前提：学生既是学生，也是人，同事拥有多种形态 ```java父类名称 对象名 = new 子类名称();接口名称 对象名 = new 实现类名称(); 1234567* 注意：继承 or 实现中，成员方法能覆盖重写，但是成员变量不能。所以： ```java Fu obj = new Zi(); obj.成员变量;//看等号左边是谁就访问谁的成员变量，没有就向上找（编译看左边，运行还看左边） obj.成员方法();//new的谁就优先用谁的成员方法，没有就向上找（编译看左，运行看右） 对象向上转型 向上转型一定是安全的 但是一旦上转为父类，就无法调用子类特有的方法 1234//创建一只猫，当做动物看待Animal animal = new Cat();//类似于自动类型转化(范围大&lt;---范围小)double num = 100; 对象向下转型 上转后，如果需要调用子类特有的方法，需要再原路下转 可以使用instanceof判断类的所属 123456//上转后，还原为猫Animal animal = new Cat();Cat cat = (Cat)animal;//类似于强制类型转换(范围小&lt;---范围大)int num = (int)10.0;//只能原路还原，如果把animal还原为狗，会报错ClassCastException,就像强制类型转换的精度损失 final关键字：“断子绝孙”关键字 可以修饰一个类：不能有任何子类 1public final class MyClass {}//和abstract关键字矛盾 可以修饰一个方法：不能覆盖重写 1public final void method(){}//和abstract关键字矛盾 可以修饰一个局部变量 1234final int num = 10;//常量final int num;num=10;//也可以//对基本数据类型来说，是变量的数据不可改变//对于引用数据类型来说，是引用的数据不可改变，即是引用所指向的地址不可改变 可以修饰一个成员变量 123456//和局部变量的区别是成员变量有默认值，所以一旦是final的成员变量，如果不第一时间初始化，他就只能是默认值常量/**final成员变量赋值的两种方式 1. 直接赋值 2. 构造方法赋值**/ 4种权限修饰符 (public &gt; protected &gt; (default) &gt; private) public protected (default) private 同一个类 √ √ √ √ 同一个包 √ √ √ × 不同包子类 √ √ × × 不同包非子类 √ × × × 内部类成员内部类 内用外，随意访问；外用内，需要内部类对象 1234567891011121314151617181920212223public class Body{ public class Heart{//成员内部类 public void beat(){ System.out.println(&quot;内部类方法&quot;); System.out.println(name);//内用外 } } private String name; public void methodBody{ new Heart().beat();//外用内 System.out.println(&quot;外部类方法&quot;); }}public class MainTest(){ public static void main(){ Body body = new Body(); body.methodBody();//间接使用成员内部类 Body.Heart heart = new Body().new Heart();//直接使用成员内部类 heart.beat(); }} 12345678910111213//内部类成员变量重名情况public class Outer{ int num = 10; public class Inner{ int num = 20; public void methodInner(){ int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(Outer.this.num);//10 } }} 局部内部类 只有当前所属的方法内部才能使用 从jdk8开始，只要局部内部类的局部变量事实不变，那么final关键字可以省略。 123456789101112131415161718public class Outer{ public void methodOuter(){ class Inner{//局部内部类 int num = 10;//jdk8后,final关键字可省略 public void methodInner(){ System.out.println(num); } } Inner inner = new Inner(); inner.methodInner(); }}public class MainTest(){ public static void main(){ Outer outer = new Outer(); outer.methodOuter(); }} 匿名内部类 如果接口的实现类 or 父类的继承类 只需要使用唯一的一次，那么可以省略该类的定义，直接使用【匿名内部类】 匿名内部类是省略了【单独实现子类】，匿名对象是省略了【对象引用名称】 1234567891011121314151617181920public interface MyInterface{ void method();//抽象方法}public class MainTest(){ public static void main(){ MyInterface obj = new MyInterface(){ @Override public void method(){ System.out.println(&quot;匿名内部类实现了方法&quot;); } }; obj.method(); MyInterface obj2 = new MyInterface(){ @Override public void method(){ System.out.println(&quot;匿名内部类实现了方法&quot;); } }.method();//匿名内部类的匿名对象 }} 小结外部类权限：public任何包都可以访问 / (default同一个包可以访问) 成员内部类权限：所有都可以 局部内部类权限：什么都不能写","link":"/2020/12/19/java%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE-%E4%B8%8A/"},{"title":"vue入门指南","text":"vue：一款渐进式（逐步实现新特性）JavaScript框架。其特性综合了Angular(模块化MVVM)和React(虚拟DOM)的优点 Ajax：前端通信框架，因为Vue的边界很明确，就是为了处理DOM，所以不具备通信能力，需要额外使用一个通信框架和服务器交互；也可以直接选择使用jQuery提供的Ajax同行功能(只是因为为了使用Ajax要完全导入jQuery的包显得很笨重) 前端MVVM框架： 后端中的MVC框架中V：视图层；C：控制层；M：模型层 传统的使用后端模板引擎渲染的方式，V就是指的jsp，freemarker等技术。 前后端分离的概念渐渐出现，特别是在前端框架出现后，前端根据后端的MVC模式，也对前端进行了层次划分，对原来的V转化前端独立渲染。并且也将V扩展为前端自己的MVC三层：V层，M层，VM层。也就是MVVM模式 V：view M：data VM：数据双向绑定 前端UI框架： Ant-Desgin：基于React的UI框架 ElementUI，iview，ice：基于Vue的UI框架 Bootstrap：Twitter推出的前端开发工具包 AmazeUI：HTML5跨屏前端框架 JavaScript构建工具： Babel：JS编译工具，主要用于浏览器不支持的ES新特性 WebPack：模块打包器 NodeJS 前端人员为了方便开发也需要掌握一定的后端技术，但是java后端异常庞大。所以为了方便前端人员开发后台应用，出现了NodeJS这样的技术。 NodeJS由于架构问题和笨重的node_modules，作者已经放弃，不久的将来，Deno可能将会取代NodeJS Express：NodeJS框架 Koa：Express简化版 NPM：项目综合管理工具 YARN：NPM的替代方案，类似于Maven和Gradle的关系 vue-element-admin: 这是一个集成大部分功能的后台管理系统框架，也就是说大多数的组件都帮我们写好了，他是基于vue-element进行开发布局的。 MVVM框架 源自经典的MVC模式，MVVM的核心是ViewModel层，负责转换Model中的数据对象来让数据变得更容易管理和使用 具体分层： Model：模型层，这里表示JavaScript对象 View：视图层，这里表示DOM ViewModel：连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者 ViewModel MVVM架构中，不允许数据和视图直接通信，只能通过ViewModel通信，而ViewModel就是定义了一个Observer观察者 ViewModel能观察到数据的变化，并对视图相应内容进行更新 ViewModel能监听试图的变化，并能够通知数据发生改变 Vue.js的核心是：DOM监听&amp;数据绑定 虚拟DOM：Vue的ViewModel绑定了数据和视图两层，所以无需操作DOM，工作知识修改DOM中的某些数据而已。这让前端资源大大节省了。 View层展现的不是Model层的数据，而是ViewModel的数据，由ViewModel负责和Model层交互，这就完全解耦了View层和Model层，这个解耦是至关重要的，它是前后端分离的关键。 VUE{ { } } &amp; v-text,v-cloak &amp; v-html 这就是前端的浏览器模板引擎渲染生成html页面。Vue在背后做了大量工作，现在数据和DOM已经建立了关系，所有东西都是响应式的。在控制台操作对象属性后界面能实时更新。 1234567891011&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;!--创建一个容器，使用Vue对象绑定该容器就可以控制这个容器中的所有DOM元素--&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--插值表达式中可以写任意合法的JS表达式--&gt; &lt;!--插值表达式会有闪烁问题，用v-cloak解决--&gt; &lt;span&gt;{{ message }}&lt;/span&gt; &lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt; &lt;span v-html=&quot;message2&quot;&gt;&lt;/span&gt;&lt;/div&gt; 1234567var app = new Vue({//这个对象app就是MVVM中的VM，核心，提供了双向数据绑定的能力 el: '#app',//和要控制的容器绑定，MVVM中的V视图层 data: {//要渲染的一些数据，MVVM中的M数据层 message: 'Hello Vue!' message2: '&lt;h1&gt;Hello&lt;/h1&gt;' }}) v-bind &amp; v-if,v-else &amp; v-for12345&lt;!--在html原始标签属性前加上v-bind:可以将属性和vue的data数据单向绑定，也可以简写只留一个冒号--&gt;&lt;!--v-bind中要用表达式的拼接需要用引号包裹起来--&gt;&lt;div id=&quot;app&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt;&lt;/div&gt; v-bind：v-前缀的被成为指令，它们是vue提供的一种特殊标签属性。它们会在渲染的DOM上应用特殊的响应式行为。意思就是：将这个元素的节点的title特性和vue实力的message属性保持一致 判断和循环指令：v-if和v-else 1234567891011121314151617&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1 v-if=&quot;ok=='A'&quot;&gt;A&lt;/h1&gt; &lt;h1 v-else-if=&quot;ok='B'&quot;&gt;B&lt;/h1&gt; &lt;h1 v-else&gt;C&lt;/h1&gt;&lt;/div&gt;&lt;!--只要涉及到v-for这种循环，推荐给每一项都加上:key属性，并且:key属性只接受number或string类型唯一的数据--&gt;&lt;div id=&quot;vm&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,i) in items&quot; :key=&quot;item&quot;&gt; {{i}}-----{{item.message}} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516var app = new Vue({ el: '#app', data: { ok: 'B' }})var vm = new Vue({ el: '#vm', data: { items:[ {message: '哈哈哈'}, {message: '嘿嘿嘿'} ] }}) 一般而言，v-if 有更高的切换消耗而v-show 有更高的初始渲染消耗。因此如果需要频繁切换,v-show更好，如果在运行时条件不改变v-if较好 事件v-on 事件一定要定义在Vue对象中的methods中 12345678&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;sayHi&quot;&gt;&lt;/button&gt; &lt;!--简写--&gt; &lt;button @click=&quot;sayHi2&quot;&gt;&lt;/button&gt;&lt;/div&gt; 123456789101112131415var app = new Vue({ el: '#app', data: { message: '人生如梦' }, methods: {//methods属性中可以定义多个事件处理函数 sayHi: function(){ alert(this.message);//要访问data中的值要用this,this代表vm实例app } //简写 sayHi2(){ alert(this.message); } }}) v-model实现双向绑定v-bind 产生的效果不含有双向绑定，所以 :value 的效果就是让 input的value属性值等于 data.name 的值，而 v-model 的效果是使input和 data.body 建立双向绑定，因此首先 data.body 的值会给input的value属性，其次，当input中输入的值发生变化的时候，data.body 还会跟着改变。 12345678&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--vue中，只有v-model实现了事项绑定--&gt; &lt;!--vue中，v-model只能应用到表单元素中--&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;{{message}}&lt;/div&gt; 123456var app = new Vue({ el: '#app', data: { message: '123' }}) 双向数据绑定目的：为了修改表单后不用自己操作DOM元素获取表单元素的值。 单项数据绑定目的：为了不用自己操作DOM去渲染数据。 事件修饰符 @click**.stop**:组织事件冒泡 @click**.prevent**:组织标签默认行为，例如a的href，form的submit @click**.capture**:将默认的冒泡模式改为捕获模式 @click**.self**:只有事件在该元素身上触发才会调用 @click**.once**:事件只触发一次 vue中使用类样式的4种方式1234567891011121314151617&lt;!--red，small,thin,italic等是css样式类--&gt;&lt;!--第一种--&gt;&lt;h1 :class=&quot;['red','small']&quot;&gt;Hello,world!&lt;/h1&gt;&lt;!--第二种--&gt;&lt;h1 :class=&quot;['red',isThin?'thin':'']&quot;&gt;Hello,world!&lt;/h1&gt;&lt;input type=&quot;button&quot; value=&quot;变瘦&quot; @click=&quot;isThin=true&quot;&gt;&lt;!--第三种--&gt;&lt;h1 :class=&quot;['red',{thin:isThin}]&quot;&gt;Hello,world!&lt;/h1&gt;&lt;!--第四种--&gt;&lt;h1 :class=&quot;{red:true,italic:true,thin:isThin}&quot;&gt;Hello,world!&lt;/h1&gt;var app = new Vue({ el: '#app', data: { isThin: false }}) 一般最常用第二个和第三个实现CSS类的动态切换 vue中行内style样式1&lt;h1 :style=&quot;{color:'red','font-size':'italic'}&quot;&gt;Hello,world!&lt;/h1&gt; 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id:&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;id&quot;&gt; &lt;label&gt;Name:&lt;/label&gt; &lt;!--注意键盘keyup修饰符:enter，还有tab,delete,space,esc,up,down,left,right--&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.enter=&quot;add&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加&quot; class=&quot;btn btn-primary&quot; @click=&quot;add&quot;&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;label&gt;按照商品名称检索商品:&lt;/label&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; @change=&quot;searchx&quot;&gt; &lt;/div&gt; &lt;table class=&quot;table table-bordered table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;CTime&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;item in searchx()&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;{{ item.id }}&lt;/td&gt; &lt;td&gt;{{ item.name }}&lt;/td&gt; &lt;td&gt;{{ item.ctime }}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue({ el: &quot;#app&quot;, data: { id:&quot;&quot;, name:&quot;&quot;, keyword:&quot;&quot;, list: [ {id:1,name:'丰田',ctime:new Date()}, {id:2,name:'奔驰',ctime:new Date()} ] }, methods: { add(){ this.list.push({id:this.id,name:this.name,ctime:new Date()}); this.id=&quot;&quot;; this.name=&quot;&quot;; }, del(id){ for(let i = 0;i &lt; this.list.length;i++){ if(this.list[i].id==id){ this.list.splice(i,1); break; } } }, searchx(){ let result=[]; for(let i=0;i&lt;this.list.length;i++){ if(this.list[i].name.indexOf(this.keyword)!=-1){ result.push(this.list[i]); } } return result; } } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 过滤器 Vue.js中允许你自定义过滤器，可以用作常见的文本格式化 可以用在两个地方：插值表达式 &amp; v-bind 表达式 自定义全局过滤器 123456789&lt;!--插值表达式中加入管道符--&gt;{{item.ctime | formatDate}}&lt;!--设置全局过滤器--&gt;Vue.filter({ &quot;formatDate&quot;, function(data){//这个回调函数的第一个参数默认永远是管道符前面的那个值 return moment(data).format(&quot;YYYY-MM-DD HH:mm:ss&quot;); }}) 私有过滤器 123456789101112var app = new Vue({ el: '#app', data: { msg:&quot;春节&quot; }, methods: {}, filters: { addStr: function(data){ return data+&quot;&quot; } }}) 全局和私有过滤器如果重名，会先用自己私有的。 自定义指令123456789101112131415161718192021222324252627282930//全局自定义获得焦点的on-focus指令//注意：Vue自定义指令的名称中，不需要v-前缀，但是在调用自定义指令时，需要在前面加上v-前缀Vue.direct('focus',{ //参数中的第一个参数永远是被绑定的那个元素 bind: function(el,binding){//当指令绑定的元素被vue实例解析时执行 binding.name;//获取指令的名称 binding.value;//获取指令等号后面的值 }, inserted: function(el){//当指令绑定的元素被插到父节点时调用 el.focus(); }})//自定义私有属性var vm = new Vue({ el: &quot;#app&quot;, data: {}, methods: {}, filters: {}, directives: { bold: { bind(el,binding){ }, inserted(el){ } } } }) 计算属性 这是一个有计算能力的属性，用来代替复杂表达式，计算实际上就是一个函数 实际上是一个能将计算结果缓存起来的属性（将行为转化成了静态的属性），可以理解为缓存。 computed和methods的区别是：一个是方法，一个是属性。 在浏览器中f12调试： vm.currentTime1：每次打印结果都不一样 vm.currentTime2：每次打印结果都和第一次一样.只有currentTime2计算中有东西发生了改变，才会重新刷新数据，这和缓存一模一样。 计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销。尤其是高并发系统。 1234&lt;div id=&quot;app&quot;&gt; &lt;p&gt;currentTime1 {{currentTime1()}}&lt;/p&gt; &lt;p&gt;currentTime2 {{currentTime2}}&lt;/p&gt;&lt;/div&gt; 12345678910111213141516var vm = new Vue({ el: &quot;#app&quot;, data: { message: &quot;hello&quot; }, methods: { currentTime1: function(){ return Date.now(); } } computed: { currentTime2: function(){ return Date.now(); } }}) vue生命周期 创建阶段：一个实例整个生命只执行一次 运行阶段：一个实例在整个生命周期中根据data改变与否有选择地执行0到多次 销毁阶段：一个实例整个生命只执行一次 在实例每个阶段中会伴随各种事件，这些事件统称为实例的 生命周期函数 / 生命周期钩子 / 生命周期事件，这些函数是vue自己执行，但是内容可能要自己写。 在new Vue()时，主要做了以下的事： 初始化data和methods 根据数据在内存中渲染出一棵DOM树 把创建好的DOM树挂载到页面上显示给用户【创建页面结束】 根据data数据的变化，有选择性的渲染DOM树 把重新渲染的DOM树再次挂载到页面上，从而保持data界面的同步 操作data和methods最早能在created中操作 操作DOM元素最早能在mounted中操作 12345678910111213141516171819202122232425262728293031var vm = new Vue({ el:'#app', data: {}, methods: {}, beforeCreate:function(){ console.log('before create') }, created:function(){ console.log('created') }, beforeMount:function(){ console.log(this.$el); console.log('before mount') }, mounted:function(){ console.log(this.$el); console.log('mounted') }, beforeDestroy:function(){ console.log('beforeDestroy') }, destroyed:function(){ console.log('destroyed') }, beforeUpdate:function(){ console.log('before updated') }, updated:function(){ console.log('updated') }}) 注意：最常用的生命周期函数是created函数，我们会在created钩子函数中：从服务器获取数据，并对数据进行初始化。 vue常用7大属性 el：指示vue编译器从什么地方开始解析vue的语法，可以说是一个占位符 data：组织从view中抽象出来的属性，可以说将视图的数据抽象出来放到data中 template：用来设置模板，会替换页面元素，包括占位符 methods：放置页面中的业务逻辑，js方法一般都放置在methods中 render：创建真正的Virtual Dom computed：用来计算 watch： watch:function(new,old)() 监听data中数据的变化 两个参数，一个返回新值，一个返回旧值 Vue组件实际开发中，不会用以上方式开发组件，而是采用vue-cli创建.vue模板文件的方式开发，以上方法只是为了说明啥是组件。 组件实际上就是一个自己定义标签元素的工具 123&lt;div&gt; &lt;comp-jack&gt;&lt;/comp-jack&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//全局组件注册Vue.component(&quot;comp-jack&quot;,{//组件名字所有字母小写，不用驼峰命名法（如果两个单词，中间用-连接） template: '&lt;li&gt;Hello&lt;/li&gt;', //组件中的data需要定义为函数的原因： //组件会被多次使用，多以data语法上必须是一个函数，每次使用时返回一个新的对象 //组件要在Vue实例中使用，所以最后一定要创建Vue实例 //组件中template的html语句中只能有一个根标签 data: function(){ return { count: 0 } }, methods: { increment(){ this.count++; } }});//局部组件注册const vm = new Vue({ el: &quot;#app&quot;, data: {}, components: { &quot;组件名&quot;:{ template:&quot;复用的html片段&quot;, data: function(){ return {}//return的对象，类似创建Vue时的data }, methods:{ //用于定义函数 } } }})//局部组件注册的更合理的写法1（结构更加清晰）let temp1 = { template:&quot;复用的html片段&quot;, data: function(){ return {}//return的对象，类似创建Vue时的data }, methods:{ //用于定义函数 }}let temp2 = { template:&quot;复用的html片段&quot;, data: function(){ return {}//return的对象，类似创建Vue时的data }, methods:{ //用于定义函数 }}const vm = new Vue({ el: &quot;#app&quot;, data: {}, components: { &quot;组件名1&quot;: temp1, &quot;组件名2&quot;: temp2 }})//局部组件注册的更合理的写法1（结构更加清晰）&lt;template id=&quot;t1&quot;&gt; 复用的html片段&lt;/template&gt;const vm = new Vue({ el: &quot;#app&quot;, data: {}, components: { &quot;组件名&quot;:{ template:&quot;#t1&quot;, data: function(){ return {}//return的对象，类似创建Vue时的data }, methods:{ //用于定义函数 } } }}) 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;大标题&lt;/h1&gt; &lt;div id=&quot;app&quot;&gt; &lt;jack v-for=&quot;item in items&quot; v-bind:j=&quot;item&quot;&gt;&lt;/jack&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;jack&quot;,{ props: ['j'], template: '&lt;li&gt;{{j}}&lt;/li&gt;' }); var app = new Vue({ el: '#app', data: { items: [&quot;Java&quot;,&quot;Linux&quot;,&quot;Windows&quot;] } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件的嵌套 在实际页面开发中很多组件都是存在嵌套行为的 顶层的组件直接在Vue对象实例中注册 如果一个组件时组件的组件，那么它应该是在组件的components属性中注册，一次类推可以得到多层组件的嵌套 注意：Vue中一切皆组件，最大的Vue实例实际也是一个组件 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;my-table&gt;&lt;/my-table&gt;&lt;/div&gt;&lt;template id=&quot;table-head&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;/template&gt;&lt;template id=&quot;table-body&quot;&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;1&lt;/th&gt; &lt;th&gt;Jack Yang&lt;/th&gt; &lt;th&gt;21&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;2&lt;/th&gt; &lt;th&gt;Sam Smith&lt;/th&gt; &lt;th&gt;28&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/template&gt;&lt;template id=&quot;my-table&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead is=&quot;table-head&quot;&gt;&lt;/thead&gt; &lt;thead is=&quot;table-body&quot;&gt;&lt;/thead&gt; &lt;/table&gt;&lt;/template&gt; 1234567891011121314151617181920const tableHead = { template: &quot;#table-head&quot;};const tableBody = { template: &quot;#table-body&quot;};const myTable = { template: &quot;#my-table&quot;, components: { &quot;table-head&quot;: tableHead, &quot;table-body&quot;: tableBody }};const vm = new Vue({ el: &quot;#app&quot;, components: { &quot;my-table&quot;: myTable }}) 组件通信一个复杂的界面一定有组件的嵌套，这时一定也会有组件之间通信的需求 组件通信—父传子 props：父组件向子组件正向传递参数通过props来实现 123456789101112131415161718192021222324&lt;div id=&quot;app&quot;&gt; &lt;my-table v-bind:us=&quot;users&quot;&gt;&lt;/my-table&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;my-table v-bind:us=&quot;users&quot;&gt;&lt;/my-table&gt;&lt;/div&gt;&lt;template id=&quot;my-table&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;u in us&quot; :key=&quot;u.id&quot;&gt; &lt;th&gt;{{ u.id }}&lt;/th&gt; &lt;th&gt;{{ u.name }}&lt;/th&gt; &lt;th&gt;{{ u.age }}&lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/template&gt; 1234567891011121314151617const myTable = { template: &quot;#my-table&quot;, props: [&quot;us&quot;]}const vm = new Vue({ el: &quot;#app&quot;, components: { &quot;my-table&quot;: myTable } data: { users: [ {id:1,name:&quot;jack1&quot;,age:11}, {id:2,name:&quot;jack2&quot;,age:12}, {id:3,name:&quot;jack3&quot;,age:13} ] }}) 组件通信—子传父 父组件的模板中包含子组件，经常会出现子组件的状态发生改变时，要通知到父组件。所有的prop都是的父子prop之间i形成了单向下行绑定。父级prop更新会向下更新到子组件中。但是反过来不行 举个栗子：就是上面中，子组件接收到了us，如果在子组件中改变了us的值，但是父组件中的users不会更改。这种更新只能是上级影响下级，下级不能影响上级。 $emit：子传父只能通过方法来传值 123456789&lt;!--父组件标签中绑定一个自定义事件,事件处理函数定义在父组件上，并且函数的参数就是子组件的$emit传递来的数据的形参--&gt;&lt;counter @自定义事件名=&quot;自定义事件处理函数&quot;&gt;&lt;/counter&gt;&lt;!--子组件中主动发射--&gt;methods: { increment(){ 方法处理代码; this.$emit(&quot;自定义事件名&quot;,传递的数据); }} 父子通信实战： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;my-table :us=&quot;users&quot; @emit-show-user=&quot;handleShowUser&quot;&gt;&lt;/my-table&gt; &lt;hr&gt; &lt;update-form :u=&quot;user&quot; @emit-update-user=&quot;handleUpdateUser&quot;&gt;&lt;/update-form&gt; &lt;/div&gt; &lt;template id=&quot;my-table&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(user, index) in us&quot; :key=&quot;index&quot;&gt; &lt;th&gt;{{ user.id }}&lt;/th&gt; &lt;th&gt;{{ user.name }}&lt;/th&gt; &lt;th&gt;{{ user.age }}&lt;/th&gt; &lt;th&gt; &lt;button @click=&quot;emitUser(index)&quot;&gt;更新&lt;/button&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/template&gt; &lt;template id=&quot;update-form&quot;&gt; &lt;form action=&quot;&quot; @submit.prevent=&quot;handleSubmit&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; v-model=&quot;u.id&quot;&gt; 名字：&lt;input type=&quot;text&quot; name=&quot;name&quot; v-model=&quot;u.name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot; v-model=&quot;u.age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;更新&quot;&gt; &lt;/form&gt; &lt;/template&gt; &lt;script&gt; const myTable={ template: &quot;#my-table&quot;, props: [&quot;us&quot;], methods: { emitUser(index){ this.$emit(&quot;emit-show-user&quot;,this.us[index]); } } } const updateForm={ template: &quot;#update-form&quot;, props: [&quot;u&quot;], methods: { handleSubmit(){ this.$emit(&quot;emit-update-user&quot;,this.u); } } } const vm = new Vue({ el: &quot;#app&quot;, data: { users: [ {id:1,name:&quot;Jack&quot;,age:18}, {id:2,name:&quot;Mariah&quot;,age:19}, {id:3,name:&quot;Sam&quot;,age:20} ], user: {} }, components: { &quot;my-table&quot;:myTable, &quot;update-form&quot;:updateForm }, methods: { handleShowUser(u){ console.log(u); this.user = JSON.parse(JSON.stringify(u)); }, handleUpdateUser(u){ console.log(u); this.users.forEach((user,i,arr)=&gt;{ if(user.id==u.id){ //vue监控不到直接通过下标修改元素的操作 // arr[i]=u; this.$set(arr,i,JSON.parse(JSON.stringify(u)));//等同于arr[i]=u，但是可以被vue监控到 } }) } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由 路由：让请求按照其地址到达目的地 web路由的发展 网站路由的发展实际上和前后端分离的发展是同步的： Vue中路由的作用： 在Vue中的一个功能视图就是一个组件，Vue中的路由解决的是但页面中组件的显示切换问题。比如：一个页面中有两个超链接“登录”,“注册”,点击两个连接分别显示对应的表单 第一个路由示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/vue-router@3.0.1/dist/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;hr&gt; &lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;div&gt;I am a div&lt;/div&gt; &lt;!-- 使用路由，确定组件切换后显示的位置 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;!-- 定义组件 --&gt; &lt;template id=&quot;login-form&quot;&gt; &lt;form action=&quot;&quot;&gt; Username：&lt;input type=&quot;text&quot;&gt;&lt;br&gt; Password：&lt;input type=&quot;text&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/template&gt; &lt;template id=&quot;register-form&quot;&gt; &lt;form action=&quot;&quot;&gt; Username：&lt;input type=&quot;text&quot;&gt;&lt;br&gt; Password：&lt;input type=&quot;text&quot;&gt;&lt;br&gt; RePassword：&lt;input type=&quot;text&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/template&gt; &lt;script&gt; //定义组件 const loginForm = { template: &quot;#login-form&quot;, } const registerForm = { template: &quot;#register-form&quot;, } //创建路由对象，定义路由规则 const MyRouter = new VueRouter({ routes: [ {name:&quot;login&quot;,path:&quot;/login&quot;,component:loginForm}, {name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm} ] }) //在Vue实例中配置router const vm = new Vue({ el: &quot;#app&quot;, router: MyRouter }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; router-link &amp; redirect123456789101112&lt;!--此时，在连接前不用加上#了--&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;!--进入页面默认跳到某个组件--&gt;&lt;!--在路由对象中定义routes时候--&gt;&lt;script&gt; routes: [ {name:&quot;login&quot;,path:&quot;/&quot;,redirect:&quot;/login&quot;},//进入/时，默认执行/login路由 {name:&quot;login&quot;,path:&quot;/login&quot;,component:loginForm}, {name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm} ]&lt;/script&gt; 嵌套路由 1234567891011121314151617&lt;!--要使点击第二层的router-link后显示的内容在第二层的router-view里，而不是第一层的router-view里，需要在路由对象中定义routes的时候，将第二层的路由信息写在父路由信息中--&gt;&lt;script&gt; routes: [ {name:&quot;login&quot;,path:&quot;/&quot;,redirect:&quot;/login&quot;},//进入/时，默认执行/login路由 { name:&quot;login&quot;, path:&quot;/login&quot;, component:loginForm, children:[ {name:&quot;phoneLogin&quot;,path:&quot;/phone&quot;,component:phoneLoginForm}, {name:&quot;accountLogin&quot;,path:&quot;/account&quot;,component:accountLoginForm}, ] }, {name:&quot;register&quot;,path:&quot;/register&quot;,component:registerForm} ]&lt;/script&gt; 路由传参query传参 导航路由地址里用?name=jack&amp;age=18传参，在组件中要获得参数，需要使用内置属性：{{$route.query.name}},{{$route.query.age}} 在router-link中还可以只用如下方式动态传参： 1&lt;router-link :to=&quot;{path:'/login/account',query:{name:'Jack',age:18}}&quot;&gt;&lt;/router-link&gt; params传参 12345//这个:name代表他能动态地匹配数据//属于restful风格（路径中包含一部分数据）{name:&quot;product&quot;,path:&quot;/product/:name&quot;,component:myComponent}//通过如下方式获取{{ $route.params.name }} 在router-link中可使用如下方式传参： 1&lt;router-link :to=&quot;{name:'product',params:{name:'Jack'}}&quot;&gt;&lt;/router-link&gt; 编程式的路由导航1$router.push(&quot;/login&quot;); Axios Axios是一个开源的可以用在浏览器端和NodeJS的异步通信框架，它的主要作用是实现AJAX异步通信。 由于Vue.js是一个视图层框架，作者严格遵循SoC原则，所以Vue.js没有AJAX通信功能，为了解决通信功能。作者单独开发了一个vue-resource插件。但是进入vue2.0后停止了对该插件的维护并推荐Axios插件。 对于AJAX通信，要少用JQuery，因为它对DOM的操作过于频繁 针对GET的Axios请求 针对POST的Axios请求 Axios的别名方法1234567891011axios.get(url,{ params:{ username:this.username, password:this.password }})axios.post(url,Qs.stringify({ username:this.username, password:this.password})) vue-cli vue-cli（Vue command-line-interface）是官方提供的一个脚手架，用于快速开发生成一个vue的项目模板 脚手架就是预先定义好的目录结构和基础代码，就像创建maven项目时可以选择创建一个初始骨架项目。这种脚手架能让我们开发更加迅速。 主要功能： 统一的目录结构 本地调试 热部署 单元测试 集成打包上线 12345cnpm install vue-cli -gvue init webpack myvueName#vue-cli的3.0+以后使用的不是vue-cli了，如果用以上的安装命令安装的并不是最新版的3.0+的，而如果安装3.0的话就需要使用新的cnpm install @vue/cli -g Vue-cli项目的目录分析： bulid：配置好了的文件，保存的是webpack打包工具的底层配置 config：关于vue的配置（端口号啥的） node_modules：项目依赖的各个包，类似于java的lib目录 src：代码储存地，我们写代码的地方 assets：静态资源（图片） component：存放一个个的组件，.vue文件表示一个组件 router：路由文件 App.vue：根组件vue文件 main.js：整个项目的入口 static：放一些静态的文件，不建议使用，一般被assets替代 index.html：vue的入口页面，只有一个div标签 package.json：相当于maven中的pom.xml文件，包管理文件 .vue文件传统的template定义方式：先定义一个template标签，然后全局或者私有地定义一个component。这种方式在很多中小规模的项目中运行的很好，这些项目中JavaScript之被用来加强特定的视图，但是当更加复杂的项目中，当你的前端完全由JavaScript驱动的时候，以下的缺点将会非常明显： 全局定义会强制要求每个component中的命名不重复 不支持CSS意味着当HTML和JavaScript组件化时，CSS明显被遗弃 可读性差，维护难度高，多个组件定义在一起，代码显得更加臃肿复杂 基于以上传统的vue组件的定义方式，.vue结尾的vue专属文件single-file-components（单文件组件）为以上所有问题提供了解决方法。 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //使用export标签将组件导出，需要使用组件的文件就可以使用import导入 export default { name: 'App' }&lt;/script&gt;&lt;style&gt; #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; }&lt;/style&gt; 总结（基于脚手架开发の规约） index.html日后不会被修改 App.vue作为根组件，定义了页面的基本结构，日后开发中，根据需求修改它 在components中新建了.vue文件来定义组件 在router/index.js中定义了路由规则 在main.js中引入了项目需要的库 基于Vue-cli和SSM搭建前后端分离项目 安装axios和qs库 1npm install --save axios vue-axios qs 引入 &amp; 配置包供全局使用 12345678910import qs from 'qs'import axios from 'axios'import VueAxios from 'vue-axios'//在所有的Vue组件中可以通过使用this.$qs使用qs库Vue.prototype.$qs = qs//配置后端服务地址（axios的默认请求前缀）axios.defaults.baseURL = &quot;http://localhost:8080&quot;//在Vue中配置axios，在所有Vue组件中可以通过this.axios使用axios库Vue.use(VueAxios,axios) 跨域问题 由于浏览器的同源策略限制，当一个请求url（后端部署服务器的地址）的协议、域名、端口三者之间任意一个与当前页面url（前端部署服务器的地址）不同即为跨域 F12控制台报错显示： 1Access to XMLHttpRequest at 'http://localhost:8080/show?pageNum=1&amp;pageSize=3' from origin 'http://localhost:8081' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 跨域问题的解决：（服务端和浏览器端都要做响应配置） 前端配置： 12//main.js中添加如下配置axios.defaults.withCredentials = true 服务端配置 12345//添加响应头//设置允许跨域共享资源的前端地址resp.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://localhost:8080&quot;);//允许client跨域请求时携带cookieresp.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;); 1234567891011121314151617181920212223 //也可以将以上代码做成过滤器并在web.xml中配置过滤器 public class AccessControlAllowFilter implements Filter { @Overridepublic void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) servletResponse; //设置允许跨域共享资源的前端地址 response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://localhost:8081&quot;); //允许client跨域请求时携带cookie response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } 12345678910&lt;filter&gt; &lt;filter-name&gt;AccessControlAllowFilter&lt;/filter-name&gt; &lt;filter-class&gt; jack.filter.AccessControlAllowFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AccessControlAllowFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Webpack webpack本质上是一个现代的Javascript应用程序的静态模块打包器。它会递归构建一个依赖关系图，其中包含应用程序所需的每个模块，然后将所有模块构成一个或多个bundle webpack是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过loader转换，任何形式的资源都可以当作模块。 移动互联网来临，更多的网页进化到了WebApp模式。它通常是一个SPA（单页面应用），每一个视图通过异步的方式加载，页面初始化和使用过程中会导致越来越多的JavaScript代码，这回给前端的开发流程和资源组织带来巨大压力。 安装WebPackwebpack是一款模块加载器兼打包工具，他能把各种资源：如JavaScript，JSX，ES6，SASS，LESS，图片等资源作为模块来处理和使用。打包后直接把ES6规范降级为ES5了，这样所有浏览器就都支持了。 12345cnpm install webpack -gcnpm install webpack0-cli -g#验证安装是否成功webpack -vwebpack-cli -v webpack.config.js配置文件解析 entry：入口文件，制定webpack用哪个文件作文项目的入口 output：输出，制定webpack将处理后的文件放在哪里 modlule：模块，用于处理各种类型的文件 plugin：插件，如：热更新，代码重用 resolve：设置路径指向 watch：监听，用于设置文件改动后直接打包","link":"/2021/01/05/vue%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"JavaSE","slug":"JavaSE","link":"/tags/JavaSE/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"分享","slug":"分享","link":"/tags/%E5%88%86%E4%BA%AB/"},{"name":"Win10","slug":"Win10","link":"/tags/Win10/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Makefile","slug":"Makefile","link":"/tags/Makefile/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"ElementUI","slug":"ElementUI","link":"/tags/ElementUI/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"想法","slug":"想法","link":"/tags/%E6%83%B3%E6%B3%95/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Activiti","slug":"Activiti","link":"/tags/Activiti/"},{"name":"旅游","slug":"旅游","link":"/tags/%E6%97%85%E6%B8%B8/"},{"name":"摄影","slug":"摄影","link":"/tags/%E6%91%84%E5%BD%B1/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"JQuery","slug":"JQuery","link":"/tags/JQuery/"},{"name":"历史","slug":"历史","link":"/tags/%E5%8E%86%E5%8F%B2/"},{"name":"战争","slug":"战争","link":"/tags/%E6%88%98%E4%BA%89/"},{"name":"股票","slug":"股票","link":"/tags/%E8%82%A1%E7%A5%A8/"},{"name":"理财","slug":"理财","link":"/tags/%E7%90%86%E8%B4%A2/"},{"name":"经济","slug":"经济","link":"/tags/%E7%BB%8F%E6%B5%8E/"},{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"JavaEE","slug":"JavaEE","link":"/tags/JavaEE/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"分享","slug":"分享","link":"/categories/%E5%88%86%E4%BA%AB/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"}]}